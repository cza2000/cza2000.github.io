<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>陈子桉的博客</title>
        <link>https://ziannchen.work/</link>
        <description>Recent content on 陈子桉的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <lastBuildDate>Wed, 16 Feb 2022 23:15:13 +0800</lastBuildDate><atom:link href="https://ziannchen.work/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>CMU 15-445 Project 1: Buffer Pool Manager</title>
        <link>https://ziannchen.work/2022/cmu-15-445-project-1-buffer-pool-manager/</link>
        <pubDate>Wed, 16 Feb 2022 23:15:13 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/cmu-15-445-project-1-buffer-pool-manager/</guid>
        <description>&lt;p&gt;buffer pool 负责将物理页在内存与磁盘之间来回移动，它允许 DBMS 支持大于系统可用内存量的数据库。缓冲池的操作对系统中的其他部分是透明的。例如，系统使用其唯一标识符 page_id 向 buffer pool 请求一个页面，但系统不需要知道该页面是否已在内存中，由 buffer pool 负责在被请求的页面不在内存中时从磁盘检索该页面，并完成可能的内存页面替换。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://ziannchen.work/img/BufferPoolManager/1.png#pic_center&#34; &gt;
		&lt;img src=&#34;https://ziannchen.work/img/BufferPoolManager/1.png#pic_center&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;图片 1&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;图片 1&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;lru-replacer&#34;&gt;LRU Replacer&lt;/h2&gt;
&lt;p&gt;该组件负责跟踪缓冲池中的页面使用情况。&lt;/p&gt;
&lt;p&gt;在内存中且未在被使用（被 Unpin）的 Page 对应的 frame 的 id 会进入 LRUReplacer，等待在内存已满且需要从磁盘中交换页面时被淘汰。LRU 替换策略要求我们能根据最近的被使用时间来选择淘汰目标，一个简单的想法就是使用一个链表记录每一个元素，新加入的在链表头，那么链表尾的自然就是最近最少被使用的。Pin 操作需要在其中检索并删除元素，则又需要一个哈希表记录每个元素在链表中的位置。此外，还需要一个锁来保证线程安全。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;LRUReplacer&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;public&lt;/span&gt; Replacer {
    ···
&lt;span style=&#34;color:#ff79c6&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;
    size_t num_pages_;
    std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;mutex latch_;
    std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;list&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;frame_id_t&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt; lru_list_;
    std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;unordered_map&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;frame_id_t, std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;list&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;frame_id_t&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;::&lt;/span&gt;iterator&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt; lru_map_;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面的实现就非常简单了，注意几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个函数都要加锁，可以使用 &lt;code&gt;std::lock_guard&lt;/code&gt;，类似 golang 中的 &lt;code&gt;defer&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在实现 &lt;code&gt;Unpin&lt;/code&gt; 时确保链表的长度不超过 LRUReplacer 的容量，已满时先从链表末尾删除再将新的加入链表头。不要忘了操作哈希表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;buffer-pool-manager&#34;&gt;Buffer Pool Manager&lt;/h2&gt;
&lt;p&gt;BufferPoolManager 负责从 DiskManager 获取数据库的物理页面并将它们存储在内存中。BufferPoolManage 还可以在被要求或者需要时淘汰一个页以便为新页腾出空间时，将脏页写入磁盘。&lt;/p&gt;
&lt;p&gt;系统中的所有内存页面均由 Page 对象表示，BufferPoolManager 类维护了一个存放 Page 类型对象的数组。Page 对象只是缓冲池中用于存储内存页面的容器，因此并不特定于唯一页面。也就是说，每个 Page 对象都包含一块内存（data_），被认为是存放 &amp;ldquo;DiskManager 从磁盘读取到的物理页面内容&amp;rdquo; 的位置，project 2将会调用 Page::GetData 方法获取指向 data_ 的指针，再使用 reinterpret_cast 将其转换为其他类型的指针。BufferPoolManager 将在把物理页面从内存来回移动到磁盘时重用相同的 Page 对象来存储不同页面的数据。这意味着在系统的整个生命周期中，相同的 Page 对象可能包含不同的物理页面。Page 对象的标识符（page_id）跟踪其当前包含的物理页面。如果 Page 对象不再包含物理页面，则必须将其 page_id 设置为INVALID_PAGE_ID。&lt;/p&gt;
&lt;p&gt;每个 Page 对象还维护一个计数器(pin_count)，以表示正在使用该页面的线程数，类似引用计数。BufferPoolManager 不允许淘汰 pinned page。每个Page对象还跟踪它的脏标记（is_dirty）。页面在被淘汰之前必须要判断是否是脏页，脏页的内容要被写回磁盘，然后才能重用该对象。&lt;/p&gt;
&lt;p&gt;BufferPoolManager实现将使用 Task 1 中实现的 LRUReplacer 类。它将使用 LRUReplacer 来跟踪页对象何时被访问过，以便在必须释放一个帧以为从磁盘复制新的物理页腾出空间时，它可以决定淘汰哪个页对象。&lt;/p&gt;
&lt;p&gt;先来看一下 &lt;code&gt;Buffer Pool Manager&lt;/code&gt; 以及 &lt;code&gt;Page&lt;/code&gt; 的结构，frame_id 是用来访问 pages_ 数组的下标，page table 用于存储 page_id -&amp;gt; frame_id 的映射，这样就可以用 page_id 找到对应的 Page 对象。free_list 表示未含有实际内存页面的 Page 对象的 frame_id。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;BufferPoolManager&lt;/span&gt; {
    ···
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** Number of pages in the buffer pool. */&lt;/span&gt;
    size_t pool_size_;
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** Array of buffer pool pages. */&lt;/span&gt;
    Page &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;pages_;
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** Pointer to the disk manager. */&lt;/span&gt;
    DiskManager &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;disk_manager_ &lt;span style=&#34;color:#50fa7b&#34;&gt;__attribute__&lt;/span&gt;((__unused__));
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** Pointer to the log manager. */&lt;/span&gt;
    LogManager &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;log_manager_ &lt;span style=&#34;color:#50fa7b&#34;&gt;__attribute__&lt;/span&gt;((__unused__));
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** Page table for keeping track of buffer pool pages. */&lt;/span&gt;
    std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;unordered_map&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;page_id_t, frame_id_t&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt; page_table_;
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** Replacer to find unpinned pages for replacement. */&lt;/span&gt;
    Replacer &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;replacer_;
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** List of free pages. */&lt;/span&gt;
    std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;list&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;frame_id_t&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt; free_list_;
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** This latch protects shared data structures. We recommend updating this
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;     * comment to describe what it protects. */&lt;/span&gt;
    std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;mutex latch_;
};

&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Page&lt;/span&gt; {
    ···
&lt;span style=&#34;color:#ff79c6&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** The actual data that is stored within a page. */&lt;/span&gt;
    &lt;span style=&#34;color:#8be9fd&#34;&gt;char&lt;/span&gt; data_[PAGE_SIZE]{};
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** The ID of this page. */&lt;/span&gt;
    page_id_t page_id_ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; INVALID_PAGE_ID;
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** The pin count of this page. */&lt;/span&gt;
    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; pin_count_ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** True if the page is dirty, i.e. it is different from its corresponding
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;     * page on disk. */&lt;/span&gt;
    &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt; is_dirty_ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;false&lt;/span&gt;;
    &lt;span style=&#34;color:#6272a4&#34;&gt;/** Page latch. */&lt;/span&gt;
    ReaderWriterLatch rwlatch_;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://ziannchen.work/img/BufferPoolManager/2.png#pic_center&#34; &gt;
		&lt;img src=&#34;https://ziannchen.work/img/BufferPoolManager/2.png#pic_center&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;图片 2&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;图片 2&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;翻译完这一大段话，话不多说直接来实现，每个函数的注释提示都比较详细了。&lt;/p&gt;
&lt;p&gt;先说几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要忘了加锁 bpm 的 latch。&lt;/li&gt;
&lt;li&gt;NewPage 和 FetchPage 返回前要自增 pin count，这是因为这两个方法被调用是因为某个线程想要使用该页面。&lt;/li&gt;
&lt;li&gt;每个 Page 对象都有一个 rwlatch，但是不要滥用。在修改元数据的时候不需要加锁，只有在将页面写入磁盘、从磁盘读取页面时候需要加锁。这个锁是留给 Project 2 的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;helper-method&#34;&gt;Helper method&lt;/h3&gt;
&lt;p&gt;FetchPage 和 NewPage 都需要找到一个 replacement page，这里的代码可以复用。先在 free list 中找，再尝试让 replacer 去选取一个 Vitctim Page，这是因为 free list 中都是没有内容的 Page，一定不需要被写入磁盘。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt; BufferPoolManager&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;FindVictimPage(frame_id_t &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;frame_id) {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#ff79c6&#34;&gt;!&lt;/span&gt;free_list_.empty()) {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;frame_id &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; free_list_.front();
        free_list_.pop_front();
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;true&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (replacer_&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;Victim(frame_id)) {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;true&lt;/span&gt;;
    }

    frame_id &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nullptr&lt;/span&gt;;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;false&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;fetchpageimpl&#34;&gt;FetchPageImpl&lt;/h3&gt;
&lt;p&gt;一个进程需要使用一个页面，bpm需要根据指定的 page_id 返回存放对应物理页面的 Page。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先在 page table 中找 page_id 是否存在对应的 frame_id。
&lt;ul&gt;
&lt;li&gt;如果存在，就直接返回对应的 Page。返回前需要自增 pin_count 并调用 replacer_-&amp;gt;Pin。&lt;/li&gt;
&lt;li&gt;如果不存在，就从 free list 或 replacer 中寻找一个 replacement page，若找不到，返回 nullptr。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 replacement page 是脏页，将其写入磁盘并重置 is_dirty。&lt;/li&gt;
&lt;li&gt;修改 page table 以及 Page 对象的元数据，从磁盘中读取 page_id 对应的物理页面。不要忘了调用 replacer_-&amp;gt;Pin，以及 pin count置为1。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Page &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;BufferPoolManager&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;FetchPageImpl(page_id_t page_id) {
    std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;lock_guard&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;mutex&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt; lock_(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;latch_);

    std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;unordered_map&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;page_id_t, frame_id_t&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;
        page_table_.find(page_id);

    frame_id_t frame_id;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (it &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; page_table_.end()) {
        frame_id &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; it&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;second;
        Page &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;page &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;pages_[frame_id];
        page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;pin_count_&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;;

        replacer_&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;Pin(frame_id);
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; page;
    }

    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#ff79c6&#34;&gt;!&lt;/span&gt;FindVictimPage(&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;frame_id)) {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nullptr&lt;/span&gt;;
    }

    Page &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;page &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;pages_[frame_id];
    page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;WLatch();
    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;IsDirty()) {
        disk_manager_&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;WritePage(page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;GetPageId(), page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;GetData());
        page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;is_dirty_ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;false&lt;/span&gt;;
    }

    page_table_.erase(page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;GetPageId());
    page_table_[page_id] &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; frame_id;

    disk_manager_&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;ReadPage(page_id, page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;GetData());

    page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;page_id_ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; page_id;
    page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;pin_count_ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;;
    replacer_&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;Pin(frame_id);
    page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;WUnlatch();

    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; page;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;unpinpageimpl&#34;&gt;UnpinPageImpl&lt;/h3&gt;
&lt;p&gt;一个进程不再使用这个页面之后，将会调用 UnpinPage。Buffer Pool Manager  需要更新其对应的 pin count，is dirty。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尝试在页表中搜索 page_id。如果没有则需要返回 &lt;code&gt;true&lt;/code&gt;。我也不知道为啥，感觉有点奇怪。&lt;/li&gt;
&lt;li&gt;如果该 page 的 pin count &amp;lt;= 0，返回 false。&lt;/li&gt;
&lt;li&gt;当函数入参 is_dirty 为真时置 page 的 is_dirty 为真。如果入参不为真，不要把原来 page 的标志搞没了。&lt;/li&gt;
&lt;li&gt;pin_count 自减，如果降为0，表示没有任何线程在使用该 page 了，调用 replacer 的 Unpin。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;flushpageimpl&#34;&gt;FlushPageImpl&lt;/h3&gt;
&lt;p&gt;将一个页面写入磁盘，这里不需要判断 is dirty 和 pin count。&lt;/p&gt;
&lt;p&gt;在页表中搜索该页。若不存在，返回 false；若存在，调用 disk_manager 的 WritePage 方法将页面写回磁盘。需要对该页加读锁。&lt;/p&gt;
&lt;h3 id=&#34;newpageimpl&#34;&gt;NewPageImpl&lt;/h3&gt;
&lt;p&gt;新建一个页面，并返回该页的 page_id 和 Page 对象。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先循环判断是否缓冲池中的所有 Page 都为 pinned，如果是则返回 nullptr。新建的页面要先写入缓冲池中的一个 Page，被 pin 过的 Page 不能被淘汰。&lt;/li&gt;
&lt;li&gt;从 free list 或 replacer 中寻找一个 replacement page，若无法找到则返回。这里复用之前的 help method FindVictimPage。&lt;/li&gt;
&lt;li&gt;如果该 replacement page 是脏的，将其写回磁盘。使用 DiskManager::AllocatePage 方法获得一个新的 page_id 赋给这个 Page 对象，修改 page table。不要忘了调用 ResetMemory 以及置 pin_count = 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Page &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;BufferPoolManager&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;NewPageImpl(page_id_t &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;page_id) {
    std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;lock_guard&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;mutex&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt; lock_(&lt;span style=&#34;color:#ff79c6&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;latch_);
    &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt; all_pinned &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;true&lt;/span&gt;;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; (size_t i &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt; pool_size_; &lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;i) {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;auto&lt;/span&gt; page &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;pages_[i];
        &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;GetPinCount() &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;) {
            &lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;;
        }

        all_pinned &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;false&lt;/span&gt;;
        &lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (all_pinned) {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nullptr&lt;/span&gt;;
    }

    frame_id_t frame_id;
    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#ff79c6&#34;&gt;!&lt;/span&gt;FindVictimPage(&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;frame_id)) {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nullptr&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;page_id &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; disk_manager_&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;AllocatePage();
    Page &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;page &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;pages_[frame_id];
    page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;WLatch();
    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;IsDirty()) {
        disk_manager_&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;WritePage(page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;GetPageId(), page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;GetData());
        page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;is_dirty_ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;false&lt;/span&gt;;
    }

    page_table_.erase(page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;GetPageId());
    page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;page_id_ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;page_id;
    page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;is_dirty_ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;false&lt;/span&gt;;
    page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;pin_count_ &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;;

    page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;ResetMemory();
    page_table_[&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;page_id] &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; frame_id;
    page&lt;span style=&#34;color:#ff79c6&#34;&gt;-&amp;gt;&lt;/span&gt;WUnlatch();
    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; page;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;deletepageimpl&#34;&gt;DeletePageImpl&lt;/h3&gt;
&lt;p&gt;删除一个页面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在页表中搜索该页，如果不存在则返回 true。&lt;/li&gt;
&lt;li&gt;如果该页的 pin count 大于 0，返回false。这代表有线程正在使用该页。&lt;/li&gt;
&lt;li&gt;调用 DiskManager::DeallocatePage 从磁盘删除该页，从页表删除该页对应的项，调用 ResetMemory 清空该 Page 对象的数据，置 page_id 为 INVALID_PAGE_ID，将该页加入 free list。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;flushallpagesimpl&#34;&gt;FlushAllPagesImpl&lt;/h3&gt;
&lt;p&gt;将所有页面写回磁盘，这个没啥好说的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>开个坑，准备开始接着写cmu 15-445</title>
        <link>https://ziannchen.work/2022/%E5%BC%80%E4%B8%AA%E5%9D%91%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B%E6%8E%A5%E7%9D%80%E5%86%99cmu-15-445/</link>
        <pubDate>Thu, 10 Feb 2022 20:01:39 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/%E5%BC%80%E4%B8%AA%E5%9D%91%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B%E6%8E%A5%E7%9D%80%E5%86%99cmu-15-445/</guid>
        <description>&lt;p&gt;在知乎上刷到了很多次 cmu 15-445，尽管数据库这课我只考了60多分 and 不咋用c++，但也在上个学期开始尝试写了一点。之后由于 b+树太难 / c++不熟悉 / 想去写 tinykv / 懒 种种原因搁置了。&lt;/p&gt;
&lt;p&gt;工作了之后感觉不会再有这样的大段空闲时间来写lab了，最近打算重启这个lab，立个flag一定要在毕业前写完并写出解析发在博客上。由于下个学期还要浪/做毕设/学工作要用的东西/可能会去实习，咱就是说也不知道啥时候能写完。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>TinyKV Project4: Transaction</title>
        <link>https://ziannchen.work/2022/tinykv-project4-transaction/</link>
        <pubDate>Sat, 05 Feb 2022 21:26:29 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/tinykv-project4-transaction/</guid>
        <description>&lt;p&gt;在之前的几个 projects 中，我们已经构建起了基于 multi-raft 的分布式KV数据库。在 project 4 中，我们将构建一个事务系统以应对多个 clinet 的并发请求并保证快照隔离（snapshot isolation）。&lt;/p&gt;
&lt;p&gt;我们将基于&lt;code&gt;Percolator&lt;/code&gt;的两阶段提交协议来构建我们的事务模型。&lt;/p&gt;
&lt;h2 id=&#34;part-amvcc&#34;&gt;Part A：MVCC&lt;/h2&gt;
&lt;p&gt;在part A中我们需要实现MVCC即多版本并发控制（multi-version concurrency control）。&lt;code&gt;tinykv&lt;/code&gt;的底层存储&lt;code&gt;Badger&lt;/code&gt;为我们提供了3个&lt;code&gt;column family&lt;/code&gt;：&lt;code&gt;CfDefault&lt;/code&gt;、&lt;code&gt;CfLock&lt;/code&gt;、&lt;code&gt;CfWrite&lt;/code&gt;，对应了论文中提到的3个列：&lt;code&gt;data&lt;/code&gt;、&lt;code&gt;lock&lt;/code&gt;、&lt;code&gt;write&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CfDefault&lt;/code&gt;：用于暂时存储对应key的value值，将由MVCC机制来决定之后该值是否被commit或者被delete（即回滚）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CfLock&lt;/code&gt;：用于存储锁，如果某key存在对应key的lock，说明它正在被某个事务修改。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CfWrite&lt;/code&gt;：用来存储key的每个版本value值的提交时间(commit version)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WriteKind&lt;/code&gt;：Lock和Write都有一个write kind属性来记录本次对key进行了什么样的修改。有三种，分别是Put、Delete和Rollback。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们依据论文，使用&lt;code&gt;Badger&lt;/code&gt;提供的读写api来完成 &lt;code&gt;transaction.go&lt;/code&gt; 中的&lt;code&gt;MvccTxn&lt;/code&gt;和它的方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// MvccTxn groups together writes as part of a single transaction. It also provides an abstraction over low-level
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// storage, lowering the concepts of timestamps, writes, and locks into plain keys and values.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; MvccTxn &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	StartTS &lt;span style=&#34;color:#8be9fd&#34;&gt;uint64&lt;/span&gt;
	Reader  storage.StorageReader
	writes  []storage.Modify
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;MvccTxn struct中需要包含事务开始的timestamp &lt;code&gt;StartTS&lt;/code&gt;，底层存储的&lt;code&gt;Reader&lt;/code&gt;和用来将一系列写操作原子化的&lt;code&gt;writes&lt;/code&gt;数组。&lt;/p&gt;
&lt;p&gt;这里需要注意一下&lt;code&gt;CfDefault&lt;/code&gt;、&lt;code&gt;CfLock&lt;/code&gt;、&lt;code&gt;CfWrite&lt;/code&gt;这三个&lt;code&gt;column family&lt;/code&gt;的key/value编码方式。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;CfDefault&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(key, StartTS)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;value&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;CfLock&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;key&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;lock&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;CfWrite&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;(key, commitTS)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;write&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;写、删除只需构建一个&lt;code&gt;storage.Modify&lt;/code&gt;结构添加到&lt;code&gt;MvccTxn&lt;/code&gt;的&lt;code&gt;writes&lt;/code&gt;中即可。读操作的实现稍微复杂。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GetValue&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GetValue finds the value for key, valid at the start timestamp of this transaction.
I.e., the most recent value committed before the start of this transaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据注释，这个方法要求我们读出在事务开始之前最晚写入的值。在论文中提到：一个值只有被commit后才对其他事务可见，表现为一个write记录。很容易想到应该去读 &lt;code&gt;CfWrite&lt;/code&gt; 这个CF。又根据方法EncodeKey的编码规则，key按照userkey升序，userkey相同时按照timestamp降序，我们可以适当编码key并调用seek，使迭代器指向 &lt;code&gt;CfWrite&lt;/code&gt; 这个CF中事务开始之前最晚写入的值。此后还需要注意两点：得到的write的key可能不等于userkey，需要特判；判断write的类型可能为&lt;code&gt;WriteKindDelete&lt;/code&gt;，这表示这个userkey已经被删除，应该返回nil。最后根据write中的StartTS从&lt;code&gt;CfDefault&lt;/code&gt;中读取value。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CurrentWrite&lt;/p&gt;
&lt;p&gt;我们需要搜索：对于key，startTS和事务的开始时间相同的write。&lt;/p&gt;
&lt;p&gt;我们可以直接遍历 &lt;code&gt;CfWrite&lt;/code&gt; 这个CF从中找到符合条件的write。从中找到由于userkey相同时key的编码按timestamp降序，我们在调用EncodeKey时将timestamp设置为&lt;code&gt;^uint64(0)&lt;/code&gt;，之后即可遍历对于userkey的所有write。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MostRecentWrite&lt;/p&gt;
&lt;p&gt;我们需要找到对于给定的userkey最迟的write。使用和&lt;code&gt;CurrentWrite&lt;/code&gt;中相似的编码方式，在 &lt;code&gt;CfWrite&lt;/code&gt; 中查找即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;part-bc-transactional-api&#34;&gt;Part B&amp;amp;C: transactional API&lt;/h2&gt;
&lt;p&gt;在Part B中我们需要实现&lt;code&gt;KvGet&lt;/code&gt;, &lt;code&gt;KvPrewrite&lt;/code&gt;, 和&lt;code&gt;KvCommit&lt;/code&gt;三个request handler。&lt;/p&gt;
&lt;h3 id=&#34;kvget&#34;&gt;KvGet&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;KvGet&lt;/code&gt; 根据事务的StartTS读出key对应的value，应当判断该key在读事务的StartTS处是否被其他事务上锁，即查找key是否存在锁且锁的startTS是否早于事务的startTS。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	txn &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; mvcc.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewMvccTxn&lt;/span&gt;(reader, req.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetVersion&lt;/span&gt;())
	lock, err &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; txn.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetLock&lt;/span&gt;(key)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;, err
	}

	&lt;span style=&#34;color:#6272a4&#34;&gt;// lock&amp;#39;s ts &amp;lt;= txn&amp;#39; ts means the key are locked before txn start and not commited yet
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; lock &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; lock.Ts &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;=&lt;/span&gt; txn.StartTS {
		resp.Error = &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;kvrpcpb.KeyError{
			Locked: &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;kvrpcpb.LockInfo{
				PrimaryLock: lock.Primary,
				LockVersion: lock.Ts,
				Key:         key,
				LockTtl:     lock.Ttl,
			},
		}
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; resp, &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;若key未被上锁，调用 &lt;code&gt;GetValue&lt;/code&gt; 读取。&lt;/p&gt;
&lt;h3 id=&#34;kvprewrite&#34;&gt;KvPrewrite&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;KvPrewrite&lt;/code&gt; 先检查每一个key是否可以被写入，并对每一个key上一个指向primary key的锁 。 &lt;code&gt;KvCommit&lt;/code&gt; 检查所有锁是否仍有效并commit所有key。它们共同构成了 &lt;code&gt;Percolator&lt;/code&gt; 事务的两阶段提交。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;KvPrewrite&lt;/code&gt; 需要将value写入每个key的data列，并对该key上锁以防止其他事务的写冲突（即分别写入 &lt;code&gt;CfDefault&lt;/code&gt; 和 &lt;code&gt;CfLock&lt;/code&gt;）。在此之前需要判断没有其他事务也对相同的key上锁或写入。我们应循环检查每一个key是否可以被合法的prewirte。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先应该判断是否有其他事务在本事务开始之后提交了相同key的commit，若有则需要记录该冲突并检查下一个key。这里可以调用 &lt;code&gt;MostRecentWrite&lt;/code&gt; 来找到对于key最近的commit记录，再判断是否冲突（冲突即commitTs &amp;gt; 事务的version）。&lt;/li&gt;
&lt;li&gt;检查key是否在事务开始之前被加锁。&lt;/li&gt;
&lt;li&gt;在本地事务中写入value、lock。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;循环结束后应判断是否出现冲突，若出现冲突则直接abort本次事务，防止写-写冲突。若没有冲突，调用&lt;code&gt;storage.Write&lt;/code&gt;提交对于&lt;code&gt;CfDefaule&lt;/code&gt;和&lt;code&gt;CfLock&lt;/code&gt;的写入。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;KvCommit&lt;/code&gt; 需要先检查所有的锁的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若锁不存在，表明可能原事务rollback或锁过期，则本次commit失败。&lt;/li&gt;
&lt;li&gt;若锁存在，但startTS不等于本次commit请求的startVersion，表明该锁不属于我们期望commit的原事务，而是被其他事务加的锁，本次commit失败。此时需要在resp.Error中的retryable字段处记录，让client重试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若锁状态符合要求，删除锁并写入write以提交commit。这两个操作需要加锁latch来保证原子性。&lt;/p&gt;
&lt;h3 id=&#34;kvscan&#34;&gt;KvScan&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;KvScan&lt;/code&gt; 一次读取 &lt;code&gt;multiple key/value pairs&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;badger自带的迭代器只支持在指定的CF中按key顺序迭代，而事务要求我们只能读取在startTS之前提交的value，这需要我们对于每一个key先找到符合条件的write记录，再去&lt;code&gt;CfDefault&lt;/code&gt;列中获取对应的value。&lt;/p&gt;
&lt;p&gt;下面我们实现一个支持事务的迭代器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// NewScanner creates a new scanner ready to read from the snapshot in txn.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;NewScanner&lt;/span&gt;(startKey []&lt;span style=&#34;color:#8be9fd&#34;&gt;byte&lt;/span&gt;, txn &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;MvccTxn) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Scanner {
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your Code Here (4C).
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	scan &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Scanner{
		txn:     txn,
		iter:    txn.Reader.&lt;span style=&#34;color:#50fa7b&#34;&gt;IterCF&lt;/span&gt;(engine_util.CfWrite),
		lastKey: []&lt;span style=&#34;color:#8be9fd&#34;&gt;byte&lt;/span&gt;{},
	}

	scan.iter.&lt;span style=&#34;color:#50fa7b&#34;&gt;Seek&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;EncodeKey&lt;/span&gt;(startKey, txn.StartTS))
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;scan
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它包含一个&lt;code&gt;CfWrite&lt;/code&gt;列的迭代器。以及一个 &lt;code&gt;lastKey&lt;/code&gt; 字段，它记录找到的上一个符合条件的write所对应的Key。&lt;/p&gt;
&lt;p&gt;最核心的是&lt;code&gt;Scanner.Next&lt;/code&gt;函数，它返回下一个符合事务条件的key/value。&lt;/p&gt;
&lt;p&gt;首先移动迭代器，使其指向第一个满足 key != lastKey 的write记录。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; currentUserKey []&lt;span style=&#34;color:#8be9fd&#34;&gt;byte&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; scan.iter.&lt;span style=&#34;color:#50fa7b&#34;&gt;Valid&lt;/span&gt;() {
		currentUserKey = &lt;span style=&#34;color:#50fa7b&#34;&gt;DecodeUserKey&lt;/span&gt;(scan.iter.&lt;span style=&#34;color:#50fa7b&#34;&gt;Item&lt;/span&gt;().&lt;span style=&#34;color:#50fa7b&#34;&gt;KeyCopy&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;))
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !bytes.&lt;span style=&#34;color:#50fa7b&#34;&gt;Equal&lt;/span&gt;(currentUserKey, scan.lastKey) {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;
		}

		scan.iter.&lt;span style=&#34;color:#50fa7b&#34;&gt;Next&lt;/span&gt;()
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;循环使用seek寻找 &lt;code&gt;EncodeKey(currentUserKey, scan.txn.StartTS)&lt;/code&gt; 或之后的第一个 key。需要注意在 &lt;code&gt;currentUserKey&lt;/code&gt; 处可能没有在 &lt;code&gt;txn.StartTS&lt;/code&gt; 之前的commit，这会使迭代器指向下一个userKey最早的commit。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span style=&#34;color:#6272a4&#34;&gt;// now we find a key that userKey != lastKey, seek commitTs &amp;lt; startTs
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; currentCommitTs &amp;gt; scan.txn.StartTS {
		scan.iter.&lt;span style=&#34;color:#50fa7b&#34;&gt;Seek&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;EncodeKey&lt;/span&gt;(currentUserKey, scan.txn.StartTS))
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !scan.iter.&lt;span style=&#34;color:#50fa7b&#34;&gt;Valid&lt;/span&gt;() {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;
		}

		currentUserKey = &lt;span style=&#34;color:#50fa7b&#34;&gt;DecodeUserKey&lt;/span&gt;(scan.iter.&lt;span style=&#34;color:#50fa7b&#34;&gt;Item&lt;/span&gt;().&lt;span style=&#34;color:#50fa7b&#34;&gt;KeyCopy&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;))
		currentCommitTs = &lt;span style=&#34;color:#50fa7b&#34;&gt;decodeTimestamp&lt;/span&gt;(scan.iter.&lt;span style=&#34;color:#50fa7b&#34;&gt;Item&lt;/span&gt;().&lt;span style=&#34;color:#50fa7b&#34;&gt;KeyCopy&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;))
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样我们便找到了下一个commitTS符合要求的userkey，只需去 &lt;code&gt;CfDefault&lt;/code&gt; 中读取value即可。&lt;/p&gt;
&lt;p&gt;此后我们可以简单的实现 &lt;code&gt;KvScan&lt;/code&gt; ，只需根据startKey和limit建立事务迭代器实例，并循环调用&lt;code&gt;Next&lt;/code&gt;获取key / value对。&lt;/p&gt;
&lt;h3 id=&#34;kvchecktxnstatus&#34;&gt;KvCheckTxnStatus&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;KvCheckTxnStatus&lt;/code&gt; 报告事务的状态，并回滚过期的锁。&lt;/p&gt;
&lt;p&gt;需要注意 &lt;code&gt;CheckTxnStatusResponse&lt;/code&gt; 中给出的注释。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// Three kinds of txn status:
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// locked: lock_ttl &amp;gt; 0
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// committed: commit_version &amp;gt; 0
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// rolled back: lock_ttl == 0 &amp;amp;&amp;amp; commit_version == 0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了确认事务是否以及被回滚或提交，应当先查找 (primary key, lockTS) 对应的write记录，这里可以使用 &lt;code&gt;CurrentWrite&lt;/code&gt; 函数，这要求我们使用req.lockTS来初始化本次事务。若存在write记录，设置 &lt;code&gt;resp.Action = kvrpcpb.Action_NoAction&lt;/code&gt;。还需要判断write的类型，若类型为 &lt;code&gt;WriteKindRollback&lt;/code&gt; 则需要在resp中的 &lt;code&gt;CommitVersion&lt;/code&gt; 记录write
的commitTS。&lt;/p&gt;
&lt;p&gt;之后需要确认锁的状态。若锁不存在，则需要回滚primary key，并记录 &lt;code&gt;resp.Action = kvrpcpb.Action_LockNotExistRollback&lt;/code&gt;。若锁存在，判断ttl是否过期。若过期则删除锁和value并回滚，并记录 &lt;code&gt;resp.Action = kvrpcpb.Action_TTLExpireRollback&lt;/code&gt;。这里判断ttl需要使用 &lt;code&gt;physical time&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;若锁仍有效，在 &lt;code&gt;resp.LockTtl&lt;/code&gt; 字段中记录剩余ttl并返回。&lt;/p&gt;
&lt;h3 id=&#34;kvbatchrollback&#34;&gt;KvBatchRollback&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;KvBatchRollback&lt;/code&gt; 批量回滚事务。检查每个key是否仍被原事务上锁，如果是则删除锁和value，回滚该事务。&lt;/p&gt;
&lt;p&gt;循环检查每一个key&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检查该key是否已经被回滚或提交。若已被回滚则忽略该key，若已被commit则在&lt;code&gt;resp.Error.Abort&lt;/code&gt; 中记录错误信息并直接返回。可以调用 &lt;code&gt;MostRecentWrite&lt;/code&gt; 来获取最近提交的write。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查该key是否存在锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若不存在，直接回滚该key。&lt;/li&gt;
&lt;li&gt;若存在。
&lt;ul&gt;
&lt;li&gt;锁不属于原事务，视为出错，回滚该事务。&lt;/li&gt;
&lt;li&gt;锁仍属于原事务，执行所有回滚步骤，删除锁、value，再回滚。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若循环过程中发生出错则不将txn中的writes写入storage，即一个key出错视为全部出错。&lt;/p&gt;
&lt;h3 id=&#34;kvresolvelock&#34;&gt;KvResolveLock&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;KvResolveLock&lt;/code&gt; 将查找属于具有给定开始时间戳的事务的所有锁，要么将他们全部回滚，要么全部commit。&lt;/p&gt;
&lt;p&gt;首先要根据startVersion找到所有的lock，我们遍历&lt;code&gt;CfLock&lt;/code&gt;找到所有满足 &lt;code&gt;lock.Ts == req.StartVersion&lt;/code&gt; 的lock。之后根据 &lt;code&gt;req.CommitVersion&lt;/code&gt; 是否为零决定回滚或是commit，相应操作可以直接调用 &lt;code&gt;KvBatchRollback&lt;/code&gt; 或者 &lt;code&gt;KvCommit&lt;/code&gt; 。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>TinyKV Project3: MultiRaftKV</title>
        <link>https://ziannchen.work/2022/tinykv-project3-multiraftkv/</link>
        <pubDate>Sat, 05 Feb 2022 21:19:15 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/tinykv-project3-multiraftkv/</guid>
        <description>&lt;p&gt;在本项目中我们需要实现基于多个raft集群的KV服务器，其中的每一个raft集群只负责固定范围内的关键字，从而解决raft算法为了追求一致性而影响了并发性的问题。&lt;/p&gt;
&lt;p&gt;为了支持这样的设计，我们需要完成三个部分的内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为我们的raft算法添加集群成员变更以及领导权变更的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在raftstore中实现配置变更以及region分裂。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现一个调度算法用于合理地变化配置，获得更好的服务器调度性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;part-a实现集群成员变更以及领导权变更&#34;&gt;Part A：实现集群成员变更以及领导权变更&lt;/h2&gt;
&lt;h3 id=&#34;领导权变更&#34;&gt;领导权变更&lt;/h3&gt;
&lt;p&gt;在这个部分我们需要引入两个新的消息类型。&lt;code&gt;MsgTransferLeader&lt;/code&gt;使得目前的leader检查其继任者的状态，&lt;code&gt;MsgTimeoutNow&lt;/code&gt;驱动继任者无视其&lt;code&gt;ElectionTimeOut&lt;/code&gt;立即发动选举。在leader帮助其更新日志并且其他follower的时钟都为随机设定的条件下，它有相当高的几率成为新的leader，而这也正是我们所期望的。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;handleTransforLeader&lt;/code&gt;函数中定义了leader面对领导权变更时的行为。对于&lt;code&gt;MsgTransferLeader&lt;/code&gt;，它的&lt;code&gt;from&lt;/code&gt;成员应当是上层设定的&lt;code&gt;transferee&lt;/code&gt;。因此应当排除三种错误情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和一般的local message一样，&lt;code&gt;from&lt;/code&gt;成员等于自身id的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;leader的&lt;code&gt;transferee&lt;/code&gt;已经设定并且等于&lt;code&gt;from&lt;/code&gt;的情况(说明有已经在运行的领导权变更，无需重复执行)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将要确定的transferee不在leader记录的peer中的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在排除以上三种情况之后，我们需要检查&lt;code&gt;transferee&lt;/code&gt;的&lt;code&gt;log&lt;/code&gt;是否是最新的，这样才能不与正常的选举规则冲突。若不是，则应调用&lt;code&gt;sendAppend&lt;/code&gt;函数向它发送缺少的entry。在transferee的记录已经最新的情况下，leader应当调用&lt;code&gt;sendTimeoutNow&lt;/code&gt;函数向其发送&lt;code&gt;MsgTimeoutNow&lt;/code&gt;消息使其立刻发动新的选举。&lt;/p&gt;
&lt;p&gt;收到&lt;code&gt;MsgTransferLeader&lt;/code&gt;消息时，follower将其转发给leader。follower收到&lt;code&gt;MsgTimeoutNow&lt;/code&gt;之后调用&lt;code&gt;step&lt;/code&gt;函数，参数为&lt;code&gt;MsgHup&lt;/code&gt;类型的消息。follower接着就会立即将计时器置零并发动选举。&lt;/p&gt;
&lt;h3 id=&#34;配置变更&#34;&gt;配置变更&lt;/h3&gt;
&lt;p&gt;与论文中相同的是，为了支持配置变更，我们需要一个特殊的entry来记录配置的参数。因此需要在&lt;code&gt;raft/rawnode.go&lt;/code&gt;中加入&lt;code&gt;ProposeConfChange&lt;/code&gt;函数，它将entry的类型设置为&lt;code&gt;EntryConfChange&lt;/code&gt;并将数据设置为&lt;code&gt;ConfChange&lt;/code&gt;的相应字节，最后向raft层发送一个带有这样的entry，并且类型为&lt;code&gt;MsgPropose&lt;/code&gt;的消息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MsgPropose&lt;/code&gt;类型的消息只会被leader受理，它将其加入自己的log之中并且尝试向follwer发送并提交消息中的entry，这与我们在项目2中所做的并没有什么区别，只需要在&lt;code&gt;raft.go&lt;/code&gt;中的&lt;code&gt;handlePropose&lt;/code&gt;函数内加入设置&lt;code&gt;PendingConfIndex&lt;/code&gt;的代码，将它设置为第一个配置变更的entry的index并暂时不受理其他的配置变更。&lt;/p&gt;
&lt;p&gt;对于Part A，我们只需要在&lt;code&gt;rawnode.go&lt;/code&gt;中加入&lt;code&gt;ApplyConfChange&lt;/code&gt;函数，用于处理一个节点的参数变化。为了实现这个功能，我们在raft层中加入了&lt;code&gt;addNode&lt;/code&gt;与&lt;code&gt;removeNode&lt;/code&gt;函数，它们都具有相当直观的实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AddNode&lt;/code&gt;函数在raft的peers中添加相应的peer，并且初始化它的&lt;code&gt;Progress&lt;/code&gt;，最后将raft的&lt;code&gt;PendingConfIndex&lt;/code&gt;清空，使其能够处理下一个配置变更的消息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;removeNode&lt;/code&gt;函数则较为复杂一些：&lt;/p&gt;
&lt;p&gt;(1) 首先检查需要删除的raft是否在当前配置之中，若不在则直接返回，若在则转(2)。&lt;/p&gt;
&lt;p&gt;(2) 检查自身是否为需要删除的peer，若是则清空自己的peers并且返回。若不是则转(3)。&lt;/p&gt;
&lt;p&gt;(3) 删除相应的peer，并检查自己的peer数量。若为1，则它需要成为这个集群的leader。&lt;/p&gt;
&lt;p&gt;(4) 删除peer后，原先不满足commit条件的entry有可能已经满足，调用&lt;code&gt;maybeAdvanceCommit&lt;/code&gt;函数进行提交。&lt;/p&gt;
&lt;p&gt;(5) 最后清空&lt;code&gt;PendingConfIndex&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;part-b-在raftstore中实现配置变更以及region分裂&#34;&gt;Part B: 在raftstore中实现配置变更以及region分裂&lt;/h2&gt;
&lt;h3 id=&#34;propose-transfer-leader&#34;&gt;Propose transfer leader&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TransferLeader&lt;/code&gt;直接被发送给集群中的leader，不需要被复制到多个peer上，因此不需要记录在proposal中，直接调用&lt;code&gt;RawNode.TransferLeader&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;implement-conf-change-in-raftstore&#34;&gt;Implement conf change in raftstore&lt;/h3&gt;
&lt;p&gt;在raft层需要在&lt;code&gt;PendingConfIndex&lt;/code&gt;字段中记录类型为&lt;code&gt;EntryType_EntryConfChange&lt;/code&gt;的日志项的index，当配置变更被apply后落实到raft层后清空这个字段。在propose的时候，如果这个字段不为None则直接返回，表示还有一次配置变更没有完成。之后调用&lt;code&gt;RawNode.ProposeConfChange&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HandleRaftReady&lt;/code&gt;中由于存在配置变更的情况，在应用了Ready中的快照后region可能发生改变，。因此在&lt;code&gt;SaveReadyState&lt;/code&gt;之后需要修改d.ctx.storeMeta。&lt;/p&gt;
&lt;p&gt;处理CommittedEntries的部分代码也需要重构以特殊处理&lt;code&gt;EntryType_EntryConfChange&lt;/code&gt;类型的日志项。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(rd.CommittedEntries) &amp;gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, e &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; rd.CommittedEntries {
			kvwb &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;new&lt;/span&gt;(engine_util.WriteBatch)
			&lt;span style=&#34;color:#ff79c6&#34;&gt;switch&lt;/span&gt; e.EntryType {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; eraftpb.EntryType_EntryNormal:
				d.&lt;span style=&#34;color:#50fa7b&#34;&gt;processNormalEntry&lt;/span&gt;(e, kvwb)
			&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; eraftpb.EntryType_EntryConfChange:
				d.&lt;span style=&#34;color:#50fa7b&#34;&gt;processConfChangeEntry&lt;/span&gt;(e, kvwb)
			}
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; d.stopped {
				&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
			} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
				d.peerStorage.applyState.AppliedIndex = e.Index
				log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;%s successfully apply entry from raft peer %d [index: %d]&amp;#34;&lt;/span&gt;, d.Tag, d.&lt;span style=&#34;color:#50fa7b&#34;&gt;PeerId&lt;/span&gt;(), e.Index)
				kvwb.&lt;span style=&#34;color:#50fa7b&#34;&gt;SetMeta&lt;/span&gt;(meta.&lt;span style=&#34;color:#50fa7b&#34;&gt;ApplyStateKey&lt;/span&gt;(d.regionId), d.peerStorage.applyState)
			}
			kvwb.&lt;span style=&#34;color:#50fa7b&#34;&gt;WriteToDB&lt;/span&gt;(d.peerStorage.Engines.Kv)

		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在添加或是删除node时，都需要先判断目标node是否已存在当前的region的peers中。配置变更之后，还需要增加&lt;code&gt;region.RegionEpoch.ConfVer&lt;/code&gt;，修改peerCache。如果删除了自己，需要调用&lt;code&gt;destroyPeer&lt;/code&gt;并直接返回，此后的日志项也不需要再处理。 新建的peer无需我们关心，他会在收到leader的心跳后被初始化，之后接收快照来达到接近region内其他peer的状态。&lt;/p&gt;
&lt;h3 id=&#34;implement-split-region-in-raftstore&#34;&gt;Implement split region in raftstore&lt;/h3&gt;
&lt;p&gt;为了支持multi-raft，TinyKV对于较大的region进行分裂，有助于均衡集群内各个机器的负载。&lt;/p&gt;
&lt;p&gt;在propose的时候需要检查SplitKey是否合法，不合法则直接返回。&lt;/p&gt;
&lt;p&gt;region分裂需要将region中的每一个peer都分裂为两个。split消息会被复制到region中的所有peer上，并由每一个peer在apply时将自己分裂，这样就完成了分裂，而且他们共用同一个store。&lt;/p&gt;
&lt;p&gt;Split属于AdminRequest，在处理的时候需要先依次检查RegionId、RegionEpoch、SplitKey是否都合法，若检查通过则开始分裂。&lt;/p&gt;
&lt;p&gt;首先，原先的region从splitkey处分裂为两个，key range分别为[startKey, splitkey)和[splitkey, endkey)。因此需要新建一个region，其中RegionEpoch中的ConfVer和Version都设为1，在原先的region中增加RegionEpoch.Version。&lt;/p&gt;
&lt;p&gt;然后需要修改d.ctx.storeMeta，删除旧的region信息，记录两个新的region信息。调用&lt;code&gt;WriteRegionState&lt;/code&gt;持久化两个新的region，state要设置为PeerState_Normal。&lt;/p&gt;
&lt;p&gt;最后，调用createPeer新建一个peer，并在route中注册，向其发生一个MsgTypeStart信息。不要忘了处理proposal。&lt;/p&gt;
&lt;h2 id=&#34;part-c实现调度器&#34;&gt;Part C：实现调度器&lt;/h2&gt;
&lt;p&gt;调度器根据集群的负载选择每个region中每个副本的最佳位置，因此需要获取整个集群的所有关键信息，并定期检查这些信息以做出调度。&lt;/p&gt;
&lt;h3 id=&#34;collect-region-heartbeat&#34;&gt;Collect region heartbeat&lt;/h3&gt;
&lt;p&gt;调度器要求每个region中的leader定期向它发送心跳信息。&lt;/p&gt;
&lt;p&gt;我们需要实现&lt;code&gt;RaftCluster.processRegionHeartbeat&lt;/code&gt;函数，更新本地保存的region信息。&lt;/p&gt;
&lt;p&gt;在此之前我们先实现一个&lt;code&gt;checkRegionEpoch&lt;/code&gt;来判断新的region信息是否合法且是否过期。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;checkRegionEpoch&lt;/span&gt;(region &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;core.RegionInfo, origin &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;core.RegionInfo) &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; region.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetRegionEpoch&lt;/span&gt;() &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; origin.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetRegionEpoch&lt;/span&gt;() &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; errors.&lt;span style=&#34;color:#50fa7b&#34;&gt;Errorf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;region is nil&amp;#34;&lt;/span&gt;)
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; util.&lt;span style=&#34;color:#50fa7b&#34;&gt;IsEpochStale&lt;/span&gt;(region.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetRegionEpoch&lt;/span&gt;(), origin.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetRegionEpoch&lt;/span&gt;()) {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;ErrRegionIsStale&lt;/span&gt;(region.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetMeta&lt;/span&gt;(), origin.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetMeta&lt;/span&gt;())
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们先需要根据心跳中的regionInfo的regionId先获取本地保存的region信息。若本地存在且新的region过期，直接返回错误。若不存在，遍历本地所有包含了新region的key range的region信息，检查新的region对于它是否过期，若存在过期则直接返回错误。&lt;/p&gt;
&lt;p&gt;若新的region未过期，则更新本地存储，包括了region tree和store status。&lt;/p&gt;
&lt;h3 id=&#34;implement-region-balance-scheduler&#34;&gt;Implement region balance scheduler&lt;/h3&gt;
&lt;p&gt;这一部分需要实现&lt;code&gt;balanceRegionScheduler.Schedule&lt;/code&gt;函数，它负责进行region的调度，返回一个MovePeerOperator，将某个peer在store之间移动。&lt;/p&gt;
&lt;p&gt;首先寻找合适的可移动的region，在此之前需要寻找所有合适的store，即：正在运行并且 downTime 小于 store的最大downTime 的所有store。如果suitableStores数量小等于1，不能进行MovePeer，则停止本次调度返回nil。之后将所有suitableStores按照拥有的region大小从大到小排序。&lt;/p&gt;
&lt;p&gt;接着我们遍历suitableStores，在每个store上按照PendingRegionsWithLock -&amp;gt; FollowerWithLock -&amp;gt; LeadersWIthLock的优先级选出第一个满足条件的region，这便是我们想要移动的region。如果没有找到合适的region，或是该region的副本数小于MaxReplicas，则停止本次调度返回nil。&lt;/p&gt;
&lt;p&gt;最后我们寻找接收peer的目标store，即拥有的region大小最小且不在suitableStores中的store。如果sourceStore.GetRegionSize()-targetStore.GetRegionSize() &amp;lt;= region.GetApproximateSize()*2，则本次调度不能进行。之后调用&lt;code&gt;AllocPeer&lt;/code&gt;在targetStore上新建一个peer，调用&lt;code&gt;CreateMovePeerOperator&lt;/code&gt;生成operator返回。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>TinyKV Project2: RaftKV</title>
        <link>https://ziannchen.work/2022/tinykv-project2-raftkv/</link>
        <pubDate>Sat, 05 Feb 2022 21:13:40 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/tinykv-project2-raftkv/</guid>
        <description>&lt;p&gt;在本项目中我们需要实现一个基于 raft 分布式共识算法的高可用kv存储服务器，它既需要我们实现Raft算法也需要我们知道如何实际使用它。&lt;/p&gt;
&lt;p&gt;我们通过3个步骤来达成这一目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现基本的Raft算法。&lt;/li&gt;
&lt;li&gt;在Raft之上构建一个可容错的KV服务。&lt;/li&gt;
&lt;li&gt;添加对于raft日志垃圾回收以及快照的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;part-a实现基本的raft算法&#34;&gt;Part A：实现基本的Raft算法&lt;/h2&gt;
&lt;p&gt;raft层中没有物理时钟，而是使用一个逻辑时钟。上层应用通过调用&lt;code&gt;RawNode.Tick()&lt;/code&gt;来推动逻辑时钟，进而推动election \ heartbeat timeout的发生，从而推动了raft状态机。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;Raft.tick&lt;/code&gt;函数中，根据&lt;code&gt;Raft.State&lt;/code&gt;推动election timeout或是 heartbeat timeout。这是通过控制&lt;code&gt;electionElapsed&lt;/code&gt;和&lt;code&gt;heartbeatElapsed&lt;/code&gt;进行自增操作实现的，当&lt;code&gt;electionElapsed &amp;gt;= randomizeElectionTimeout&lt;/code&gt;时触发一次选举，当&lt;code&gt;heartbeatElapsed &amp;gt;= heartbeatTimeout&lt;/code&gt;时触发一次心跳。触发之后对应地要清零&lt;code&gt;Elapsed&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;raft中不同peer之间、raft层与上层应用之间收发消息都是异步的。在raft层中只需将希望发出的消息存入&lt;code&gt;Raft.msg&lt;/code&gt;中，上层应用会在调用&lt;code&gt;HandleRaftReady&lt;/code&gt;处理消息并转发到目标处。上层应用同时为每个收到的消息调用&lt;code&gt;Raft.Step&lt;/code&gt;让raft层处理消息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;raft中定义的不同&lt;code&gt;Message&lt;/code&gt;有不同的&lt;code&gt;MsgType&lt;/code&gt;。根据论文，不同的&lt;code&gt;MsgType&lt;/code&gt;只能拥有特定的raft状态的peer才能处理，如下表所示。每个消息先在&lt;code&gt;Raft.Step&lt;/code&gt;函数中根据此时raft状态的的不同被路由到对应的不同状态的step函数中处理，再根据消息类型的不同由对应的&lt;code&gt;handlexxx&lt;/code&gt;函数处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;Msgtype&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;State&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgHup&lt;/td&gt;
&lt;td&gt;L、C、F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgBeat&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgPropose&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgAppend&lt;/td&gt;
&lt;td&gt;L、C、F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgAppendResponse&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgRequestVote&lt;/td&gt;
&lt;td&gt;L、C、F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgRequestVoteResponse&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgSnapshot&lt;/td&gt;
&lt;td&gt;L、C、F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgHeartbeat&lt;/td&gt;
&lt;td&gt;L、C、F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgHeartbeatResponse&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgTransferLeader&lt;/td&gt;
&lt;td&gt;L、C、F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pb.MessageType_MsgTimeoutNow&lt;/td&gt;
&lt;td&gt;C、F&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;newRaft函数，根据传入的一个&lt;code&gt;Config&lt;/code&gt;参数创建一个raft peer实例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Raft.RaftLog&lt;/code&gt;需要调用&lt;code&gt;newLog&lt;/code&gt;函数，需要注意Raft中的entries和Storage中entries数组下标、日志项index、几个特殊的index之间的关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Raft.Prs&lt;/code&gt;记录了同一个region内各个peer的日志同步情况。 还有一个隐含的作用是记录了同一个region内各个peer的id，也让我们知道了peer的数量，这在有时候很有用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;leader-election&#34;&gt;Leader election&lt;/h3&gt;
&lt;p&gt;首先要实现&lt;code&gt;becomexxx&lt;/code&gt;函数。根据论文可以很容易实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;becomeFollower&lt;/code&gt;：更新State、Vote、Term、Lead，将electionElapsed清零。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;becomeCandidate&lt;/code&gt;：更新State，将Vote设为自己的id，清空votes、Lead、electionElapsed，设置votes[r.id] = true，增加Term。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;becomeLeader&lt;/code&gt;：更新State、heartbeatElapsed，将Lead设为自己的id，更新Prs，自增一条空日志并广播（每个leader只会commit本term内的日志，如此可以保证集群的可用性）。需要注意的是如果当前Region中只有自己，则直接commit该条日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发起选举的过程是在&lt;code&gt;startElection&lt;/code&gt;中实现。调用becomeCandidate，并向其他peer广播RequestVote消息。在消息中需要附加自身的最后一条日志的Index和term。需要注意的是，若region中只有自己一个节点，则直接成为leader。&lt;/p&gt;
&lt;p&gt;处理candidate发来的RequestVote消息是在&lt;code&gt;handleRequestVote&lt;/code&gt;函数中实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果消息中的Term比自身的Term小，拒绝投票。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;r.Vote != None &amp;amp;&amp;amp; r.Vote != m.From&lt;/code&gt;，这意味着在本次任期中已经为另一个peer投过票，拒绝投票。&lt;/li&gt;
&lt;li&gt;判断消息发送者的日志是否比自己更up-to-date。若不是，拒绝投票。&lt;/li&gt;
&lt;li&gt;至此，同意投票，更新自身Vote字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处理其他peer回复的RequestVoteResponse是在&lt;code&gt;handleRequestVoteResponse&lt;/code&gt;函数中实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果消息的Term比自己的Term小，拒绝处理该消息。这意味着这个消息是过时的。&lt;/li&gt;
&lt;li&gt;如果同意投票，更新r.votes。如果同意投票的数量过半，自己成为leader；如果拒绝投票的数量过半，自己退化为follower。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;成为leader后要定期广播心跳，通过调用&lt;code&gt;boardcastHeartbeat&lt;/code&gt;来进行广播，在消息中附加自己的Term。&lt;/p&gt;
&lt;h3 id=&#34;log-replication&#34;&gt;Log replication&lt;/h3&gt;
&lt;p&gt;leader在Prs中记录同一region中各个peer的日志同步情况，在某个peer日志落后时要进行日志复制，在上层应用向raft层Propose日志后也要进行广播日志复制。&lt;/p&gt;
&lt;p&gt;发送日志复制的操作在&lt;code&gt;sendAppend&lt;/code&gt;中处理。&lt;code&gt;r.Prs[to].Next&lt;/code&gt;代表需要向&lt;code&gt;to&lt;/code&gt;复制的第一条日志的index，如果这条日志已经被compact了，则转为发送snapshot。发送日志时还需要附带前一条日志的index和term以及自己的commit。&lt;/p&gt;
&lt;p&gt;接收到leader的日志复制消息后，相应的处理在&lt;code&gt;handleAppendEntries&lt;/code&gt;中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若消息的term比自身小，这表示原leader可能陷入网络分区之类的情况，不知道外部已经产生了term更大的新的leader，拒绝。&lt;/li&gt;
&lt;li&gt;至此，至少我们可以承认该leader的合法性，调用becomeFollower。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;m.Index &amp;gt; r.RaftLog.LastIndex()&lt;/code&gt; 这表示自己没有leader想要复制的日志的前一条日志，拒绝，并设置response消息中的index为自己的lastIndex。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;m.Index&lt;/code&gt;对应的日志的term冲突，则拒绝，同时在response消息中需要附带上自己的日志中该term对应的第一条日志的index。&lt;/li&gt;
&lt;li&gt;至此，同意复制日志。将消息中与自己冲突的日志全部附加在自身未冲突的日志项之后，更新&lt;code&gt;stabled&lt;/code&gt;和&lt;code&gt;commit&lt;/code&gt;。需要注意避免&lt;code&gt;commit&lt;/code&gt;回退。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;leader接收到其他peer对日志复制的回复后，在&lt;code&gt;handleAppendEntriesResponse&lt;/code&gt;中处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若消息的term比自身的小，说明消息过期，拒绝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果消息类型是拒绝：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若m.Index为0，直接返回。&lt;/li&gt;
&lt;li&gt;若m.LogTerm为0，说明该peer的日志落后自己太多。若不为0，说明该peer的日志和自己在prevIndex处冲突。调整r.Prs[m.From].Next，重新发送一次日志复制消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果消息类型是接受：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新r.Prs，视情况是否更新commit。若commit更新，需要立即广播&lt;code&gt;AppendEntries&lt;/code&gt;。若该peer日志仍落后，需要再次发送日志复制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;implement-the-raw-node-interface&#34;&gt;Implement the raw node interface&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RawNode&lt;/code&gt;包装了一个&lt;code&gt;Raft&lt;/code&gt;结构，是与上层应用交互的接口。&lt;code&gt;Campaign&lt;/code&gt;函数让&lt;code&gt;RawNode&lt;/code&gt;在raft层直接发起一次选举。&lt;code&gt;Propose&lt;/code&gt;向raft层中添加一条日志。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ready&lt;/code&gt;函数将此刻的&lt;code&gt;RawNode&lt;/code&gt;状态相对于上一次调用&lt;code&gt;Ready&lt;/code&gt;时的增量包装为一个Ready结构返回。其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ready.Entries&lt;/code&gt;表示未被持久化的日志项。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ready.CommittedEntries&lt;/code&gt;表示已经commit未被apply的日志项。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ready.Snapshot&lt;/code&gt;表示&lt;code&gt;pendingSnapshot&lt;/code&gt;，此后需要清空&lt;code&gt;pendingSnapshot&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ready.Messages&lt;/code&gt;表示需要发给其他peer的消息，此后需要清空&lt;code&gt;RawNode.Raft.msgs&lt;/code&gt;。
由于需要获取增量，所以&lt;code&gt;HardState&lt;/code&gt;和&lt;code&gt;SoftState&lt;/code&gt;需要与上一次获得的进行对比，若不同才能写入&lt;code&gt;Ready&lt;/code&gt;中。因此，&lt;code&gt;RawNode&lt;/code&gt;结构中需要记录&lt;code&gt;prevSoftState&lt;/code&gt;、&lt;code&gt;prevHardState&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;hasReady&lt;/code&gt;用于判断&lt;code&gt;Ready&lt;/code&gt;的增量是否存在。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Advance&lt;/code&gt;在上层应用处理完&lt;code&gt;Ready&lt;/code&gt;后调用，更新raft层的stable、applied。&lt;/p&gt;
&lt;h2 id=&#34;part-b构建一个可容错的kv服务&#34;&gt;Part B：构建一个可容错的KV服务&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RaftStorage&lt;/code&gt;类似于&lt;code&gt;StandaloneStorage&lt;/code&gt;，它处理用户发送来的请求。&lt;/p&gt;
&lt;p&gt;它启动一个&lt;code&gt;Raftstore&lt;/code&gt;来驱动raft层，将请求包装为&lt;code&gt;RaftCmdRequest&lt;/code&gt;，通过&lt;code&gt;RaftstoreRouter&lt;/code&gt;发送给region中的leader，同时记录一个callback。raft层在日志复制到半数以上节点后apply，我们从callback中读出response，进行相应处理&lt;/p&gt;
&lt;h3 id=&#34;implement-peer-storage&#34;&gt;Implement peer storage&lt;/h3&gt;
&lt;p&gt;我们需要将&lt;code&gt;Ready&lt;/code&gt;中的unstable entries持久化，需要注意几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已经转化为快照的日志对应的index不能重复持久化。&lt;/li&gt;
&lt;li&gt;已经持久化但过时的日志需要删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;SaveReadyState&lt;/code&gt;中我们要保存&lt;code&gt;Ready&lt;/code&gt;中的状态，保存日志、更新&lt;code&gt;PeerStorage.raftState&lt;/code&gt;，并持久化到raftDB。&lt;/p&gt;
&lt;h3 id=&#34;implement-raft-ready-process&#34;&gt;Implement Raft ready process&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Raftstore&lt;/code&gt;会启动一个&lt;code&gt;raftWorker&lt;/code&gt;用于驱动raft层。它在一个循环中不停地接收消息，将一些消息调用&lt;code&gt;RawNode&lt;/code&gt;的接口传递给raft层，并处理&lt;code&gt;RawNode&lt;/code&gt;的Ready。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, msg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; msgs {
		peerState &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;getPeerState&lt;/span&gt;(peerStateMap, msg.RegionID)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; peerState &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt; {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
		}
		&lt;span style=&#34;color:#50fa7b&#34;&gt;newPeerMsgHandler&lt;/span&gt;(peerState.peer, rw.ctx).&lt;span style=&#34;color:#50fa7b&#34;&gt;HandleMsg&lt;/span&gt;(msg)
	}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, peerState &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; peerStateMap {
		&lt;span style=&#34;color:#50fa7b&#34;&gt;newPeerMsgHandler&lt;/span&gt;(peerState.peer, rw.ctx).&lt;span style=&#34;color:#50fa7b&#34;&gt;HandleRaftReady&lt;/span&gt;()
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先实现&lt;code&gt;proposeRaftCommand&lt;/code&gt;函数。它将&lt;code&gt;RaftCmdRequest&lt;/code&gt;中的每一个&lt;code&gt;Request&lt;/code&gt;与callback绑定，记录在&lt;code&gt;peer.proposals&lt;/code&gt;数组中，并调用&lt;code&gt;RawNode.Propose&lt;/code&gt;函数将请求发送到raft层进行共识。&lt;/p&gt;
&lt;p&gt;接着，实现&lt;code&gt;HandleRaftReady&lt;/code&gt;函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若该peer已经被destroy，直接返回。&lt;/li&gt;
&lt;li&gt;若该peer没有pending Ready，直接返回。&lt;/li&gt;
&lt;li&gt;获取Ready，并调用&lt;code&gt;SaveReadyState&lt;/code&gt;保存状态。如果自身是leader，调用&lt;code&gt;HeartbeatScheduler&lt;/code&gt;向PD发送心跳同步状态。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;Send&lt;/code&gt;发送消息给其他peer，处理Ready中的CommittedEntries，调用Advance。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在处理CommittedEntries时，对每个日志项使用一个WriteBatch来保证原子性。从entry.Data中Unmarshal出RaftCmdRequest结构，将其中的请求应用到状态机。需要注意的是请求类型为&lt;code&gt;CmdType_Snap&lt;/code&gt;表示一个读事务，需要设置&lt;code&gt;cb.Txn = d.peerStorage.Engines.Kv.NewTransaction(false)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将结果封装成&lt;code&gt;RaftCmdResponse&lt;/code&gt;，从&lt;code&gt;proposals&lt;/code&gt;中找到对应的callback返回。此后还需要更新&lt;code&gt;peerStorage.applyState.AppliedIndex&lt;/code&gt;，一同加入WriteBatch，最后持久化。&lt;/p&gt;
&lt;p&gt;寻找对应的callback的过程在&lt;code&gt;peerMsgHandler.handleProposal&lt;/code&gt;中实现。proposal的index和term和该请求在raft层中日志项的index和term是相同的，因此可以直接遍历proposals数组，找到对应的callback。若index相同但term不同说明这个请求可能未完成共识，应该调用&lt;code&gt;NotifyStaleReq&lt;/code&gt;返回错误信息。&lt;/p&gt;
&lt;h2 id=&#34;part-craft-日志的垃圾回收以及快照&#34;&gt;Part C：raft 日志的垃圾回收以及快照&lt;/h2&gt;
&lt;p&gt;长时间运行的服务器会保存大量的raft日志，这会消耗大量磁盘空间。而且在许多时候我们只需要记录状态机的最终状态，而不需要保存状态机达到该状态所经历的过程，因此我们需要截断日志，进行日志项的垃圾回收，并通过快照同步到其他节点。&lt;/p&gt;
&lt;p&gt;我们需要在raft和raftstore两个部分中分别增加对快照的支持。&lt;/p&gt;
&lt;h3 id=&#34;implement-in-raft&#34;&gt;Implement in Raft&lt;/h3&gt;
&lt;p&gt;在raft层的日志同步过程中，如果leader发现希望复制给follower的日志项已经被删除，应该转变为发送一个快照，并在此后复制剩余的日志项。&lt;/p&gt;
&lt;p&gt;首先我们修改&lt;code&gt;Raft.sendAppend&lt;/code&gt;函数，leader调用这个函数以向follower复制日志。如果r.Prs[to].Next &amp;lt;= r.RaftLog.truncatedIndex，转为发送快照。调用&lt;code&gt;r.RaftLog.storage.Snapshot&lt;/code&gt;以获取快照。&lt;/p&gt;
&lt;p&gt;接下来是&lt;code&gt;Raft.handleSnapshot&lt;/code&gt;函数，follower在接收到leader发送的快照后调用这个函数处理。首先需要判断这个快照是否是最新的，如果&lt;code&gt;meta.Index &amp;lt;= r.RaftLog.committed&lt;/code&gt;表示该快照不是最新，拒绝接收。之后follower接受这个快照，需要将applied、commited、stabled、truncatedIndex都修改为meta.Index，并清空本地的日志，将这个快照保存在RaftLog.pendingSnapshot中。还需要根据Metadate.ConfState.Nodes更新Raft.Prs。&lt;/p&gt;
&lt;p&gt;pendingSnapshot会在Ready中被保存到raftstore中，需要实现&lt;code&gt;PeerStorage.ApplySnapshot&lt;/code&gt;函数。先调用&lt;code&gt;clearMeta&lt;/code&gt;和&lt;code&gt;clearExtraData&lt;/code&gt;来清空过时的信息，然后更新raftState和applyState这些metadata，将snapState.StateType设置为SnapState_Applying。最后通过regionSched这个channel向region worker发送一个RegionTaskApply，等待其中的Notifier返回。在&lt;code&gt;HandleRaftReady&lt;/code&gt;中需要先apply快照，后apply日志。&lt;/p&gt;
&lt;h3 id=&#34;implement-in-raftstore&#34;&gt;Implement in raftstore&lt;/h3&gt;
&lt;p&gt;raftstore会检查是否需要对日志项进行垃圾回收，并propose一个CompactLogRequest。&lt;/p&gt;
&lt;p&gt;CompactLogRequest在AdminRequest中，我们需要修改&lt;code&gt;peerMsgHandler.proposeRaftCommand&lt;/code&gt;中增加对AdminRequest的处理。这个请求没有callback，因此不需要记录proposal，直接propose到raft层进行共识。&lt;/p&gt;
&lt;p&gt;经过共识的CompactLogRequest会在Ready中被apply，我们修改&lt;code&gt;HandleRaftReady&lt;/code&gt;，在处理CommittedEntries先判断请求中AdminRequest是否为空，若不为空需要特殊处理。这个分支里目前只需要处理CompactLogRequest，先判断只有在adminReq.CompactLog.CompactIndex &amp;gt; d.peerStorage.applyState.TruncatedState.Index的时候才能compact。如果需要compact，首先更新 TruncatedState ，然后调用ScheduleCompactLog添加一个 raftlog-gc 的任务异步处理。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>TinyKV Project1: StandaloneKV</title>
        <link>https://ziannchen.work/2022/tinykv-project1-standalonekv/</link>
        <pubDate>Sat, 05 Feb 2022 21:04:35 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/tinykv-project1-standalonekv/</guid>
        <description>&lt;p&gt;在本项目中，我们将在 &lt;code&gt;column family&lt;/code&gt; 的支持下构建一个独立的 key / value 存储gRPC服务。在 &lt;code&gt;kv/main.go&lt;/code&gt; 中我们初始化了一个 &lt;code&gt;gRPC&lt;/code&gt; server，它包含了一个 &lt;code&gt;tintkv.Server&lt;/code&gt; ，提供名为 &lt;code&gt;TinyKV&lt;/code&gt; 的 &lt;code&gt;gRPC&lt;/code&gt; 服务。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	server &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; server.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewServer&lt;/span&gt;(storage)

   &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; alivePolicy = keepalive.EnforcementPolicy{
   	MinTime:             &lt;span style=&#34;color:#bd93f9&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Second, &lt;span style=&#34;color:#6272a4&#34;&gt;// If a client pings more than once every 2 seconds, terminate the connection
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;   	PermitWithoutStream: &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;,            &lt;span style=&#34;color:#6272a4&#34;&gt;// Allow pings even when there are no active streams
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;   }

   grpcServer &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; grpc.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewServer&lt;/span&gt;(
   	grpc.&lt;span style=&#34;color:#50fa7b&#34;&gt;KeepaliveEnforcementPolicy&lt;/span&gt;(alivePolicy),
   	grpc.&lt;span style=&#34;color:#50fa7b&#34;&gt;InitialWindowSize&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;30&lt;/span&gt;),
   	grpc.&lt;span style=&#34;color:#50fa7b&#34;&gt;InitialConnWindowSize&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;30&lt;/span&gt;),
   	grpc.&lt;span style=&#34;color:#50fa7b&#34;&gt;MaxRecvMsgSize&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1024&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1024&lt;/span&gt;),
   )
   tinykvpb.&lt;span style=&#34;color:#50fa7b&#34;&gt;RegisterTinyKvServer&lt;/span&gt;(grpcServer, server)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，&lt;code&gt;server&lt;/code&gt; 依赖于一个 &lt;code&gt;storage&lt;/code&gt; ，它是一个接口，可以根据配置文件选择raft存储实现或者单机存储实现。&lt;/p&gt;
&lt;p&gt;我们通过两步来完成这个项目：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现一个单机存储引擎。&lt;/li&gt;
&lt;li&gt;实现原始的kv服务handler。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实现一个单机存储引擎&#34;&gt;实现一个单机存储引擎。&lt;/h2&gt;
&lt;p&gt;我们需要用一个单机存储引擎来实现这个接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// Storage represents the internal-facing server part of TinyKV, it handles sending and receiving from other
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// TinyKV nodes. As part of that responsibility, it also reads and writes data to disk (or semi-permanent memory).
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Storage &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt; {
	&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;() &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt;
	&lt;span style=&#34;color:#50fa7b&#34;&gt;Stop&lt;/span&gt;() &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt;
	&lt;span style=&#34;color:#50fa7b&#34;&gt;Write&lt;/span&gt;(ctx &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;kvrpcpb.Context, batch []Modify) &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt;
	&lt;span style=&#34;color:#50fa7b&#34;&gt;Reader&lt;/span&gt;(ctx &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;kvrpcpb.Context) (StorageReader, &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码位于 &lt;code&gt;kv/storage/standalone_storage/standalone_storage.go&lt;/code&gt; 中。我们底层的存储服务使用了 &lt;code&gt;badger&lt;/code&gt; ，因此实现 &lt;code&gt;Storage&lt;/code&gt; 接口只需对 &lt;code&gt;badger&lt;/code&gt; 的api进行封装。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; StandAloneStorage &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your Data Here (1).
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	db &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;badger.DB
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Reader&lt;/code&gt; 方法中直接返回一个 &lt;code&gt;StandAloneStorageReader&lt;/code&gt; 即可，其中包含了一个 &lt;code&gt;badger.Txn&lt;/code&gt; 是一个事务接口，提供了读时的快照。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Write&lt;/code&gt; 方法需要一次性 &lt;code&gt;batch&lt;/code&gt; 中的所有写入或是删除操作写入数据库。需要使用一个 &lt;code&gt;WriteBatch&lt;/code&gt; 记录下所有写操作，最后使用 &lt;code&gt;WriteBatch.WriteToDB&lt;/code&gt; 方法一次性写入 &lt;code&gt;badger&lt;/code&gt;。&lt;code&gt;badger&lt;/code&gt; 并不支持 &lt;code&gt;column family&lt;/code&gt;，因此tinykv在不同 &lt;code&gt;column family&lt;/code&gt; 上的区分只是为把不同 &lt;code&gt;column family&lt;/code&gt; 的key在编码时加上不同的前缀。&lt;/p&gt;
&lt;h2 id=&#34;实现原始的kv服务handler&#34;&gt;实现原始的kv服务handler。&lt;/h2&gt;
&lt;p&gt;我们需要使用刚刚实现的单机存储引擎为 &lt;code&gt;server&lt;/code&gt; 实现 &lt;code&gt;RawGet/Put/Delete/Scan&lt;/code&gt; 4个方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RawGet&lt;/code&gt; 方法需要使用 &lt;code&gt;RawGetRequest&lt;/code&gt; 中的 &lt;code&gt;Context&lt;/code&gt; 初始化一个 &lt;code&gt;Reader&lt;/code&gt;，此后直接读取。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RawPut/Delete&lt;/code&gt; 这两个写操作需要使用 &lt;code&gt;storage.Modify&lt;/code&gt; 先进行封装再调用 &lt;code&gt;Write&lt;/code&gt; 写入。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RawScan&lt;/code&gt; 需要初始化一个迭代器 &lt;code&gt;Reader.IterCF&lt;/code&gt; ，之后直接循环读取。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>mit-6.824 lab4: ShardKV</title>
        <link>https://ziannchen.work/2022/mit-6.824-lab4-shardkv/</link>
        <pubDate>Fri, 04 Feb 2022 13:21:03 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/mit-6.824-lab4-shardkv/</guid>
        <description>&lt;p&gt;lab课程网址 &lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/labs/lab-shard.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pdos.csail.mit.edu/6.824/labs/lab-shard.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本次lab是最难的一次lab，很多地方需要我们自由发挥，不像lab2那样可以参考论文。&lt;/p&gt;
&lt;p&gt;Lab2和Lab3构成基础分布式数据库的框架，实现了多节点间的数据一致性，支持crud，数据同步和快照保存。然而，由于所有的请求都需要由 leader 来处理，当数据增长到一定程度时，若仍然使用单一集群服务所有数据，leader面对的压力会非常大，请求响应时间也会延长，磁盘空间也会不足。在这种模式下，增加机器并不会带来性能的提升，反而存在浪费。一个非常直接的解决方法，就是将数据按照某种方式分开存储到不同的集群上，将不同的请求引流到不同的集群，降低单一集群的压力，提供更为高效、更为健壮的服务。&lt;/p&gt;
&lt;p&gt;Lab4就是要实现数据的划分，将不同的数据划分到不同的集群上，保证相应数据请求引流到对应的集群。这里，将互不相交并且组成完整数据的每一个数据子集称为 Shard。在同一阶段中，Shard 与集群的对应关系称为 Config，随着时间的推移，增加或减少机器、某个 Shard 中的数据请求过热，Shard 需要在不同集群之中进行迁移。如何在 Config更新、 Shard 迁移的同时仍能正确对外提供强一致性的服务，是lab4主要挑战。&lt;/p&gt;
&lt;p&gt;一个集群只有Leader才能服务，系统的性能与集群的数量成正比。lab3是一个集群，lab4要实现的是多个集群之间的配合。&lt;/p&gt;
&lt;p&gt;我画了一个 ShardKV 最终的结构图&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://ziannchen.work/img/ShardKV/1.png&#34; &gt;
		&lt;img src=&#34;https://ziannchen.work/img/ShardKV/1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;图片 1&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;图片 1&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;shardctrler&#34;&gt;ShardCtrler&lt;/h2&gt;
&lt;p&gt;Client 在向 Server 发送RPC之前，需要先知道目标 key 所在的 Shard 位于哪一个 Group，以及如何和这个 Group 中的leader通信。这就需要有一个地方保存 shard -&amp;gt; gid 和 gid -&amp;gt; server 信息，这就是lab4A中需要实现的 ShardCtrler，它使用 Config 结构保存这些信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// A configuration -- an assignment of shards to groups.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// Please don&amp;#39;t change this.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Config &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Num    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;              &lt;span style=&#34;color:#6272a4&#34;&gt;// config number
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Shards [NShards]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;     &lt;span style=&#34;color:#6272a4&#34;&gt;// shard -&amp;gt; gid
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Groups &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;][]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// gid -&amp;gt; servers[]
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每次 shard -&amp;gt; gid 的对应关系被更改时，ShardCtrler 创建一个新的 Config 保存新的对应关系。ShardCtrler 支持Join、Leave、Move、Query 4种RPC来添加新的 Group、删除 Group，在 Group 之间移动 Shard 以及查询对应 Num 的 Config，底层也使用Raft协议在多台机器上进行数据同步。因此整体实现和lab3类似。&lt;/p&gt;
&lt;h3 id=&#34;client&#34;&gt;Client&lt;/h3&gt;
&lt;p&gt;为了简化逻辑4种请求共用一个RPC，也需要加上 ClientID 和 RequestID 让 server 端能够去重。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; CommandRequest &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	ClientID  &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	RequestID &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	OpType
	JoinArgs
	LeaveArgs
	MoveArgs
	QueryArgs
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; CommandResponse &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Err         Err
	Config      Config
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; JoinArgs &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Servers   &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;][]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// new GID -&amp;gt; servers mappings
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; LeaveArgs &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	GIDs      []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; MoveArgs &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Shard     &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	GID       &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; QueryArgs &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Num       &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// desired config number
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;server&#34;&gt;Server&lt;/h3&gt;
&lt;p&gt;对于RPC的处理模型和lab3是一样的，由于Config数据较小，还不用处理快照。&lt;/p&gt;
&lt;h4 id=&#34;join&#34;&gt;Join&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Join&lt;/code&gt; 操作向当前配置中新增一些server，这些server可能被加入现有的 Group 中，也可能是新增的 Group。&lt;/p&gt;
&lt;p&gt;新增的 Group 还没有 Shard，需要在 &lt;code&gt;Groups&lt;/code&gt; 中对 &lt;code&gt;Shards&lt;/code&gt; 进行平衡并且要产生尽可能少的 Shard 迁移，平衡的方法是每次循环让拥有 Shard 最多的 Group 分一个给拥有 Shard 最少的 Group，直到它们之间的差值小等于1。&lt;/p&gt;
&lt;p&gt;ShardCtrler 刚启动时还没有 Config 信息，第一次执行 &lt;code&gt;Join&lt;/code&gt; 时所有的 Shard 还未被分配到具体的 Group 上，对应的 gid 是0，我称为 &lt;code&gt;zombieShard&lt;/code&gt;。因此在处理 &lt;code&gt;Join&lt;/code&gt; 时也要分配可能存在的 &lt;code&gt;zombieShard&lt;/code&gt;。此外maps数据需要深拷贝。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (sc &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardCtrler) &lt;span style=&#34;color:#50fa7b&#34;&gt;executeJoin&lt;/span&gt;(servers &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;][]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) {
	length &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(sc.configs)
	lastConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; sc.configs[length&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;]

	newGroups &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;deepCopy&lt;/span&gt;(lastConfig.Groups)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; gid, servers &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; servers {
		newGroups[gid] = servers
	}
	newConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Config{
		Num:    length,
		Shards: [NShards]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;{},
		Groups: newGroups,
	}

	groupToShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;getGroupToShards&lt;/span&gt;(newGroups, lastConfig.Shards)
	zombieShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;{}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; shard, gid &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; lastConfig.Shards {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; gid &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt; {
			zombieShards = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(zombieShards, shard)
		}
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; zombieShards {
		target &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;getMinGroup&lt;/span&gt;(groupToShards)
		groupToShards[target] = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(groupToShards[target], shard)
	}

	groupToShards = &lt;span style=&#34;color:#50fa7b&#34;&gt;balanceShardBetweenGroups&lt;/span&gt;(groupToShards)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; gid, shards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; groupToShards {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; shards {
			newConfig.Shards[shard] = gid
		}
	}

	sc.configs = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(sc.configs, newConfig)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;leave&#34;&gt;Leave&lt;/h4&gt;
&lt;p&gt;Group 被删除后，其原先拥有的 Shard 就成了 &lt;code&gt;zombieShard&lt;/code&gt;，应当依次分配被拥有 Shard 数量最少的 Group。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (sc &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardCtrler) &lt;span style=&#34;color:#50fa7b&#34;&gt;executeLeave&lt;/span&gt;(GIDs []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
	length &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(sc.configs)
	lastConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; sc.configs[length&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;]
	newGroups &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;deepCopy&lt;/span&gt;(lastConfig.Groups)

	newConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Config{
		Num:    length,
		Shards: [NShards]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;{},
		Groups: newGroups,
	}

	groupToShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;getGroupToShards&lt;/span&gt;(newGroups, lastConfig.Shards)
	zombieShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;{}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, gid &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; GIDs {
		&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;delete&lt;/span&gt;(newConfig.Groups, gid)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; shards, ok &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; groupToShards[gid]; ok {
			zombieShards = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(zombieShards, shards&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)
			&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;delete&lt;/span&gt;(groupToShards, gid)
		}
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; zombieShards {
		target &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;getMinGroup&lt;/span&gt;(groupToShards)
		groupToShards[target] = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(groupToShards[target], shard)
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; gid, shards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; groupToShards {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; shards {
			newConfig.Shards[shard] = gid
		}
	}

	sc.configs = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(sc.configs, newConfig)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;move&#34;&gt;Move&lt;/h4&gt;
&lt;p&gt;将指定的 Shard 交由新的 Group 负责，只需要改动 &lt;code&gt;Shards&lt;/code&gt; 数组。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (sc &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardCtrler) &lt;span style=&#34;color:#50fa7b&#34;&gt;executeMove&lt;/span&gt;(shard &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, gid &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
	length &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(sc.configs)
	lastConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; sc.configs[length&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;]
	newGroups &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;deepCopy&lt;/span&gt;(lastConfig.Groups)

	newConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Config{
		Num:    length,
		Shards: lastConfig.Shards,
		Groups: newGroups,
	}

	newConfig.Shards[shard] = gid
	sc.configs = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(sc.configs, newConfig)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;query&#34;&gt;Query&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Query&lt;/code&gt; 查询指定版本的 Config。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (sc &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardCtrler) &lt;span style=&#34;color:#50fa7b&#34;&gt;executeQuery&lt;/span&gt;(num &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) Config {
	length &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(sc.configs)
	config &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Config{}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; num &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; num &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;=&lt;/span&gt; length {
		config = sc.configs[length&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;]
	} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
		config = sc.configs[num]
	}

	newGroups &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;deepCopy&lt;/span&gt;(config.Groups)
	newConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Config{
		Num:    config.Num,
		Shards: config.Shards,
		Groups: newGroups,
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; newConfig
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;测试结果&#34;&gt;测试结果&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;Test: Basic leave/join ...
  ... Passed
Test: Historical queries ...
  ... Passed
Test: Move ...
  ... Passed
Test: Concurrent leave/join ...
  ... Passed
Test: Minimal transfers after joins ...
  ... Passed
Test: Minimal transfers after leaves ...
  ... Passed
Test: Multi-group join/leave ...
  ... Passed
Test: Concurrent multi leave/join ...
  ... Passed
Test: Minimal transfers after multijoins ...
  ... Passed
Test: Minimal transfers after multileaves ...
  ... Passed
Test: Check Same config on servers ...
  ... Passed
PASS
ok  	6.824/shardctrler	5.641s
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;shardkv&#34;&gt;ShardKV&lt;/h2&gt;
&lt;h3 id=&#34;整体结构&#34;&gt;整体结构&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ShardKV&lt;/code&gt; 的状态机 db 由多个 Shard 组成，每个 Shard 包含了自己的状态、kv和客户端请求去重表，这使得不同的 Shard 之间可以在独立迁移的同时不影响未受影响的 Shard 对外正常提供服务，也可以通过 Shard 的状态来进行许多判断，每个状态的含义在注释中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; ShardKV &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	mu           sync.RWMutex
	me           &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	rf           &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;raft.Raft
	applyCh      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; raft.ApplyMsg
	make_end     &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd
	gid          &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	ctrlers      []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd
	maxraftstate &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// snapshot if log grows this big
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your definitions here.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	prevConfig       shardctrler.Config
	currConfig       shardctrler.Config
	persister        &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;raft.Persister
	scClerk          &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;shardctrler.Clerk
	waitChs      	 &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; CommandResponse
	db               &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Shard
	lastAppliedIndex &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; ShardStatus &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;const&lt;/span&gt; (
	&lt;span style=&#34;color:#6272a4&#34;&gt;// The group serves and owns the shard.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Serving ShardStatus = &lt;span style=&#34;color:#ff79c6&#34;&gt;iota&lt;/span&gt;
	&lt;span style=&#34;color:#6272a4&#34;&gt;// The group serves the shard, but does not own the shard yet.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Pulling
	&lt;span style=&#34;color:#6272a4&#34;&gt;// The group does not serve and own the partition.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Invalid
	&lt;span style=&#34;color:#6272a4&#34;&gt;// The group owns but does not serve the shard.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Erasing
	&lt;span style=&#34;color:#6272a4&#34;&gt;// The group own the shard and serve it, but it&amp;#39;s waiting for ex-owner to delete it
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Waiting
)

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Shard &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Status       ShardStatus
	KV           &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;
	LastSessions &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Session
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;leader需要执行多个定时任务，需要在后台启动协程来循环判断状态、执行任务、睡眠。我抽象出了一个 &lt;code&gt;daemon&lt;/code&gt; 函数来完成这些。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;StartServer&lt;/span&gt;(servers []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd, me &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, persister &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;raft.Persister, maxraftstate &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, gid &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, ctrlers []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd, make_end &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV {
	···
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your initialization code here.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Use something like this to talk to the shardctrler:
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#6272a4&#34;&gt;// kv.mck = shardctrler.MakeClerk(kv.ctrlers)
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	kv.applyCh = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; raft.ApplyMsg)
	kv.rf = raft.&lt;span style=&#34;color:#50fa7b&#34;&gt;Make&lt;/span&gt;(servers, me, persister, kv.applyCh)
	kv.scClerk = shardctrler.&lt;span style=&#34;color:#50fa7b&#34;&gt;MakeClerk&lt;/span&gt;(kv.ctrlers)
	kv.mu = sync.RWMutex{}
	kv.waitChs = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; CommandResponse)
	kv.db = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Shard)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;; i &amp;lt; shardctrler.NShards; i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt; {
		kv.db[i] = &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;Shard{
			Status:       Invalid,
			KV:           &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;),
			LastSessions: &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Session),
		}
	}

	kv.lastAppliedIndex = &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;
	kv.prevConfig = shardctrler.Config{}
	kv.currConfig = shardctrler.Config{}
	kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applySnapshot&lt;/span&gt;(persister.&lt;span style=&#34;color:#50fa7b&#34;&gt;ReadSnapshot&lt;/span&gt;())

	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applier&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;daemon&lt;/span&gt;(kv.fetchConfig)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;daemon&lt;/span&gt;(kv.pullData)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;daemon&lt;/span&gt;(kv.eraseData)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;daemon&lt;/span&gt;(kv.proposeEmpty)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; kv
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;daemon&lt;/span&gt;(action &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;()) {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;killed&lt;/span&gt;() {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; _, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetState&lt;/span&gt;(); isLeader {
			&lt;span style=&#34;color:#50fa7b&#34;&gt;action&lt;/span&gt;()
		}

		time.&lt;span style=&#34;color:#50fa7b&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;50&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Millisecond)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;applier 的结构和lab3类似，日志被 commit 之后根据 CommandType 的不同执行不同的applyxxx，其中 &lt;code&gt;EraseData&lt;/code&gt; 和 &lt;code&gt;ClientRequest&lt;/code&gt; 需要返回 response。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; CommandType &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;const&lt;/span&gt; (
	ClientRequest CommandType = &lt;span style=&#34;color:#ff79c6&#34;&gt;iota&lt;/span&gt;
	ConfChange
	InsertData
	EraseData
	StopWaiting
	Empty
)

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; RaftLogCommand &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	CommandType
	Data &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{}
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(commandType CommandType, data &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{}) RaftLogCommand {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; RaftLogCommand{
		CommandType: commandType,
		Data: data,
	}
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;applier&lt;/span&gt;() {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;killed&lt;/span&gt;() {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; applyMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;kv.applyCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; applyMsg.CommandValid {
				command &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; applyMsg.Command.(RaftLogCommand)
				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()

				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; applyMsg.CommandIndex &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;=&lt;/span&gt; kv.lastAppliedIndex {
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] discard out-of-date apply Msg [index %d]&amp;#34;&lt;/span&gt;, kv.gid, kv.me, applyMsg.CommandIndex)
					kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
					&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
				}

				kv.lastAppliedIndex = applyMsg.CommandIndex
				response &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;CommandResponse{}
				&lt;span style=&#34;color:#ff79c6&#34;&gt;switch&lt;/span&gt; command.CommandType {
				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; Empty:
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] get empty in apply Msg [index %d]&amp;#34;&lt;/span&gt;, kv.gid, kv.me, applyMsg.CommandIndex)
				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; ConfChange:
					lastestConf &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; command.Data.(shardctrler.Config)
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyConfChange&lt;/span&gt;(lastestConf, applyMsg.CommandIndex)

				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; InsertData:
					resp &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; command.Data.(PullDataResponse)
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyInsertData&lt;/span&gt;(resp, applyMsg.CommandIndex)

				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; StopWaiting:
					req &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; command.Data.(EraseDataRequest)
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyStopWaiting&lt;/span&gt;(req, applyMsg.CommandIndex)

				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; EraseData:
					req &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; command.Data.(EraseDataRequest)
					response = kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyEraseData&lt;/span&gt;(req, applyMsg.CommandIndex)
					&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; currentTerm, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetState&lt;/span&gt;(); currentTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; applyMsg.CommandTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isLeader {
						ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getWaitCh&lt;/span&gt;(applyMsg.CommandIndex)
						ch &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;response
					}

				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; ClientRequest:
					request &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; command.Data.(CommandRequest)
					response = kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyClientRequest&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;request, applyMsg.CommandIndex)
					&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; currentTerm, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetState&lt;/span&gt;(); currentTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; applyMsg.CommandTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isLeader {
						ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getWaitCh&lt;/span&gt;(applyMsg.CommandIndex)
						ch &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;response
					}
				}

				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;needToSnapshot&lt;/span&gt;(applyMsg.RaftStateSize) {
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] take a snapshot till [index %d]&amp;#34;&lt;/span&gt;, kv.gid, kv.me, applyMsg.CommandIndex)
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;takeSnapshot&lt;/span&gt;(applyMsg.CommandIndex)
				}

				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
			} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
				&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] received a snapshot from raft layer [index %d]&amp;#34;&lt;/span&gt;, kv.gid, kv.me, applyMsg.SnapshotIndex)
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;CondInstallSnapshot&lt;/span&gt;(applyMsg.SnapshotTerm, applyMsg.SnapshotIndex, applyMsg.Snapshot) {
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applySnapshot&lt;/span&gt;(applyMsg.Snapshot)
					kv.lastAppliedIndex = applyMsg.SnapshotIndex
				}

				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;客户端请求&#34;&gt;客户端请求&lt;/h3&gt;
&lt;p&gt;这里和lab3基本一样，不同的是 handle RPC 以及日志apply时都需要额外判断在当前版本的 Config 下本 Group 是否负责该 key 所属的 Shard。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;isShardMatch&lt;/span&gt;(shardId &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; kv.currConfig.Shards[shardId] &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; kv.gid &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (kv.db[shardId].Status &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Serving &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; kv.db[shardId].Status &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Waiting)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;配置更新&#34;&gt;配置更新&lt;/h3&gt;
&lt;p&gt;每个 Group 中的 leader 需要在后台启动一个协程向 ShardCtrler 定时使用 &lt;code&gt;Query&lt;/code&gt; 拉取最新的 Config，一旦拉取到就需要提交一条 raft 日志，以在每台机器上更新配置。&lt;/p&gt;
&lt;p&gt;此外，每次只能拉取高一个版本的配置，而且为了防止集群的分片状态被覆盖，从而使得某些任务永远不会被执行，只有在每一 Shard 的状态都为 &lt;code&gt;Serving&lt;/code&gt; 或 &lt;code&gt;Invalid&lt;/code&gt; 时才能拉取、更新配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;fetchConfig&lt;/span&gt;() {
	canFetchConf &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	currConfNum &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.currConfig.Num
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; shardId, shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; kv.db {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; shard.Status &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; Serving &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; shard.Status &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; Invalid {
			canFetchConf = &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
			&lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;
		}
	}

	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; canFetchConf {
		latestConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.scClerk.&lt;span style=&#34;color:#50fa7b&#34;&gt;Query&lt;/span&gt;(currConfNum &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; latestConfig.Num &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; currConfNum&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt; {
			kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(ConfChange, latestConfig))
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在每台机器上，新配置对应的 raft 日志被 commit 之后，都需要更新本地的 &lt;code&gt;prevConfig&lt;/code&gt; 和 &lt;code&gt;currConfig&lt;/code&gt;，以及更新 db 中对应的 Shard 状态，以便让数据拉取、数据清理协程能检测到去进行数据迁移。&lt;/p&gt;
&lt;p&gt;在新版本的 Config 中新增的 Shard 状态改为 Pulling，等待拉取数据协程去其他 Group 上拉数据。失去的 Shard 状态改为 Erasing，等待其他 Group 来拉取数据。若当前 Config 的版本为1，则代表集群刚初始化，不需要去其他 Group 拉取数据，只需更改对应的 Shard 状态为 Serving。&lt;/p&gt;
&lt;h3 id=&#34;数据拉取&#34;&gt;数据拉取&lt;/h3&gt;
&lt;p&gt;新的 Config 在 applier 协程中被应用并不表示所属分片可以立刻对外提供服务，还需要等待在上一个版本的 Config 中不属于自身的 Shard 从它之前所属的 Group 中迁移到本 Group。&lt;/p&gt;
&lt;p&gt;这里显然不能在配置更新时同步阻塞的去拉取 Shard，这会阻塞 applier 协程，严重影响对外服务的可用性。那么是否可以异步的去拉取数据并提交日志？其实不行，leader 可能会在 apply 新配置之后到新数据被异步拉取到并提交日志之前宕机，而 follower 虽然会 apply 配置但是不会去拉数据，这样这些数据将永远无法被更新。&lt;/p&gt;
&lt;p&gt;因此，我们不能在 apply 配置的时候启动异步任务，而是应该只更新 shard 的状态，由单独的后台协程去检测每个 Shard 的状态，从而判断是否需要并执行分片迁移，分片清理等任务。为了让单独的协程能知道该向哪个 Group 去拉取数据或让它去删除数据，&lt;code&gt;ShardKV&lt;/code&gt; 需要维护 currConfig 和 prevConfig，这样其他协程能够通过它们来得知所有 Shard 的 ex-owner。&lt;/p&gt;
&lt;p&gt;需要定义新的RPC来完成数据拉取。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; PullDataRequest &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	ConfNum  &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	ShardIds []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; PullDataResponse &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Err     Err
	ConfNum &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	Shards  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Shard
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并行向状态为 &lt;code&gt;Pulling&lt;/code&gt; 的不同 Shard 的 ex-owner 发送RPC来拉取数据，使用 waitGroup 来保证尝试拉取了一遍当前版本的配置所需要的所有 Shard 之后才能进行下一轮循环。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;pullData&lt;/span&gt;() {
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	groupToShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getGroupToShards&lt;/span&gt;(Pulling)
	currConfNum &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.currConfig.Num
	wg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; sync.WaitGroup{}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; gid, shards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; groupToShards {
		wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
		servers &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.prevConfig.Groups[gid]
		&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(servers []&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, shards []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, confNum &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Done&lt;/span&gt;()
			&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, server &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; servers {
				shardOwner &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;make_end&lt;/span&gt;(server)
				args &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; PullDataRequest{
					ConfNum:  confNum,
					ShardIds: shards,
				}

				reply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; PullDataResponse{}
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; shardOwner.&lt;span style=&#34;color:#50fa7b&#34;&gt;Call&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;ShardKV.PullData&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply) &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; reply.Err &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; OK {
					kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(InsertData, resp))
					&lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;
				}
			}
		}(servers, shards, currConfNum)
	}

	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()
	wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Wait&lt;/span&gt;()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据的被拉取方在处理 RPC 时，只有在 PullDataRequest 中的配置版本与自身的配置版本相同时，才回应其需要的 Shard 信息。需要注意正确的对所有 Shard 深拷贝。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;PullData&lt;/span&gt;(args &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;PullDataRequest, reply &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;PullDataResponse) {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] reply %s for PULL DATA request %s&amp;#34;&lt;/span&gt;, kv.gid, kv.me, reply, args)
	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] received a PULL DATA request %s&amp;#34;&lt;/span&gt;, kv.gid, kv.me, args)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; _, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetState&lt;/span&gt;(); !isLeader {
		reply.Err = ErrWrongLeader
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.currConfig.Num &amp;lt; args.ConfNum {
		reply.Err = ErrNotReady
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.currConfig.Num &amp;gt; args.ConfNum {
		&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;panic&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;duplicated pull data request&amp;#34;&lt;/span&gt;)
	}

	replyShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Shard)

	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, shardId &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; args.ShardIds {
		shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.db[shardId]
		replyShards[shardId] = &lt;span style=&#34;color:#50fa7b&#34;&gt;deepCopyShard&lt;/span&gt;(shard)
	}

	reply.ConfNum = kv.currConfig.Num
	reply.Shards = replyShards
	reply.Err = OK
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 applyInsertData 时，为了保证集群数据变更的幂等性，要保证 Config 的版本与当前版本相同时以及其 Shard 的本地状态为 &lt;code&gt;Pulling&lt;/code&gt; 时才能更新 Shard 的状态。将其状态改为 &lt;code&gt;Waiting&lt;/code&gt; 让数据清理协程去检测。&lt;/p&gt;
&lt;h3 id=&#34;数据清理&#34;&gt;数据清理&lt;/h3&gt;
&lt;h4 id=&#34;current-owner&#34;&gt;current owner&lt;/h4&gt;
&lt;p&gt;在完成数据拉取之后，需要清理掉每个新拉到的 Shard 对应的 ex-owner 机器上的旧数据。后台协程检查所有状态为 &lt;code&gt;Waiting&lt;/code&gt; 的 Shard，并行向它们的 ex-owners 分别发送 RPC，告知它们：我已拉取到我要的数据，现在你可以把它们（对应的 Shard 状态为 Erasing）删了。这里 waitGroup 的用法同上。&lt;/p&gt;
&lt;p&gt;RPC返回且得知 ex-owners 上的数据清理已经完成后需要提交一条 &lt;code&gt;StopWaiting&lt;/code&gt; 类型的 raft 日志，将这个信息同步到 Group 内所有机器上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; EraseDataRequest &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	ConfNum  &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	ShardIDs []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; EraseDataResponse &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Err Err
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;eraseData&lt;/span&gt;() {
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	groupToShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getGroupToShards&lt;/span&gt;(Waiting)
	currConfNum &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.currConfig.Num
	wg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; sync.WaitGroup{}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; gid, shards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; groupToShards {
		wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
		servers &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.prevConfig.Groups[gid]
		&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(servers []&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, shards []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, confNum &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Done&lt;/span&gt;()
			&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, server &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; servers {
				shardOwner &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;make_end&lt;/span&gt;(server)
				args &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; EraseDataRequest{
					ConfNum:  confNum,
					ShardIDs: shards,
				}

				reply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; EraseDataResponse{}
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; shardOwner.&lt;span style=&#34;color:#50fa7b&#34;&gt;Call&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;ShardKV.EraseData&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply) &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; reply.Err &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; OK {
					kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(StopWaiting, req))
					&lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;
				}
			}
		}(servers, shards, currConfNum)
	}

	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()
	wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Wait&lt;/span&gt;()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;StopWaiting&lt;/code&gt; 日志以及 Shard 的 &lt;code&gt;Waiting&lt;/code&gt; 状态存在的用途是标记我是否已经成功在 ex-owner 上删除过期的 Shard。applyStopWaiting 时，在 Config 版本相同时将对应的状态为 &lt;code&gt;Waiting&lt;/code&gt; 的 Shard 更新状态为 &lt;code&gt;Serving&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;ex-owner&#34;&gt;ex-owner&lt;/h4&gt;
&lt;p&gt;ex-owner 在 handle &lt;code&gt;EraseData&lt;/code&gt; 的RPC时，需要返回数据清理是否完成，这里的处理类似处理客户端请求，不需要进行去重。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;EraseData&lt;/span&gt;(req &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;EraseDataRequest, resp &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;EraseDataResponse) {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] resp %s for ERASE DATA request %s&amp;#34;&lt;/span&gt;, kv.gid, kv.me, resp, req)
	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] received a ERASE DATA request %s&amp;#34;&lt;/span&gt;, kv.gid, kv.me, req)
	index, _, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(EraseData, &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;req))
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !isLeader {
		resp.Err = ErrWrongLeader
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
	ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getWaitCh&lt;/span&gt;(index)
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; response &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;ch:
		resp.Err = response.Err

	&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;500&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Millisecond).C:
		resp.Err = ErrTimeout
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;() {
		kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
		kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;removeWaitCh&lt;/span&gt;(index)
		kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
	}()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;apply 时，在版本号相同的情况下将对应的状态为 &lt;code&gt;Erasing&lt;/code&gt; 的 Shard 更新为 &lt;code&gt;Invalid&lt;/code&gt;，表明对应 Shard 已经成功被清除，清空 kv 和客户端请求去重表。不要忘了返回OK。&lt;/p&gt;
&lt;h3 id=&#34;提交空日志&#34;&gt;提交空日志&lt;/h3&gt;
&lt;p&gt;在某个涉及重启的测试中，有时候会出现集群对外出现活锁，无法再服务请求直到超时。我重新打了很多日志，发现这时各个 Group 间的 Config 版本不一致，且版本较低的 Group 的一些 Shard 状态不为 &lt;code&gt;Serving&lt;/code&gt; 和 &lt;code&gt;Invalid&lt;/code&gt;，这卡着配置更新协程无法拉取最新的 Config。按理说 Config 的版本只能以1为公差递增，其余的 Group 版本高说明也经历过较低的这个版本，应该有向这个 Group 发送过拉取数据和清理数据的RPC来更新 Shard 状态，那么为什么状态并没有被更新呢？&lt;/p&gt;
&lt;p&gt;仔细读了很久日志，我发现版本较低的 Group 在推进 Config 到这个版本之后已经正确处理过拉取数据或是清理数据的RPC也更新了 Shard 状态，但在重启后这最后处理的关键RPC对应的日志并没有重新被commit。原来，此时 leader 的 currentTerm 高于这个RPC对应的日志的 term，且这个时间节点客户端碰巧没有向该 Group 组执行读写请求，导致 leader 无法拥有当前任期的 term 的日志，无法将状态机更新到最新。&lt;/p&gt;
&lt;p&gt;lab4的最后一部分是我在写完 TinyKV 之后做的，我想到 TinyKV （其实 etcd 也是这么做的）中要求的 leader 在当选时要先提交一条空日志，这样可以保证集群的可用性，于是我也移植了这个特性到 6.824 中。&lt;/p&gt;
&lt;p&gt;想起了以前几个月前看过的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md#%E7%A9%BA%E6%97%A5%E5%BF%97%E6%A3%80%E6%B5%8B&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;谭新宇&lt;/a&gt; 的文章，我知道了不能把这个特性加到 raft 层。于是我也让 leader 在 kv 层周期性的去检测下层是否包含当前 term 的日志，如果没有便 append 一条空日志，这样即可保证新选出的 leader 状态机能够迅速达到最新。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;proposeEmpty&lt;/span&gt;() {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;HasLogAtCurrentTerm&lt;/span&gt;() {
		kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(Empty, &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;))
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;测试结果-1&#34;&gt;测试结果&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;Test: static shards ...
  ... Passed
Test: join then leave ...
  ... Passed
Test: snapshots, join, and leave ...
  ... Passed
Test: servers miss configuration changes...
  ... Passed
Test: concurrent puts and configuration changes...
  ... Passed
Test: more concurrent puts and configuration changes...
  ... Passed
Test: concurrent configuration change and restart...
  ... Passed
Test: unreliable 1...
  ... Passed
Test: unreliable 2...
  ... Passed
Test: unreliable 3...
  ... Passed
Test: shard deletion (challenge 1) ...
  ... Passed
Test: unaffected shard access (challenge 2) ...
  ... Passed
Test: partial migration shard access (challenge 2) ...
  ... Passed
PASS
ok  	6.824/shardkv	108.040s
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>mit-6.824 lab3: RaftKV</title>
        <link>https://ziannchen.work/2022/mit-6.824-lab3-raftkv/</link>
        <pubDate>Thu, 03 Feb 2022 15:06:21 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/mit-6.824-lab3-raftkv/</guid>
        <description>&lt;h1 id=&#34;lab3-kvraft&#34;&gt;Lab3: KVRaft&lt;/h1&gt;
&lt;p&gt;lab链接 &lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本次lab中我们需要使用lab2中实现的Raft库来构建一个可容错的 Key/Value 存储服务，要求其对外提供强一致性（&lt;code&gt;Strong consistency&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;这个KV存储服务支持Get/Put/Append三种客户端操作。客户端通过RPC与集群中的leader通信，leader接收到请求后将其包装在一条Raft日志中下放到Raft层进行共识，日志被apply后返回客户端结果。&lt;/p&gt;
&lt;h2 id=&#34;一些思考&#34;&gt;一些思考&lt;/h2&gt;
&lt;p&gt;在PartA的描述中提到，leader在将一个请求下放到raft层之后，commit之前宕机，这时它无法回复Clerk。又或者是，这条日志成功commit，但返回的RPC丢失。Clerk在规定时间内没有收到结果，会向另一台主机（可能是新选出的leader）发送RPC，这条日志最终被commit之后又会被应用于状态机，从而状态机执行了两次相同的请求。&lt;/p&gt;
&lt;p&gt;这要求我们能够判断重复的请求。因此每个请求都需要被唯一标识，请求中需要加上（ClientID, RequestID），Clerk每次请求成功之后自增RequestID。&lt;/p&gt;
&lt;p&gt;我们还需要在遇到重复的请求时直接返回第一次请求时的结果，这需要我们保存每一个Clerk的最后一次请求的结果ClientID -&amp;gt; (RequestID, LastResponse)。只需要保存最后一次请求结果是因为如果服务端收到RequestID = x的RPC，说明这个Clerk已经收到了RequestID为[1, x-1]之间内的所有请求的结果，服务端如果再次收到这个RequestID在区间之内的请求说明该RPC过期，直接丢弃即可。&lt;/p&gt;
&lt;h2 id=&#34;client&#34;&gt;client&lt;/h2&gt;
&lt;p&gt;我将3种请求共用了一个RPC，简化了逻辑。&lt;/p&gt;
&lt;p&gt;Clerk保存一个leaderID，请求失败了再换另一个server，请求成功了自增requestID。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Clerk &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	servers []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd
	&lt;span style=&#34;color:#6272a4&#34;&gt;// You will have to modify this struct.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	leaderID  &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	clientID  &lt;span style=&#34;color:#8be9fd&#34;&gt;int64&lt;/span&gt;
	requestID &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (ck &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Clerk) &lt;span style=&#34;color:#50fa7b&#34;&gt;Get&lt;/span&gt;(key &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; ck.&lt;span style=&#34;color:#50fa7b&#34;&gt;Command&lt;/span&gt;(key, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, OpGet)
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (ck &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Clerk) &lt;span style=&#34;color:#50fa7b&#34;&gt;Put&lt;/span&gt;(key &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, value &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) {
	ck.&lt;span style=&#34;color:#50fa7b&#34;&gt;Command&lt;/span&gt;(key, value, OpPut)
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (ck &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Clerk) &lt;span style=&#34;color:#50fa7b&#34;&gt;Append&lt;/span&gt;(key &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, value &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) {
	ck.&lt;span style=&#34;color:#50fa7b&#34;&gt;Command&lt;/span&gt;(key, value, OpAppend)
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (ck &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Clerk) &lt;span style=&#34;color:#50fa7b&#34;&gt;Command&lt;/span&gt;(key, value &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, op Operation) &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; {
	req &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;getCommandRequest&lt;/span&gt;(key, value, op, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;int&lt;/span&gt;(ck.clientID), ck.requestID)	
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; {
		resp &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; CommandResponse{}
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !ck.servers[ck.leaderID].&lt;span style=&#34;color:#50fa7b&#34;&gt;Call&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;KVServer.Command&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;req, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;resp) &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; resp.Err &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; ErrWrongLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; resp.Err &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; ErrTimeout {		
			ck.leaderID = (ck.leaderID &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#ff79c6&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(ck.servers)
			&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
		}

		ck.requestID&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;	resp.Value	
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;server&#34;&gt;server&lt;/h2&gt;
&lt;p&gt;KVServer的结构体如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; KVServer &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	mu      sync.RWMutex
	me      &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	rf      &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;raft.Raft
	applyCh &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; raft.ApplyMsg
	dead    &lt;span style=&#34;color:#8be9fd&#34;&gt;int32&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// set by Kill()
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
	maxraftstate &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// snapshot if log grows this big
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your definitions here.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	persister        &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;raft.Persister
	waitChs      	 &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandResponse
	db               &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;
	lastSessions     &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]Session
	lastAppliedIndex &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;state-machine&#34;&gt;state-machine&lt;/h3&gt;
&lt;p&gt;本次lab中只需使用一个内存版本的 KV 状态机 map[string]string。&lt;/p&gt;
&lt;h3 id=&#34;rpc-handler&#34;&gt;RPC handler&lt;/h3&gt;
&lt;p&gt;客户端请求来临时，Server端会启动一个协程作为 RPC handler 来处理客户端请求，其中会调用 &lt;code&gt;Raft.Start&lt;/code&gt; 函数将请求下放到 Raft 层形成一条日志去做共识。在 Raft 层，每条被commit的日志会按照 index 的顺序写入 applyCh 中，上层必须也按 index 序从applyCh中读出日志并应用于状态机，这样才能保证不同节点上的数据一致。&lt;/p&gt;
&lt;p&gt;这要求必须有一个单独的applier协程来循环读applyCh，并应用于状态机。由于来自不同客户端的请求是并发的，如果在RPC handler协程中直接读applyCh无法保证index序。返回给客户端的response要根据日志应用于状态机的结果来生成，这需要我们处理RPC handler和applier协程之间的通信问题。&lt;/p&gt;
&lt;p&gt;自然想到使用channel来通信，使用一个 waitChs map (log index -&amp;gt; response) 来记录每一个请求对应的channel。在RPC handler协程将日志下放到Raft层之后，在 waitChs 中注册一个channel并阻塞读，applier协程读出日志，应用于状态机之后生成response写入这个channel。RPC handler协程在规定时间内读出结果则正常返回客户端，若超时则返回超时。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;KVServer) &lt;span style=&#34;color:#50fa7b&#34;&gt;Command&lt;/span&gt;(req &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandRequest, resp &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandResponse) {
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your code here.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] reply %+v for Request %+v&amp;#34;&lt;/span&gt;, kv.me, resp, req)

	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] received Request %+v from Clerk&amp;#34;&lt;/span&gt;, kv.me, req)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; req.Op &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; OpGet &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;isDuplicatedRequest&lt;/span&gt;(req.ClientID, req.RequestID) {
		resp.Err = kv.lastSessions[req.ClientID].Err
		kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()

	index, _, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;req)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !isLeader {
		resp.Err = ErrWrongLeader
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] add command into raft layer [index %d]&amp;#34;&lt;/span&gt;, kv.me, index)
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
	ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getWaitCh&lt;/span&gt;(index)
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; result &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;ch:
		resp.Value = result.Value
		resp.Err = result.Err

	&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;500&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Millisecond).C:
		resp.Err = ErrTimeout
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;() {
		kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
		kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;removeWaitCh&lt;/span&gt;(index)
		kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
	}()
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;KVServer) &lt;span style=&#34;color:#50fa7b&#34;&gt;applier&lt;/span&gt;() {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;killed&lt;/span&gt;() {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; applyMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;kv.applyCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; applyMsg.CommandValid {
				command &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; applyMsg.Command.(CommandRequest)
				
				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; applyMsg.CommandIndex &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;=&lt;/span&gt; kv.lastAppliedIndex {
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] discard out-of-date apply Msg in [index %d]&amp;#34;&lt;/span&gt;, kv.me, applyMsg.CommandIndex)
					kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
					&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
				}
				
				kv.lastAppliedIndex = applyMsg.CommandIndex
				&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; response &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandResponse
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; command.Op &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; OpGet &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;isDuplicatedRequest&lt;/span&gt;(command.ClientID, command.RequestID) {
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] received a duplicated command in [index %d]&amp;#34;&lt;/span&gt;, kv.me, applyMsg.CommandIndex)
					response = kv.lastSessions[command.ClientID].CommandResponse
				} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
					response = kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyCommand&lt;/span&gt;(command)
					&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; command.Op &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; OpGet {
						kv.lastSessions[command.ClientID] = Session{
							RequestID:       command.RequestID,
							CommandResponse: response,
						}
					}
				}

				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;needToSnapshot&lt;/span&gt;(applyMsg.RaftStateSize) {
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] reach maxraftstate, take a snapshot till [index %d]&amp;#34;&lt;/span&gt;, kv.me, applyMsg.CommandIndex)
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;takeSnapshot&lt;/span&gt;(applyMsg.CommandIndex)
				}

				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; currentTerm, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetState&lt;/span&gt;(); currentTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; applyMsg.CommandTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isLeader {
					ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getWaitCh&lt;/span&gt;(applyMsg.CommandIndex)
					ch &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; response
				}

				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
			} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
				&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] received a snapshot from raft layer [index %d, term %d]&amp;#34;&lt;/span&gt;, kv.me, applyMsg.SnapshotIndex, applyMsg.SnapshotTerm)
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;CondInstallSnapshot&lt;/span&gt;(applyMsg.SnapshotTerm, applyMsg.SnapshotIndex, applyMsg.Snapshot) {
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applySnapshotToService&lt;/span&gt;(applyMsg.Snapshot)
					kv.lastAppliedIndex = applyMsg.SnapshotIndex
				}
				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有几点需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;apply日志时需要防止状态机回滚。在lab2中提到作为follower的节点可能收到leader的install snapshot，将snapshot写入applyCh中，此时读applyCh的顺序是：旧日志1 -&amp;gt; 新快照 -&amp;gt; 旧日志2。应用了新快照之后要避免再次应用旧日志，所以应用快照之后也要更新 lastAppliedIndex，应用日志时要先判断是否 applyMsg.CommandIndex &amp;lt;= kv.lastAppliedIndex。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仅对leader的waitCh进行通知。每个节点在读出日志后都要提交到状态机，且更新lastSessions。但只有leader需要将response写入waitCh。leader可能会在提交日志后失去leader身份，所以在applier中写入response前要先判断。此时RPC handler协程就让其超时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端的非读请求需要两次去重。重复的请求到来时，之前相同的请求可能已经被应用于该节点的状态机，也可能其对应的日志还没被commit。因此需要在RPC handler中调用Start之前以及日志commit之后应用于状态机之前两次去重。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;leader在调用Start提交日志后去获取waitCh来阻塞读 以及 applier 在commit日志并应用于状态机之后获取waitCh来写入response 这二者之间顺序无法保证。因此channel容量设置为1，先获取channel的协程要负责创建channel，这个过程要加写锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;KVServer) &lt;span style=&#34;color:#50fa7b&#34;&gt;getWaitCh&lt;/span&gt;(index &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandResponse {
	ch, ok &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.waitChs[index]
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !ok {
		ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandResponse, &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
		kv.waitChs[index] = ch
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; ch
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; ch
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;snapshot&#34;&gt;snapshot&lt;/h3&gt;
&lt;p&gt;part B中要求我们在raft state size达到阈值时给raft层下发快照。快照中不仅需要包含KV状态机，还需要包含lastSessions客户端请求去重表。由于快照是和lastIncludeIndex对应的，所以需要由applier协程在将对应的index的日志应用于状态机后继续阻塞的生成快照。&lt;/p&gt;
&lt;h2 id=&#34;测试结果&#34;&gt;测试结果&lt;/h2&gt;
&lt;h3 id=&#34;3a&#34;&gt;3A&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;Test: one client (3A) ...
  ... Passed --  15.1  5  9881  941
Test: ops complete fast enough (3A) ...
  ... Passed --  15.5  3  7032    0
Test: many clients (3A) ...
  ... Passed --  15.6  5 11160 1171
Test: unreliable net, many clients (3A) ...
  ... Passed --  16.2  5  7462  901
Test: concurrent append to same key, unreliable (3A) ...
  ... Passed --   1.5  3   282   52
Test: progress in majority (3A) ...
  ... Passed --   1.1  5   108    2
Test: no progress in minority (3A) ...
  ... Passed --   1.0  5   184    3
Test: completion after heal (3A) ...
  ... Passed --   1.0  5    63    3
Test: partitions, one client (3A) ...
  ... Passed --  22.5  5  9323  643
Test: partitions, many clients (3A) ...
  ... Passed --  23.3  5 18230  837
Test: restarts, one client (3A) ...
  ... Passed --  22.0  5 12689  822
Test: restarts, many clients (3A) ...
  ... Passed --  22.9  5 24109 1144
Test: unreliable net, restarts, many clients (3A) ...
  ... Passed --  25.7  5  9398  873
Test: restarts, partitions, many clients (3A) ...
  ... Passed --  30.3  5 19984  848
Test: unreliable net, restarts, partitions, many clients (3A) ...
  ... Passed --  29.9  5  7443  622
Test: unreliable net, restarts, partitions, random keys, many clients (3A) ...
  ... Passed --  32.9  7 14185  904
PASS
ok  	6.824/kvraft	277.625s
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3b&#34;&gt;3B&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;Test: InstallSnapshot RPC (3B) ...
  ... Passed --   3.4  3  2151   63
Test: snapshot size is reasonable (3B) ...
  ... Passed --   2.8  3  5727  800
Test: ops complete fast enough (3B) ...
  ... Passed --   3.2  3  6962    0
Test: restarts, snapshots, one client (3B) ...
  ... Passed --  21.2  5 46519 4431
Test: restarts, snapshots, many clients (3B) ...
  ... Passed --  21.6  5 53053 4531
Test: unreliable net, snapshots, many clients (3B) ...
  ... Passed --  15.9  5 11057 1341
Test: unreliable net, restarts, snapshots, many clients (3B) ...
  ... Passed --  22.3  5 12478 1412
Test: unreliable net, restarts, partitions, snapshots, many clients (3B) ...
  ... Passed --  29.6  5  8653  760
Test: unreliable net, restarts, partitions, snapshots, random keys, many clients (3B) ...
  ... Passed --  31.6  7 25416 1802
PASS
ok  	6.824/kvraft	151.660s
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>mit-6.824 lab2: Raft</title>
        <link>https://ziannchen.work/2022/mit-6.824-lab2-raft/</link>
        <pubDate>Thu, 03 Feb 2022 15:04:30 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/mit-6.824-lab2-raft/</guid>
        <description>&lt;h1 id=&#34;lab2-raft&#34;&gt;Lab2: Raft&lt;/h1&gt;
&lt;p&gt;lab原链接 &lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/labs/lab-raft.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pdos.csail.mit.edu/6.824/labs/lab-raft.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Raft是一种基于复制的状态机协议，通过在多个副本服务器上存储其状态（即数据）的完整副本来实现容错。&lt;/p&gt;
&lt;p&gt;Raft将客户端请求组织成一个称为日志的序列，并通过复制确保所有副本服务器都看到相同的日志。每个副本按日志顺序执行客户端请求，并将它们应用于本地的状态机副本。由于所有副本服务器都看到相同的日志内容，因此它们都以相同的顺序执行相同的请求，从而继续具有相同的服务状态。如果服务器出现故障但随后恢复，Raft保证只要至少半数的服务器存活，并且可以相互通信，就可以保证正常对外服务。&lt;/p&gt;
&lt;p&gt;在本次lab中我们的任务是使用go语言实现raft。参考论文 &lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;raft-extended&lt;/a&gt;，我们需要实现除了集群成员变更之外的绝大部分内容。论文中我认为最核心的就是描述3个RPC的(Figure 2)这张图，我的实现大体上遵循了这张图。此外我也参考了一些工业级的raft实现，比如SOFAJraft、etcd，做了一些优化。在我秋招面试美团的一个做分布式存储的部门时，他们问了我很多关于raft的内容（虽然最后挂了）。&lt;/p&gt;
&lt;p&gt;有些需要注意的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当收到的RPC中的term大于自身时，无条件跟随term并转为follower，这在不同的RPC handler中的处理略有不同。&lt;/li&gt;
&lt;li&gt;在lab的一些测试用例中，网络将是不稳定的，带来大量随机的RPC丢包、乱序、超时。对于过期的RPC，直接抛弃不处理即可。对于是否过期的判断体现在term太小、身份不正确之类（例如follow收到append entries response）。&lt;/li&gt;
&lt;li&gt;锁的使用：在接发RPC、读写channel时一定不要持有锁，不然很有可能死锁。此外有许多代码块对Raft结构中各字段是只读的，我使用了读写锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结构体&#34;&gt;结构体&lt;/h2&gt;
&lt;p&gt;Raft结构中的各个变量和论文大致一样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Raft &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	rw        sync.RWMutex        &lt;span style=&#34;color:#6272a4&#34;&gt;// Lock to protect shared access to this peer&amp;#39;s state
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	peers     []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd &lt;span style=&#34;color:#6272a4&#34;&gt;// RPC end points of all peers
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	persister &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Persister          &lt;span style=&#34;color:#6272a4&#34;&gt;// Object to hold this peer&amp;#39;s persisted state
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	me        &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;                 &lt;span style=&#34;color:#6272a4&#34;&gt;// this peer&amp;#39;s index into peers[]
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	dead      &lt;span style=&#34;color:#8be9fd&#34;&gt;int32&lt;/span&gt;               &lt;span style=&#34;color:#6272a4&#34;&gt;// set by Kill()
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your data here (2A, 2B, 2C).
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#6272a4&#34;&gt;// Look at the paper&amp;#39;s Figure 2 for a description of what
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#6272a4&#34;&gt;// state a Raft server must maintain.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
	currentState   State
	currentTerm    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	votedFor       &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	voteFrom       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;
	logs           []LogEntry
	commitIndex    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	lastApplied    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	nextIndex      []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	matchIndex     []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	electionTimer  &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;time.Timer
	heartbeatTimer &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;time.Timer
	applyCh        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; ApplyMsg
	applierCond    sync.Cond
	replicatorCond []sync.Cond
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Make&lt;/span&gt;(peers []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd, me &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;,
	persister &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Persister, applyCh &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; ApplyMsg) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft {
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your initialization code here (2A, 2B, 2C).
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	rf &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;Raft{
		rw:             sync.RWMutex{},
		peers:          peers,
		persister:      persister,
		me:             me,
		dead:           &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;,
		currentState:   Follower,
		currentTerm:    &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;,
		votedFor:       &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;,
		voteFrom:       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;),
		logs:           &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]LogEntry, &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;),
		nextIndex:      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(peers)),
		matchIndex:     &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(peers)),
		electionTimer:  time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;RandomizedElectionTimeout&lt;/span&gt;()),
		heartbeatTimer: time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;StableHeartbeatTimeout&lt;/span&gt;()),
		applyCh:        applyCh,
		replicatorCond: &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]sync.Cond, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(peers)),
	}

	rf.applierCond = &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;sync.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewCond&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;rf.rw)
	rf.logs[&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;] = LogEntry{&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;}
	&lt;span style=&#34;color:#6272a4&#34;&gt;// initialize from state persisted before a crash
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;readPersist&lt;/span&gt;(persister.&lt;span style=&#34;color:#50fa7b&#34;&gt;ReadRaftState&lt;/span&gt;())
	rf.commitIndex, rf.lastApplied = rf.logs[&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;].Index, rf.logs[&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;].Index
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(peers); i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt; {
		rf.matchIndex[i], rf.nextIndex[i] = &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; me {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
		}

		rf.replicatorCond[i] = &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;sync.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewCond&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;sync.Mutex{})
		&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;replicator&lt;/span&gt;(i)
	}

	&lt;span style=&#34;color:#6272a4&#34;&gt;// start ticker goroutine to start elections
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;ticker&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;applier&lt;/span&gt;(rf.applyCh)

	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; rf
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据论文，日志的index和term都从1开始，所以在logs[0]处存放一个index和term均为0的dummy value。&lt;/p&gt;
&lt;p&gt;在Make函数中启动了一些后台协程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replicator：共len(peers)-1个，用于管理leader对每一个follower的日志复制，下文会详细介绍。&lt;/li&gt;
&lt;li&gt;ticker：用来触发选举和心跳timeout。&lt;/li&gt;
&lt;li&gt;applier：用于向applyCh中提交已经commit的日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;leader-election&#34;&gt;leader-election&lt;/h2&gt;
&lt;h3 id=&#34;sender&#34;&gt;sender&lt;/h3&gt;
&lt;p&gt;在ticker函数中需要循环使用select监听两个timer的channel，lab的提示中说使用timer可能会有问题但我没有遇到过，懒得改了。&lt;/p&gt;
&lt;p&gt;如果是选举计时器到期，则发起一轮选举；如果是心跳计时器到期，则发起一轮心跳。二者都要首先判断当前身份是否正确。我使用了一个map来记录当前term中投票给自己的peer，需要在每次转换为candidate时清空map。也可以每次start election时声明一个得票计数，之后使用闭包来计算。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;ticker&lt;/span&gt;() {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Killed&lt;/span&gt;() {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;rf.electionTimer.C:
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.currentState &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; Leader {
				rf.currentState = Candidate
				rf.voteFrom = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;)
				rf.currentTerm&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;
				rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;startElection&lt;/span&gt;()
			}

			rf.electionTimer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Reset&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;RandomizedElectionTimeout&lt;/span&gt;())
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;rf.heartbeatTimer.C:
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.currentState &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Leader {
				&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] boardcast heartbeat at term %d&amp;#34;&lt;/span&gt;, rf.me, rf.currentTerm)
				rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;boardcastHeartbeat&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;)
			}

			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;选举需要异步对每个peer发送request vote，不然就太慢了。异步才不会阻塞ticker，能快速重置计时器。response handler中要先判断是否仍满足rf.currentTerm == args.Term &amp;amp;&amp;amp; rf.currentState == Candidate，若不满足说明RPC过期，直接抛弃不处理。&lt;/p&gt;
&lt;p&gt;我之所以没有使用闭包是因为这样难以抽象出一个 handleRequestVoteResponse 函数，代码结构不够统一。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;startElection&lt;/span&gt;() {
	args &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getDefaultRequestVoteArgs&lt;/span&gt;()
	rf.votedFor, rf.voteFrom[rf.me] = rf.me, &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] start election at term %d&amp;#34;&lt;/span&gt;, rf.me, rf.currentTerm)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; index &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; rf.peers {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; index &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; rf.me {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
		}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(i &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
			reply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; RequestVoteReply{}
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;sendRequestVote&lt;/span&gt;(i, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply) {
				rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
				rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;handleRequestVoteResponse&lt;/span&gt;(i, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply)
				rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
			}
		}(index)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;handler&#34;&gt;handler&lt;/h3&gt;
&lt;p&gt;handler的实现完全参照论文，先判断term是否小于自身，再判断term、voteFor和日志是否满足条件。判断voteFor时要先满足args.Term == rf.currentTerm，这是由于args.Term &amp;gt; rf.currentTerm时需要无条件跟随term并重置voteFor。&lt;/p&gt;
&lt;p&gt;需要注意的是只有同意投票时才需要重置election timer，这在课程的TA的guidance中有提及，有利于在网络不稳定时仍能快速选出leader。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;RequestVote&lt;/span&gt;(args &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;RequestVoteArgs, reply &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;RequestVoteReply) {
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your code here (2A, 2B).
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] reply [%s] for RequestVote to %d&amp;#34;&lt;/span&gt;, rf.me, reply, args.CandidateId)

	rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d][state %s term %d vote %d lastindex %d lastterm %d] receive RequestVote [%s] from %d&amp;#34;&lt;/span&gt;, rf.me, StateName[rf.currentState], rf.currentTerm, rf.votedFor, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Term, args, args.CandidateId)

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; args.Term &amp;lt; rf.currentTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; (args.Term &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; rf.currentTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; rf.votedFor &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; rf.votedFor &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; args.CandidateId) {
		reply.Term, reply.VoteGranted = rf.currentTerm, &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	needToPersist &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; args.Term &amp;gt; rf.currentTerm {
		rf.currentTerm, rf.votedFor = args.Term, &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;
		&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] change state from Leader to Follower at term %d&amp;#34;&lt;/span&gt;, rf.me, rf.currentTerm)
		rf.currentState = Follower
		needToPersist = &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;isLogUpToDate&lt;/span&gt;(args.LastLogIndex, args.LastLogTerm) {
		reply.Term, reply.VoteGranted = rf.currentTerm, &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; needToPersist {
			rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
		}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	reply.Term, reply.VoteGranted = rf.currentTerm, &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	rf.votedFor = args.CandidateId
	rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
	rf.electionTimer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Reset&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;RandomizedElectionTimeout&lt;/span&gt;())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;log-replication&#34;&gt;log-replication&lt;/h2&gt;
&lt;h3 id=&#34;replicator&#34;&gt;replicator&lt;/h3&gt;
&lt;p&gt;根据每个peer的nextIndex判断发送entries或是snapshot。&lt;/p&gt;
&lt;p&gt;response handler的实现参照论文，先判断是否过期，再判断是否成功。若成功，则更新match、next index。找到最新的复制到超过半数peer且term等于当前term的日志，更新commit。需要注意日志的term必须和当前term一致才能更新commit，不然可能会有安全性问题导致已经commit的日志被覆盖，我忘了哪个测试一直过不了后来发现就是这个原因，所以论文一定要非常仔细读。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;doReplicate&lt;/span&gt;(i &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
	rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.currentState &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; Leader {
		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.nextIndex[i] &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getDummyLogntry&lt;/span&gt;().Index {
		args &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getDefaultInstallSnapshotArgs&lt;/span&gt;()
		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()

		reply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; InstallSnapshotReply{}
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;sendInstallSnapshot&lt;/span&gt;(i, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply) {
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
			rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;handleInstallSnapshotResponse&lt;/span&gt;(i, args, reply)
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
		}
	} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
		args &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getDefaultAppendEntriesArgs&lt;/span&gt;(i)
		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()

		reply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; AppendEntriesReply{}
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;sendAppendEntries&lt;/span&gt;(i, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply) {
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
			rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;handleAppendEntriesReponse&lt;/span&gt;(i, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply)
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我参考了 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LebronAl/MIT6.824-2021/blob/master/docs/lab2.md#%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LebronAI&lt;/a&gt; 的设计。&lt;/p&gt;
&lt;p&gt;如果为每一次Start、心跳都广播发送一次append entries，则将下层的日志同步与上层的提交新指令强绑定了，会造成RPC数量过多，还会重复发送很多次相同的日志项。每次发送 rpc 都不论是发送端还是接收端都需要若干次系统调用和内存拷贝，rpc 次数过多也会对 CPU 造成不必要的压力。&lt;/p&gt;
&lt;p&gt;这里可以做一个batching的优化，也将二者之间解耦。这里原作者参考了SOFAJraft的日志复制模型，让每个peer对于其他所有peer各维护一个replicator协程，负责在自己成为leader时对单独一个peer的日志复制。&lt;/p&gt;
&lt;p&gt;这个协程利用条件变量 &lt;code&gt;sync.Cond&lt;/code&gt; 执行 &lt;code&gt;Wait&lt;/code&gt; 来避免耗费 cpu，每次需要进行一次日志复制时调用 &lt;code&gt;Signal&lt;/code&gt; 唤醒。它在满足复制条件时会尽最大努力将[nextIndex, lastIndex]之间的日志复制到peer上。&lt;/p&gt;
&lt;p&gt;由于leader使用replicator维护对于一个peer的日志复制，同一时间下最多只会发送一个RPC，若RPC丢失、超时很可能触发re-election。因此：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;心跳计时器到期，很急，要立即发送RPC。leader commit更新时也要立即发送RPC，这个是为啥我忘记了。&lt;/li&gt;
&lt;li&gt;Start被调用，不急，只需调用条件变量的 &lt;code&gt;Singal&lt;/code&gt;，让replicator慢慢发。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;replicator&lt;/span&gt;(peer &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
	rf.replicatorCond[peer].L.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; rf.replicatorCond[peer].L.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Killed&lt;/span&gt;() {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;needToReplicate&lt;/span&gt;(peer) {
			rf.replicatorCond[peer].&lt;span style=&#34;color:#50fa7b&#34;&gt;Wait&lt;/span&gt;()
		}

		rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;doReplicate&lt;/span&gt;(peer)
	}
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;needToReplicate&lt;/span&gt;(peer &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt; {
	rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; rf.currentState &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Leader &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; rf.nextIndex[peer] &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index
}
 
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;boardcastHeartbeat&lt;/span&gt;(isHeartbeat &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;) {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; index &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; rf.peers {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; index &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; rf.me {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
		}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; isHeartbeat {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;doReplicate&lt;/span&gt;(index)
		} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
			rf.replicatorCond[index].&lt;span style=&#34;color:#50fa7b&#34;&gt;Signal&lt;/span&gt;()
		}
	}

	rf.heartbeatTimer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Reset&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;StableHeartbeatTimeout&lt;/span&gt;())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;handler-1&#34;&gt;handler&lt;/h3&gt;
&lt;p&gt;完全按照论文图中伪代码实现，包括了课程视频中提到的加速解决日志冲突的优化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;AppendEntries&lt;/span&gt;(args &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;AppendEntriesArgs, reply &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;AppendEntriesReply) {
	rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d][term %d lastindex %d lastterm %d commit %d] receive AppendEntries %+v from %d&amp;#34;&lt;/span&gt;, rf.me, rf.currentTerm, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Term, rf.commitIndex, args, args.LeaderId)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] reply [%s] for AppendEntries to %d&amp;#34;&lt;/span&gt;, rf.me, reply, args.LeaderId)

	needToPersist &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; args.Term &amp;lt; rf.currentTerm {
		reply.Success, reply.Term = &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;, rf.currentTerm
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; args.Term &amp;gt; rf.currentTerm {
		rf.currentTerm = args.Term
		needToPersist = &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	}

	rf.currentState = Follower
	rf.electionTimer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Reset&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;RandomizedElectionTimeout&lt;/span&gt;())

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; args.PrevLogIndex &amp;lt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getDummyLogntry&lt;/span&gt;().Index {
		reply.Success, reply.Term = &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; needToPersist {
			rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
		}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;isLogMatch&lt;/span&gt;(args.PrevLogIndex, args.PrevLogTerm) {
		reply.Term, reply.Success = rf.currentTerm, &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
		reply.XIndex, reply.Term = rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getConflictEntry&lt;/span&gt;(args.PrevLogIndex)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; needToPersist {
			rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
		}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	lastLogIndex &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; index, entry &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; args.Entries {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; entry.Index &amp;gt; lastLogIndex &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; rf.logs[rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getSliceIndex&lt;/span&gt;(entry.Index)].Term &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; entry.Term {
			rf.logs = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(rf.logs[:rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getSliceIndex&lt;/span&gt;(entry.Index)], args.Entries[index:]&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)
			&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] append Follower&amp;#39;s last log index from %d to %d&amp;#34;&lt;/span&gt;, rf.me, lastLogIndex, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index)
			needToPersist = &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
			&lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;
		}
	}

	rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;maybeAdvanceFollowerCommit&lt;/span&gt;(args.LeaderCommit)
	reply.Success = &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; needToPersist {
		rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;persistence&#34;&gt;persistence&lt;/h2&gt;
&lt;p&gt;论文中提到有三个变量是需要持久化的：currentTerm、votedFor、log[]，这三个量每次改变之后都应该持久化。&lt;/p&gt;
&lt;p&gt;持久化应当在被其他协程感知（发送RPC、释放锁）之前完成，而每个函数中如果没有改变这三个量（如加锁之后发现RPC过期）则不用持久化，若有也只需持久化一次，所以我在很多地方都使用了一个 needToPersist 布尔量进行判断。这样写感觉不够优雅，暂时没想到其他方法。&lt;/p&gt;
&lt;h2 id=&#34;log-compaction&#34;&gt;log-compaction&lt;/h2&gt;
&lt;p&gt;对于leader，在replicator中根据next index判断出需要给peer发送快照时，调用 &lt;code&gt;persister.ReadSnapshot&lt;/code&gt; 获得快照并发送。&lt;/p&gt;
&lt;p&gt;对于接收方，需要判断如果 args.LastIncludedIndex &amp;lt;= rf.commitIndex，则拒绝接收快照。这说明本地状态机已经至少比该快照更新（或者将要，因为applier协程已经在apply这些日志的过程中了），可能导致raft回到旧的状态。应当等待service层调用 &lt;code&gt;Snapshot&lt;/code&gt; 函数来安装快照。接收快照后，异步写入到applyCh中。&lt;/p&gt;
&lt;p&gt;对于两个service层给raft层安装快照的函数，它们的区别是：&lt;code&gt;Snapshot&lt;/code&gt; 是由service层在处理apply message时判断raft state&amp;rsquo;s size是否达到阈值，主动调用。&lt;code&gt;CondInstallSnapshot&lt;/code&gt; 是service层在处理apply message中leader发来的更新的快照时调用，也需要再次判断是否 LastIncludedIndex &amp;lt;= rf.commitIndex，安装快照之后应该更新lastApplied、commitIndex。&lt;/p&gt;
&lt;p&gt;安装快照后需要压缩日志，但是需要记录下包含在快照中的最新的日志项的index和term，我将其记录在dummy entry（即rf.log[0]）中。此外被删除的日志项需要被正确的删除使其能够被gc。&lt;/p&gt;
&lt;h2 id=&#34;applier&#34;&gt;applier&lt;/h2&gt;
&lt;p&gt;根据论文，一旦commitIndex &amp;gt; lastApplied，则需要将[lastApplied+1, commitIndex]中的所有日志项apply到状态机并增加lastApplied。&lt;/p&gt;
&lt;p&gt;一开始我的实现是每次commitIndex更新，都异步起一个协程将[lastApplied+1, commitIndex]间日志写入applyCh。但是因为写channel时不能持有锁，所以这个过程只能是：&lt;/p&gt;
&lt;p&gt;加锁 -&amp;gt; 深拷贝日志项 -&amp;gt; 释放锁 -&amp;gt; 写channel -&amp;gt; 加锁 -&amp;gt; 更新lastApplied -&amp;gt; 释放锁&lt;/p&gt;
&lt;p&gt;日志在push完之前不会更新lastApplied，这样容易造成相同的日志项被重复apply，存在资源浪费。所以这里也可以参考之前replicator的实现思路，后台起一个applier协程，平时调用一个条件变量的 &lt;code&gt;Wait&lt;/code&gt; ，被 &lt;code&gt;Signal&lt;/code&gt; 唤醒时将[lastApplied+1, commitIndex]中的所有日志项apply到状态机，每次更新commitIndex时调用 &lt;code&gt;Signal&lt;/code&gt;。这样即能避免日志被重复apply，也完成了 apply 日志到状态机和 raft 提交新日志之间的解耦。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;applier&lt;/span&gt;(applyCh &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; ApplyMsg) {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Killed&lt;/span&gt;() {
		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;needToApply&lt;/span&gt;() {
			rf.applierCond.&lt;span style=&#34;color:#50fa7b&#34;&gt;Wait&lt;/span&gt;()
		}

		lastApplied, commitIndex &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rf.lastApplied, rf.commitIndex
		needToApply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DeepCopy&lt;/span&gt;(rf.logs[rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getSliceIndex&lt;/span&gt;(lastApplied&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;) : rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getSliceIndex&lt;/span&gt;(commitIndex)&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;])

		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, entry &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; needToApply {
			applyMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; ApplyMsg{
				CommandValid:  &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;,
				Command:       entry.Command,
				CommandIndex:  entry.Index,
				CommandTerm:   entry.Term,
				RaftStateSize: rf.persister.&lt;span style=&#34;color:#50fa7b&#34;&gt;RaftStateSize&lt;/span&gt;(),
			}

			applyCh &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; applyMsg
			&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] applied log [index %d] at term %d&amp;#34;&lt;/span&gt;, rf.me, entry.Index, entry.Term)
		}

		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; commitIndex &amp;gt; rf.lastApplied {
			rf.lastApplied = commitIndex
		}

		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意因为写channel时是不加锁的，而写channel是可能出现并发的，可能存在一种情况：applier在写入一批旧日志时，follower接受leader的 &lt;code&gt;InstallSnapshot&lt;/code&gt; 之后将新的snapshot写入channel。此时channel的写入顺序可能是：旧日志1 -&amp;gt; 新快照 -&amp;gt; 旧日志2。&lt;/p&gt;
&lt;p&gt;service层读channel是线性的，在读出snapshot并调用 &lt;code&gt;CondInstallSnapshot&lt;/code&gt; 后会更新raft层的lastApplied、commitIndex。因此在raft层apply完日志之后，重新获得锁去更新lastApplied时要注意不能回退，在这二者之间可能service层已经对更新的快照调用过 &lt;code&gt;CondInstallSnapshot&lt;/code&gt; 了（新快照的 lastIncludeIndex 一定大于 commitIndex ）。&lt;/p&gt;
&lt;h2 id=&#34;测试结果&#34;&gt;测试结果&lt;/h2&gt;
&lt;h3 id=&#34;2a&#34;&gt;2A&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;Test (2A): initial election ...
  ... Passed --   3.6  3   46   12142    0
Test (2A): election after network failure ...
  ... Passed --   5.6  3   94   19292    0
Test (2A): multiple elections ...
  ... Passed --   7.9  7  534  113432    0
PASS
ok  	6.824/raft	17.177s
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2b&#34;&gt;2B&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Test (2B): basic agreement ...
  ... Passed --   1.1  3   16    4326    3
Test (2B): RPC byte count ...
  ... Passed --   1.3  3   48  153910   11
Test (2B): agreement despite follower disconnection ...
  ... Passed --   4.3  3   75   19840    7
Test (2B): no agreement if too many followers disconnect ...
  ... Passed --   4.7  5  146   33983    4
Test (2B): concurrent Start()s ...
  ... Passed --   1.5  3   18    5054    6
Test (2B): rejoin of partitioned leader ...
  ... Passed --   5.1  3  117   27458    4
Test (2B): leader backs up quickly over incorrect follower logs ...
  ... Passed --   9.8  5 1023  627193  102
Test (2B): RPC counts aren&#39;t too high ...
  ... Passed --   3.0  3   42   12296   12
PASS
ok  	6.824/raft	30.976s
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2c&#34;&gt;2C&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Test (2C): basic persistence ...
  ... Passed --   6.0  3   91   21819    6
Test (2C): more persistence ...
  ... Passed --  18.3  5  821  178397   16
Test (2C): partitioned leader and one follower crash, leader restarts ...
  ... Passed --   2.7  3   35    8235    4
Test (2C): Figure 8 ...
  ... Passed --  27.9  5  530  117688   23
Test (2C): unreliable agreement ...
  ... Passed --   3.0  5  753  240518  246
Test (2C): Figure 8 (unreliable) ...
  ... Passed --  36.6  5 1684 3862021  145
Test (2C): churn ...
  ... Passed --  16.5  5 7937 3098958 1199
Test (2C): unreliable churn ...
  ... Passed --  16.3  5 1631 1031494  298
PASS
ok  	6.824/raft	127.309s
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2d&#34;&gt;2D&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Test (2D): snapshots basic ...
  ... Passed --   2.4  3  247   96514  251
Test (2D): install snapshots (disconnect) ...
  ... Passed --  46.7  3 1035  293753  399
Test (2D): install snapshots (disconnect+unreliable) ...
  ... Passed --  52.4  3 1153  310385  377
Test (2D): install snapshots (crash) ...
  ... Passed --  32.0  3  722  206681  322
Test (2D): install snapshots (unreliable+crash) ...
  ... Passed --  43.7  3  806  220815  388
PASS
ok  	6.824/raft	177.243s
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>mit-6.824 lab1: MapReduce</title>
        <link>https://ziannchen.work/2022/mit-6.824-lab1-mapreduce/</link>
        <pubDate>Thu, 03 Feb 2022 15:01:24 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/mit-6.824-lab1-mapreduce/</guid>
        <description>&lt;h1 id=&#34;lab1-mapreduce&#34;&gt;Lab1: MapReduce&lt;/h1&gt;
&lt;p&gt;在本次lab中我们的任务是实现一个分布式的MapReduce，它由两个程序组成，Coordinator和Worker。只有一个Coordinator，一个或多个Worker并行执行。&lt;/p&gt;
&lt;p&gt;每个Worker将通过RPC与Coordinator通信以请求一个Map或Reduce任务，之后从一个或多个文件中读取任务的输入，执行任务，并将任务的输出写入一个或多个文件。&lt;/p&gt;
&lt;p&gt;Coordinator应注意到Worker是否在合理的时间内（10s）完成了任务，如果没有则将相同的任务交给另一个Worker。&lt;/p&gt;
&lt;h2 id=&#34;coordinator&#34;&gt;Coordinator&lt;/h2&gt;
&lt;p&gt;写这个lab的时候刚学go语言不久，觉得channel这个东西很帅，就使用了很多channel实现了一个lock-free版本的Coordinator，实践了一下csp。&lt;/p&gt;
&lt;h3 id=&#34;核心结构体&#34;&gt;核心结构体&lt;/h3&gt;
&lt;p&gt;Coordinator维护每一个Map和Reduce任务的状态，这样就不用维护每一个worker的状态，这也利于worker的弹性伸缩。&lt;/p&gt;
&lt;p&gt;xxxidCh用于在获取任务编号并发放给worker，xxxDoneCh和xxxUndoneCh用于获取完成或未完成的任务编号修改任务状态。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Coordinator &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	files          []&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;
	nMap           &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	nReduce        &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	mapidCh        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	reduceidCh     &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	mapStatus      []Task
	reduceStatus   []Task

	heartbeatCh    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; heartbeatMsg
	reportCh       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; reportMsg
	stateCh        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; getStateMsg

	mapDoneCh      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; Execution
	reduceDoneCh   &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; Execution
	mapUndoneCh    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; Execution
	reduceUndoneCh &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; Execution
	
	mapComplete    &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;
	reduceComplete &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;
	mapRemain      &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	reduceRemain   &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每个任务的状态有3种，每个任务被初始化时都是UnStarted，被分配给Worker之后转换为Processing，收到Report完成转为Done，未完成转为UnStarted。&lt;/p&gt;
&lt;p&gt;结构体Task用term和任务状态共同表示一个任务的信息，term代表该任务被分配给worker执行的次数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; TaskStatus &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;const&lt;/span&gt; (
	UnStarted TaskStatus = &lt;span style=&#34;color:#ff79c6&#34;&gt;iota&lt;/span&gt;
	Processing
	Done
)

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Task &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	term &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	TaskStatus
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;rpc-handler&#34;&gt;RPC-handler&lt;/h3&gt;
&lt;p&gt;Coordinator接收到RPC之后，包装出一个xxxMsg结构，传入RPC对应的channel中。&lt;/p&gt;
&lt;p&gt;Done在这里作用类似于一个回调。Coordinator在启动时会在后台启动一个goroutine，不断监控 heartbeatCh 和 reportCh 中的Msg并处理，处理完成后执行msg.Done &amp;lt;- struct{}{}。在RPC handler中只需要等待Done这个channel返回。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; heartbeatMsg &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	response &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;HeartbeatResponse
	Done       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt;{}
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; reportMsg &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	request &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ReportRequest
	Done      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt;{}
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (c &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Coordinator) &lt;span style=&#34;color:#50fa7b&#34;&gt;Heartbeat&lt;/span&gt;(request &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;HeartbeatRequest, response &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;HeartbeatResponse) &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt; {
	log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Coordinator] receive a request from worker&amp;#34;&lt;/span&gt;)
	msg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; heartbeatMsg{
		response: response,
		Done:       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt;{}),
	}
	c.heartbeatCh &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; msg
	&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;msg.Done

	log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Coordinator] run heartbeat [%s] for worker&amp;#34;&lt;/span&gt;, response)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (c &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Coordinator) &lt;span style=&#34;color:#50fa7b&#34;&gt;Report&lt;/span&gt;(request &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ReportRequest, response &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ReportResponse) &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt; {
	log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Coordinator] receive worker&amp;#39;s report [%s]&amp;#34;&lt;/span&gt;, request)
	msg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; reportMsg{
		request: request,
		Done:      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt;{}),
	}

	c.reportCh &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; msg
	&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;msg.Done

	log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Coordinator] finish dealing with the report from worker&amp;#34;&lt;/span&gt;)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;handleHeartbeatMsg&lt;/code&gt;函数中处理心跳，根据当前Map和Reduce任务的状态给Worker分配一个任务、让worker等待或是告知所有任务已经完成。任务的id从mapidCh或reduceidCh两个channel中读出，在response中还要加上任务的term，每次分配该任务前需要对term自增以在不同的执行者之间区分。&lt;/p&gt;
&lt;p&gt;那么任务的id是什么时候写入channel中的呢？Coordinator在初始化时先将所有Map任务的id写入mapidCh，在所有Map任务都完成后将所有Reduce任务的id写入reduceidCh。&lt;/p&gt;
&lt;p&gt;需要注意一点，每个任务在分配之后10s内如果没有收到Report，则应该默认任务失败。这需要另起一个goroutine来判断，直接sleep 10s之后将id写入Undone channel即可，让run函数去判断。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;handleReportMsg&lt;/code&gt;函数中处理worker的返回任务结果，根据结构类型将任务的Execution写入对应的Done/Undone channel。我将任务的term和id包装成一个Execution结构表示任务的一次执行，使得某次任务失败是超时还是worker返回失败这两种情况可以被区分。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Execution &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	term &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	id   &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;核心逻辑&#34;&gt;核心逻辑&lt;/h3&gt;
&lt;p&gt;run函数是Coordinator的核心，它作为一个后台运行的goroutine在不断的循环中监听各个channel并执行对应的操作。由于所有的数据都在这一个goroutine中修改，避免了data-race。&lt;/p&gt;
&lt;p&gt;Coordinator真正处理worker上报的任务的完成情况是由run函数在select中同时监听这4个channel，再根据任务id来执行对应逻辑。因此&lt;code&gt;handleReportMsg&lt;/code&gt;函数可以另起一个goroutine来执行，这4个channel的容量也只需设置为1。&lt;/p&gt;
&lt;p&gt;从4个channel读出任务id后要注意，只有在对应的状态、Execution中term和本地任务的term一致时才能执行逻辑。&lt;/p&gt;
&lt;p&gt;例如某个MapFailed消息在10s之后到达，这可能是因为网络拥塞或是worker执行任务太慢，这个map任务已经被重新分配给了另一个worker，此时状态是仍是Processing。但这时term不一致应该放弃处理这个MapFailed消息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (c &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Coordinator) &lt;span style=&#34;color:#50fa7b&#34;&gt;run&lt;/span&gt;() &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; hbMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.heartbeatCh:
			c.&lt;span style=&#34;color:#50fa7b&#34;&gt;handleHeartbeatMsg&lt;/span&gt;(hbMsg)

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; rpMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.reportCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; c.&lt;span style=&#34;color:#50fa7b&#34;&gt;handleReportMsg&lt;/span&gt;(rpMsg)

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; e &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.mapDoneCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; c.mapStatus[e.id].TaskStatus &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Processing &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c.mapStatus[e.id].term &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; e.term {
				···
			}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; e &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.reduceDoneCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; c.reduceStatus[e.id].TaskStatus &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Processing &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c.reduceStatus[e.id].term &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; e.term {
				···
			}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; e &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.mapUndoneCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; c.mapStatus[e.id].TaskStatus &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Processing &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c.mapStatus[e.id].term &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; e.term {
				···
			}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; e &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.reduceUndoneCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; c.reduceStatus[e.id].TaskStatus &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Processing &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c.reduceStatus[e.id].term &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; e.term {
				···
			}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; stMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.stateCh:
			stMsg.state &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; c.reduceComplete

		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;worker&#34;&gt;Worker&lt;/h2&gt;
&lt;p&gt;worker的实现比较简单，只需要循环向coordinator请求任务执行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Worker&lt;/span&gt;(mapf &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) []KeyValue,
	reducef &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, []&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) {

	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your worker implementation here.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; {
		response &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;doHeartbeat&lt;/span&gt;()
		log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Worker] receive coordinator&amp;#39;s heartbeat [%s]&amp;#34;&lt;/span&gt;, response)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;switch&lt;/span&gt; response.Type {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; Map:
			&lt;span style=&#34;color:#50fa7b&#34;&gt;doMapTask&lt;/span&gt;(mapf, response.Id, response.Term, response.NReduce, response.Name)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; Reduce:
			&lt;span style=&#34;color:#50fa7b&#34;&gt;doReduceTask&lt;/span&gt;(reducef, response.Id,response.Term, response.NMap)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; Wait:
			time.&lt;span style=&#34;color:#50fa7b&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Second)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; Completed:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;default&lt;/span&gt;:
			&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;panic&lt;/span&gt;(fmt.&lt;span style=&#34;color:#50fa7b&#34;&gt;Sprintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Worker] unexpected jobType %v&amp;#34;&lt;/span&gt;, response.Type))
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行Map任务时，只需将mapf函数产生的中间文件kv pair按照ihash(kv.Key)%nReduce的余数写入不同的文件等待Reduce即可。写入的文件要先调用ioutil.TempFile(&amp;quot;&amp;quot;, &amp;ldquo;temp&amp;rdquo;)生成再调用os.Rename()改为mr-i-j。&lt;/p&gt;
&lt;p&gt;执行Reduce任务时，先建立一个kv数组，再将所有中间文件中的kv pair append到数组中再排序，将相同key对应的所有value append到一个string数组中，喂给reducef函数执行。看起来非常暴力，在工业界应该不可行，但通过本次lab的测试足够了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>mit-6.824 lab0: Preface</title>
        <link>https://ziannchen.work/2022/mit-6.824-lab0-preface/</link>
        <pubDate>Thu, 03 Feb 2022 14:01:24 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/mit-6.824-lab0-preface/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;21年的3月份，大三下学期，我收到了一份暑期实习的offer。需要提前学习一下go语言，之后在某学长的安利下我了解到了mit-6.824这门课程，他建议我做一下这门课的4个lab就当实践一下go。不过我配好环境后就去浪了2333，也就断断续续的在b站上看了几期课的视频。&lt;/p&gt;
&lt;p&gt;真正开始写lab还是暑假实习在公司摸鱼的时候开始的，当时还拉着旁边组的一个实习生一起写相互交流进度。不得不说，课程、论文和lab真的都是非常非常的硬核（虽然我论文只大概看了前几篇），分布式系统这个领域也真的是非常非常的有趣，比学校里学的东西不知道高到哪里去了。暑假结束时还只写完了lab2，lab3只写了一点点，之后由于搞完秋招后一直在玩，年底又去写PingCAP talent-plan的tinykv了（这个也挺有意思的，也更贴近工业界，可惜文档给的太少，与之相比6.824的实现就像个玩具）导致进度很慢，最终22年1月中旬才全部写完。&lt;/p&gt;
&lt;p&gt;最近（毕业之前）我应该会将整理完所有的文档、实现思路发出来，也锻炼一下自己写技术文章的水平。&lt;/p&gt;
&lt;h2 id=&#34;一些资料&#34;&gt;一些资料&lt;/h2&gt;
&lt;h3 id=&#34;我的实验配置&#34;&gt;我的实验配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;win10 + wsl2 + ubuntu 20.04&lt;/li&gt;
&lt;li&gt;16G内存&lt;/li&gt;
&lt;li&gt;go version 1.15&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;课程网站&#34;&gt;课程网站&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://nil.csail.mit.edu/6.824/2021/schedule.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;6.824 Schedule: Spring 2021&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;用于并发测试的脚本&#34;&gt;用于并发测试的脚本&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&lt;/span&gt;rm -rf tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;
mkdir tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;start_time&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;$(&lt;/span&gt;date + %s&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;[&lt;/span&gt; -e /tmp/fd1 &lt;span style=&#34;color:#ff79c6&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; mkfifo /tmp/fd1
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;exec&lt;/span&gt; 3&amp;lt;&amp;gt;/tmp/fd1
rm -rf /tmp/fd1
&lt;span style=&#34;color:#6272a4&#34;&gt;# 同时执行 10 个线程，依照cpu核心数视情况而定&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 1; i &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 10; i++&lt;span style=&#34;color:#ff79c6&#34;&gt;))&lt;/span&gt;; &lt;span style=&#34;color:#ff79c6&#34;&gt;do&lt;/span&gt;
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;echo&lt;/span&gt; &amp;gt;&amp;amp;&lt;span style=&#34;color:#bd93f9&#34;&gt;3&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;done&lt;/span&gt;

&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 1; i &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 500; i++&lt;span style=&#34;color:#ff79c6&#34;&gt;))&lt;/span&gt;; &lt;span style=&#34;color:#ff79c6&#34;&gt;do&lt;/span&gt;
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;read&lt;/span&gt; -u3
  &lt;span style=&#34;color:#ff79c6&#34;&gt;{&lt;/span&gt;
	touch ./tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;/report_&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$i&lt;/span&gt;.log
    go &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;test&lt;/span&gt; -run &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt; -race &amp;gt; ./tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;/report_&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$i&lt;/span&gt;.log
	&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;$(&lt;/span&gt;tail -n &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt; ./tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;/report_&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$i&lt;/span&gt;.log&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;s&lt;/span&gt;:&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;ok&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;]&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;then&lt;/span&gt;
		rm ./tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;/report_&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$i&lt;/span&gt;.log
	&lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt;
		&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;test &lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$i&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt; Failed&amp;#34;&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;fi&lt;/span&gt;

    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;echo&lt;/span&gt; &amp;gt;&amp;amp;&lt;span style=&#34;color:#bd93f9&#34;&gt;3&lt;/span&gt;
  &lt;span style=&#34;color:#ff79c6&#34;&gt;}&lt;/span&gt; &amp;amp;
&lt;span style=&#34;color:#ff79c6&#34;&gt;done&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;wait&lt;/span&gt;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;stop_time&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;$(&lt;/span&gt;date +%s&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;TIME:&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;$(&lt;/span&gt;expr &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$stop_time&lt;/span&gt; - &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$start_time&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;exec&lt;/span&gt; 3&amp;lt;&amp;amp;-
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;exec&lt;/span&gt; 3&amp;gt;&amp;amp;-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Hugo&amp;Stack &#43; Github Pages &#43; Github Actions 建站记录</title>
        <link>https://ziannchen.work/2022/hugostack-github-pages-github-actions-%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/</link>
        <pubDate>Mon, 31 Jan 2022 14:38:17 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/hugostack-github-pages-github-actions-%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/</guid>
        <description>&lt;h2 id=&#34;开端&#34;&gt;开端&lt;/h2&gt;
&lt;p&gt;一个程序员怎么能没有一个属于自己的技术博客呢？念叨这句话很久了，22年的春节我终于新建了文件夹。&lt;/p&gt;
&lt;h2 id=&#34;技术栈选型&#34;&gt;技术栈选型&lt;/h2&gt;
&lt;p&gt;框架 &lt;code&gt;Hugo&lt;/code&gt; ，主题 &lt;code&gt;Stack&lt;/code&gt; ，托管于 &lt;code&gt;GitHub Pages&lt;/code&gt;，域名备案于阿里云。此外使用了 &lt;code&gt;Github Actions&lt;/code&gt; 进行自动化部署。&lt;/p&gt;
&lt;h2 id=&#34;框架&#34;&gt;框架&lt;/h2&gt;
&lt;p&gt;一开始只知道博客可以托管在GitHub Pages上，作为完全不懂前端的我，肯定要选个简单的博客框架，上网查了下主要有Hexo和Hugo。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hexo？要用 nodejs，先pass。&lt;/li&gt;
&lt;li&gt;Hugo？是 go 语言开发的，这我熟，就它了！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt; 是由 Go 语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。&lt;code&gt;Hugo&lt;/code&gt; 的速度真的非常快，本地运行后，更新一保存之后马上在浏览器之后就能看到结果。此外还要选个主题，我用的是 &lt;code&gt;Stack&lt;/code&gt;。具体看 &lt;a class=&#34;link&#34; href=&#34;https://www.gohugo.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hugo 官方文档&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://docs.stack.jimmycai.com/zh/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Stack 官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;折腾博客的各种小细节时，基本都在参考这位博主的 &lt;a class=&#34;link&#34; href=&#34;https://mantyke.icu/2022/stack-theme-furnish03/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;装修记录&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;需要注意一点，&lt;code&gt;Hugo&lt;/code&gt; 框架的文件结构和 themes 中主题的文件结构是相同的，在修改样式时需要将主题文件夹中的同名文件复制到外边再做修改。若在主题文件夹中修改，由于自动化部署时是在 GitHub Actions 提供的 runner 上每次重新获取 hugo 和 theme 来生成静态网站，本地的更改就没了。&lt;/p&gt;
&lt;p&gt;写博客时，只需先执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;hugo new post/xxx.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后修改顶部的 FrontMatter&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;---
&lt;span style=&#34;color:#ff79c6&#34;&gt;title&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;my title&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;description&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;my description&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;date&lt;/span&gt;: 2022-02-03T15:01:24&lt;span style=&#34;color:#bd93f9&#34;&gt;+08&lt;/span&gt;:&lt;span style=&#34;color:#bd93f9&#34;&gt;00&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;draft&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;tags&lt;/span&gt;:
    - tag1
&lt;span style=&#34;color:#ff79c6&#34;&gt;categories&lt;/span&gt;:
    - categorie1
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再之后就可以开始创作了。&lt;/p&gt;
&lt;h2 id=&#34;后端&#34;&gt;后端&lt;/h2&gt;
&lt;p&gt;将博客托管在Github Pages上，具体看 &lt;a class=&#34;link&#34; href=&#34;https://pages.github.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官网&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;新建一个public Repository，名字要是 &lt;code&gt;username.github.io&lt;/code&gt;。之后在hugo框架根目录下执行 &lt;code&gt;hugo -D&lt;/code&gt; 在 public 文件夹中生成静态网站，再将 public 文件夹中内容 push 到该 Repository 中即可完成部署。&lt;/p&gt;
&lt;h2 id=&#34;自动化部署&#34;&gt;自动化部署&lt;/h2&gt;
&lt;p&gt;每次部署很麻烦，需要以下步骤：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;hugo -D
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;cd&lt;/span&gt; public
git add .
git commit -m &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;some messages&amp;#34;&lt;/span&gt;
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而且这样想要用git管理源文件有一点麻烦，自然想到使用 GitHub Actions 来完成自动化部署。&lt;/p&gt;
&lt;p&gt;需要先新建一个 Repository 保存博客框架源文件，我取名为 &lt;code&gt;my-hugo-stack&lt;/code&gt;。&lt;code&gt;username.github.io&lt;/code&gt; 这个Repository保存的是静态网站文件，不要混淆。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;my-hugo-stack&lt;/code&gt; 的 &lt;code&gt;Actions&lt;/code&gt; 中，新建一个 &lt;code&gt;workflow&lt;/code&gt; ，点击 configure 写入以下内容&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: ci
&lt;span style=&#34;color:#ff79c6&#34;&gt;on&lt;/span&gt;:
  &lt;span style=&#34;color:#ff79c6&#34;&gt;push&lt;/span&gt;: 
    &lt;span style=&#34;color:#ff79c6&#34;&gt;branches&lt;/span&gt;: 
      - master
      
&lt;span style=&#34;color:#ff79c6&#34;&gt;jobs&lt;/span&gt;:
  &lt;span style=&#34;color:#ff79c6&#34;&gt;build&lt;/span&gt;:
    &lt;span style=&#34;color:#ff79c6&#34;&gt;runs-on&lt;/span&gt;: ubuntu-latest 
    &lt;span style=&#34;color:#ff79c6&#34;&gt;steps&lt;/span&gt;:
      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: checkout 
        &lt;span style=&#34;color:#ff79c6&#34;&gt;uses&lt;/span&gt;: actions/checkout@v2.3.4
        &lt;span style=&#34;color:#ff79c6&#34;&gt;with&lt;/span&gt;:
          &lt;span style=&#34;color:#ff79c6&#34;&gt;submodules&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
          
      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: Setup Hugo
        &lt;span style=&#34;color:#ff79c6&#34;&gt;uses&lt;/span&gt;: peaceiris/actions-hugo@v2
        &lt;span style=&#34;color:#ff79c6&#34;&gt;with&lt;/span&gt;:
          &lt;span style=&#34;color:#ff79c6&#34;&gt;hugo-version&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;0.92.1&amp;#39;&lt;/span&gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;extended&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
          
      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: Build
        &lt;span style=&#34;color:#ff79c6&#34;&gt;run&lt;/span&gt;: hugo -D

      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: Add CNAME
        &lt;span style=&#34;color:#ff79c6&#34;&gt;run&lt;/span&gt;: echo &amp;#34;ziannchen.work&amp;#34; &amp;gt; public/CNAME
        
      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: Deploy
        &lt;span style=&#34;color:#ff79c6&#34;&gt;uses&lt;/span&gt;: peaceiris/actions-gh-pages@v3
        &lt;span style=&#34;color:#ff79c6&#34;&gt;with&lt;/span&gt;:
          &lt;span style=&#34;color:#ff79c6&#34;&gt;deploy_key&lt;/span&gt;: ${{ secrets.ACTIONS_DEPLOY_KEY }} 
          &lt;span style=&#34;color:#ff79c6&#34;&gt;external_repository&lt;/span&gt;: cza2000/cza2000.github.io  
          &lt;span style=&#34;color:#ff79c6&#34;&gt;publish_branch&lt;/span&gt;: master  
          &lt;span style=&#34;color:#ff79c6&#34;&gt;publish_dir&lt;/span&gt;: ./public 
          &lt;span style=&#34;color:#ff79c6&#34;&gt;commit_message&lt;/span&gt;: ${{ github.event.head_commit.message }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此外还需要新建一对SSH密钥。私钥写入博客源文件仓库的 &lt;code&gt;Settings&lt;/code&gt; - &lt;code&gt;Actions secrets&lt;/code&gt;，命名为 &lt;code&gt;ACTIONS_DEPLOY_KEY&lt;/code&gt;，公钥写入静态网站仓库的 &lt;code&gt;Settings&lt;/code&gt; - &lt;code&gt;Deploy keys&lt;/code&gt;，命名随意。&lt;/p&gt;
&lt;p&gt;之后将本地博客源文件 push 至 &lt;code&gt;my-hugo-stack&lt;/code&gt; 的 master 分支就会触发 action，自动部署并将生成的 public 文件夹内的内容 push 到 &lt;code&gt;username.github.io&lt;/code&gt; 中完成部署。&lt;/p&gt;
&lt;p&gt;由于我买了域名，这样做每次都把我的 CNAME 搞没了，我就在 yml 文件中手动加了一个 step，每次重新生成 CNAME 文件。&lt;/p&gt;
&lt;p&gt;为了更懒一点，又写了个脚本 deploy.sh:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;#!/bin/sh
&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&lt;/span&gt;git add .
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;msg&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;rebuilding site &lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;$(&lt;/span&gt;date&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;[&lt;/span&gt; -n &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$*&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;]&lt;/span&gt;; &lt;span style=&#34;color:#ff79c6&#34;&gt;then&lt;/span&gt;
	&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;msg&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$*&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;fi&lt;/span&gt;
git commit -m &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$msg&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#6272a4&#34;&gt;# Push source and build repos.&lt;/span&gt;
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 考虑弄个 CDN&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 加了个访问量统计
&lt;a class=&#34;link&#34; href=&#34;http://ibruce.info/2015/04/04/busuanzi/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;不蒜子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
