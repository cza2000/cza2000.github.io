<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>陈子桉的博客</title>
        <link>https://ziannchen.work/</link>
        <description>Recent content on 陈子桉的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <lastBuildDate>Fri, 04 Feb 2022 13:21:03 +0800</lastBuildDate><atom:link href="https://ziannchen.work/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>mit-6.824 lab4: ShardKV</title>
        <link>https://ziannchen.work/2022/mit-6.824-lab4-shardkv/</link>
        <pubDate>Fri, 04 Feb 2022 13:21:03 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/mit-6.824-lab4-shardkv/</guid>
        <description>&lt;p&gt;lab课程网址 &lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/labs/lab-shard.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pdos.csail.mit.edu/6.824/labs/lab-shard.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本次lab是最难的一次lab，很多地方需要我们自由发挥，不像lab2那样可以参考论文。&lt;/p&gt;
&lt;p&gt;Lab2和Lab3构成基础分布式数据库的框架，实现了多节点间的数据一致性，支持crud，数据同步和快照保存。然而，由于所有的请求都需要由 leader 来处理，当数据增长到一定程度时，若仍然使用单一集群服务所有数据，leader面对的压力会非常大，请求响应时间也会延长，磁盘空间也会不足。在这种模式下，增加机器并不会带来性能的提升，反而存在浪费。一个非常直接的解决方法，就是将数据按照某种方式分开存储到不同的集群上，将不同的请求引流到不同的集群，降低单一集群的压力，提供更为高效、更为健壮的服务。&lt;/p&gt;
&lt;p&gt;Lab4就是要实现数据的划分，将不同的数据划分到不同的集群上，保证相应数据请求引流到对应的集群。这里，将互不相交并且组成完整数据的每一个数据子集称为 Shard。在同一阶段中，Shard 与集群的对应关系称为 Config，随着时间的推移，增加或减少机器、某个 Shard 中的数据请求过热，Shard 需要在不同集群之中进行迁移。如何在 Config更新、 Shard 迁移的同时仍能正确对外提供强一致性的服务，是lab4主要挑战。&lt;/p&gt;
&lt;p&gt;一个集群只有Leader才能服务，系统的性能与集群的数量成正比。lab3是一个集群，lab4要实现的是多个集群之间的配合。&lt;/p&gt;
&lt;p&gt;我画了一个 ShardKV 最终的结构图&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://ziannchen.work/img/ShardKV/1.png&#34; &gt;
		&lt;img src=&#34;https://ziannchen.work/img/ShardKV/1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;图片 1&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;图片 1&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;shardctrler&#34;&gt;ShardCtrler&lt;/h2&gt;
&lt;p&gt;Client 在向 Server 发送RPC之前，需要先知道目标 key 所在的 Shard 位于哪一个 Group，以及如何和这个 Group 中的leader通信。这就需要有一个地方保存 shard -&amp;gt; gid 和 gid -&amp;gt; server 信息，这就是lab4A中需要实现的 ShardCtrler，它使用 Config 结构保存这些信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// A configuration -- an assignment of shards to groups.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// Please don&amp;#39;t change this.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Config &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Num    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;              &lt;span style=&#34;color:#6272a4&#34;&gt;// config number
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Shards [NShards]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;     &lt;span style=&#34;color:#6272a4&#34;&gt;// shard -&amp;gt; gid
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Groups &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;][]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// gid -&amp;gt; servers[]
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每次 shard -&amp;gt; gid 的对应关系被更改时，ShardCtrler 创建一个新的 Config 保存新的对应关系。ShardCtrler 支持Join、Leave、Move、Query 4种RPC来添加新的 Group、删除 Group，在 Group 之间移动 Shard 以及查询对应 Num 的 Config，底层也使用Raft协议在多台机器上进行数据同步。因此整体实现和lab3类似。&lt;/p&gt;
&lt;h3 id=&#34;client&#34;&gt;Client&lt;/h3&gt;
&lt;p&gt;为了简化逻辑4种请求共用一个RPC，也需要加上 ClientID 和 RequestID 让 server 端能够去重。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; CommandRequest &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	ClientID  &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	RequestID &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	OpType
	JoinArgs
	LeaveArgs
	MoveArgs
	QueryArgs
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; CommandResponse &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Err         Err
	Config      Config
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; JoinArgs &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Servers   &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;][]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// new GID -&amp;gt; servers mappings
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; LeaveArgs &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	GIDs      []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; MoveArgs &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Shard     &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	GID       &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; QueryArgs &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Num       &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// desired config number
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;server&#34;&gt;Server&lt;/h3&gt;
&lt;p&gt;对于RPC的处理模型和lab3是一样的，由于Config数据较小，还不用处理快照。&lt;/p&gt;
&lt;h4 id=&#34;join&#34;&gt;Join&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Join&lt;/code&gt; 操作向当前配置中新增一些server，这些server可能被加入现有的 Group 中，也可能是新增的 Group。&lt;/p&gt;
&lt;p&gt;新增的 Group 还没有 Shard，需要在 &lt;code&gt;Groups&lt;/code&gt; 中对 &lt;code&gt;Shards&lt;/code&gt; 进行平衡并且要产生尽可能少的 Shard 迁移，平衡的方法是每次循环让拥有 Shard 最多的 Group 分一个给拥有 Shard 最少的 Group，直到它们之间的差值小等于1。&lt;/p&gt;
&lt;p&gt;ShardCtrler 刚启动时还没有 Config 信息，第一次执行 &lt;code&gt;Join&lt;/code&gt; 时所有的 Shard 还未被分配到具体的 Group 上，对应的 gid 是0，我称为 &lt;code&gt;zombieShard&lt;/code&gt;。因此在处理 &lt;code&gt;Join&lt;/code&gt; 时也要分配可能存在的 &lt;code&gt;zombieShard&lt;/code&gt;。此外maps数据需要深拷贝。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (sc &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardCtrler) &lt;span style=&#34;color:#50fa7b&#34;&gt;executeJoin&lt;/span&gt;(servers &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;][]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) {
	length &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(sc.configs)
	lastConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; sc.configs[length&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;]

	newGroups &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;deepCopy&lt;/span&gt;(lastConfig.Groups)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; gid, servers &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; servers {
		newGroups[gid] = servers
	}
	newConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Config{
		Num:    length,
		Shards: [NShards]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;{},
		Groups: newGroups,
	}

	groupToShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;getGroupToShards&lt;/span&gt;(newGroups, lastConfig.Shards)
	zombieShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;{}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; shard, gid &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; lastConfig.Shards {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; gid &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt; {
			zombieShards = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(zombieShards, shard)
		}
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; zombieShards {
		target &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;getMinGroup&lt;/span&gt;(groupToShards)
		groupToShards[target] = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(groupToShards[target], shard)
	}

	groupToShards = &lt;span style=&#34;color:#50fa7b&#34;&gt;balanceShardBetweenGroups&lt;/span&gt;(groupToShards)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; gid, shards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; groupToShards {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; shards {
			newConfig.Shards[shard] = gid
		}
	}

	sc.configs = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(sc.configs, newConfig)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;leave&#34;&gt;Leave&lt;/h4&gt;
&lt;p&gt;Group 被删除后，其原先拥有的 Shard 就成了 &lt;code&gt;zombieShard&lt;/code&gt;，应当依次分配被拥有 Shard 数量最少的 Group。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (sc &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardCtrler) &lt;span style=&#34;color:#50fa7b&#34;&gt;executeLeave&lt;/span&gt;(GIDs []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
	length &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(sc.configs)
	lastConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; sc.configs[length&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;]
	newGroups &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;deepCopy&lt;/span&gt;(lastConfig.Groups)

	newConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Config{
		Num:    length,
		Shards: [NShards]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;{},
		Groups: newGroups,
	}

	groupToShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;getGroupToShards&lt;/span&gt;(newGroups, lastConfig.Shards)
	zombieShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;{}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, gid &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; GIDs {
		&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;delete&lt;/span&gt;(newConfig.Groups, gid)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; shards, ok &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; groupToShards[gid]; ok {
			zombieShards = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(zombieShards, shards&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)
			&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;delete&lt;/span&gt;(groupToShards, gid)
		}
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; zombieShards {
		target &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;getMinGroup&lt;/span&gt;(groupToShards)
		groupToShards[target] = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(groupToShards[target], shard)
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; gid, shards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; groupToShards {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; shards {
			newConfig.Shards[shard] = gid
		}
	}

	sc.configs = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(sc.configs, newConfig)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;move&#34;&gt;Move&lt;/h4&gt;
&lt;p&gt;将指定的 Shard 交由新的 Group 负责，只需要改动 &lt;code&gt;Shards&lt;/code&gt; 数组。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (sc &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardCtrler) &lt;span style=&#34;color:#50fa7b&#34;&gt;executeMove&lt;/span&gt;(shard &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, gid &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
	length &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(sc.configs)
	lastConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; sc.configs[length&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;]
	newGroups &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;deepCopy&lt;/span&gt;(lastConfig.Groups)

	newConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Config{
		Num:    length,
		Shards: lastConfig.Shards,
		Groups: newGroups,
	}

	newConfig.Shards[shard] = gid
	sc.configs = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(sc.configs, newConfig)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;query&#34;&gt;Query&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Query&lt;/code&gt; 查询指定版本的 Config。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (sc &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardCtrler) &lt;span style=&#34;color:#50fa7b&#34;&gt;executeQuery&lt;/span&gt;(num &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) Config {
	length &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(sc.configs)
	config &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Config{}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; num &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; num &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;=&lt;/span&gt; length {
		config = sc.configs[length&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;]
	} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
		config = sc.configs[num]
	}

	newGroups &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;deepCopy&lt;/span&gt;(config.Groups)
	newConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; Config{
		Num:    config.Num,
		Shards: config.Shards,
		Groups: newGroups,
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; newConfig
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;测试结果&#34;&gt;测试结果&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;Test: Basic leave/join ...
  ... Passed
Test: Historical queries ...
  ... Passed
Test: Move ...
  ... Passed
Test: Concurrent leave/join ...
  ... Passed
Test: Minimal transfers after joins ...
  ... Passed
Test: Minimal transfers after leaves ...
  ... Passed
Test: Multi-group join/leave ...
  ... Passed
Test: Concurrent multi leave/join ...
  ... Passed
Test: Minimal transfers after multijoins ...
  ... Passed
Test: Minimal transfers after multileaves ...
  ... Passed
Test: Check Same config on servers ...
  ... Passed
PASS
ok  	6.824/shardctrler	5.641s
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;shardkv&#34;&gt;ShardKV&lt;/h2&gt;
&lt;h3 id=&#34;整体结构&#34;&gt;整体结构&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ShardKV&lt;/code&gt; 的状态机 db 由多个 Shard 组成，每个 Shard 包含了自己的状态、kv和客户端请求去重表，这使得不同的 Shard 之间可以在独立迁移的同时不影响未受影响的 Shard 对外正常提供服务，也可以通过 Shard 的状态来进行许多判断，每个状态的含义在注释中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; ShardKV &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	mu           sync.RWMutex
	me           &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	rf           &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;raft.Raft
	applyCh      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; raft.ApplyMsg
	make_end     &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd
	gid          &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	ctrlers      []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd
	maxraftstate &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// snapshot if log grows this big
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your definitions here.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	prevConfig       shardctrler.Config
	currConfig       shardctrler.Config
	persister        &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;raft.Persister
	scClerk          &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;shardctrler.Clerk
	notifyChans      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; CommandResponse
	db               &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Shard
	lastAppliedIndex &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; ShardStatus &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;const&lt;/span&gt; (
	&lt;span style=&#34;color:#6272a4&#34;&gt;// The group serves and owns the shard.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Serving ShardStatus = &lt;span style=&#34;color:#ff79c6&#34;&gt;iota&lt;/span&gt;
	&lt;span style=&#34;color:#6272a4&#34;&gt;// The group serves the shard, but does not own the shard yet.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Pulling
	&lt;span style=&#34;color:#6272a4&#34;&gt;// The group does not serve and own the partition.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Invalid
	&lt;span style=&#34;color:#6272a4&#34;&gt;// The group owns but does not serve the shard.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Erasing
	&lt;span style=&#34;color:#6272a4&#34;&gt;// The group own the shard and serve it, but it&amp;#39;s waiting for ex-owner to delete it
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	Waiting
)

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Shard &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Status       ShardStatus
	KV           &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;
	LastSessions &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Session
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;leader需要执行多个定时任务，需要在后台启动协程来循环判断状态、执行任务、睡眠。我抽象出了一个 &lt;code&gt;daemon&lt;/code&gt; 函数来完成这些。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;StartServer&lt;/span&gt;(servers []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd, me &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, persister &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;raft.Persister, maxraftstate &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, gid &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, ctrlers []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd, make_end &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV {
	···
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your initialization code here.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Use something like this to talk to the shardctrler:
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#6272a4&#34;&gt;// kv.mck = shardctrler.MakeClerk(kv.ctrlers)
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	kv.applyCh = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; raft.ApplyMsg)
	kv.rf = raft.&lt;span style=&#34;color:#50fa7b&#34;&gt;Make&lt;/span&gt;(servers, me, persister, kv.applyCh)
	kv.scClerk = shardctrler.&lt;span style=&#34;color:#50fa7b&#34;&gt;MakeClerk&lt;/span&gt;(kv.ctrlers)
	kv.mu = sync.RWMutex{}
	kv.notifyChans = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; CommandResponse)
	kv.db = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Shard)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;; i &amp;lt; shardctrler.NShards; i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt; {
		kv.db[i] = &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;Shard{
			Status:       Invalid,
			KV:           &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;),
			LastSessions: &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Session),
		}
	}

	kv.lastAppliedIndex = &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;
	kv.prevConfig = shardctrler.Config{}
	kv.currConfig = shardctrler.Config{}
	kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applySnapshot&lt;/span&gt;(persister.&lt;span style=&#34;color:#50fa7b&#34;&gt;ReadSnapshot&lt;/span&gt;())

	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applier&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;daemon&lt;/span&gt;(kv.fetchConfig)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;daemon&lt;/span&gt;(kv.pullData)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;daemon&lt;/span&gt;(kv.eraseData)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;daemon&lt;/span&gt;(kv.proposeEmpty)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; kv
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;daemon&lt;/span&gt;(action &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;()) {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;killed&lt;/span&gt;() {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; _, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetState&lt;/span&gt;(); isLeader {
			&lt;span style=&#34;color:#50fa7b&#34;&gt;action&lt;/span&gt;()
		}

		time.&lt;span style=&#34;color:#50fa7b&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;50&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Millisecond)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;applier 的结构和lab3类似，日志被 commit 之后根据 CommandType 的不同执行不同的applyxxx，其中 &lt;code&gt;EraseData&lt;/code&gt; 和 &lt;code&gt;ClientRequest&lt;/code&gt; 需要返回 response。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; CommandType &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;const&lt;/span&gt; (
	ClientRequest CommandType = &lt;span style=&#34;color:#ff79c6&#34;&gt;iota&lt;/span&gt;
	ConfChange
	InsertData
	EraseData
	StopWaiting
	Empty
)

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; RaftLogCommand &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	CommandType
	Data &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{}
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(commandType CommandType, data &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;interface&lt;/span&gt;{}) RaftLogCommand {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; RaftLogCommand{
		CommandType: commandType,
		Data: data,
	}
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;applier&lt;/span&gt;() {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;killed&lt;/span&gt;() {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; applyMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;kv.applyCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; applyMsg.CommandValid {
				command &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; applyMsg.Command.(RaftLogCommand)
				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()

				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; applyMsg.CommandIndex &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;=&lt;/span&gt; kv.lastAppliedIndex {
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] discard out-of-date apply Msg [index %d]&amp;#34;&lt;/span&gt;, kv.gid, kv.me, applyMsg.CommandIndex)
					kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
					&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
				}

				kv.lastAppliedIndex = applyMsg.CommandIndex
				response &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;CommandResponse{}
				&lt;span style=&#34;color:#ff79c6&#34;&gt;switch&lt;/span&gt; command.CommandType {
				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; Empty:
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] get empty in apply Msg [index %d]&amp;#34;&lt;/span&gt;, kv.gid, kv.me, applyMsg.CommandIndex)
				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; ConfChange:
					lastestConf &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; command.Data.(shardctrler.Config)
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyConfChange&lt;/span&gt;(lastestConf, applyMsg.CommandIndex)

				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; InsertData:
					resp &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; command.Data.(PullDataResponse)
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyInsertData&lt;/span&gt;(resp, applyMsg.CommandIndex)

				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; StopWaiting:
					req &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; command.Data.(EraseDataRequest)
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyStopWaiting&lt;/span&gt;(req, applyMsg.CommandIndex)

				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; EraseData:
					req &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; command.Data.(EraseDataRequest)
					response = kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyEraseData&lt;/span&gt;(req, applyMsg.CommandIndex)
					&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; currentTerm, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetState&lt;/span&gt;(); currentTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; applyMsg.CommandTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isLeader {
						ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getNotifyChan&lt;/span&gt;(applyMsg.CommandIndex)
						ch &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;response
					}

				&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; ClientRequest:
					request &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; command.Data.(CommandRequest)
					response = kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyClientRequest&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;request, applyMsg.CommandIndex)
					&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; currentTerm, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetState&lt;/span&gt;(); currentTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; applyMsg.CommandTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isLeader {
						ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getNotifyChan&lt;/span&gt;(applyMsg.CommandIndex)
						ch &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;response
					}
				}

				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;needToSnapshot&lt;/span&gt;(applyMsg.RaftStateSize) {
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] take a snapshot till [index %d]&amp;#34;&lt;/span&gt;, kv.gid, kv.me, applyMsg.CommandIndex)
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;takeSnapshot&lt;/span&gt;(applyMsg.CommandIndex)
				}

				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
			} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
				&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] received a snapshot from raft layer [index %d]&amp;#34;&lt;/span&gt;, kv.gid, kv.me, applyMsg.SnapshotIndex)
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;CondInstallSnapshot&lt;/span&gt;(applyMsg.SnapshotTerm, applyMsg.SnapshotIndex, applyMsg.Snapshot) {
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applySnapshot&lt;/span&gt;(applyMsg.Snapshot)
					kv.lastAppliedIndex = applyMsg.SnapshotIndex
				}

				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;客户端请求&#34;&gt;客户端请求&lt;/h3&gt;
&lt;p&gt;这里和lab3基本一样，不同的是 handle RPC 以及日志apply时都需要额外判断在当前版本的 Config 下本 Group 是否负责该 key 所属的 Shard。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;isShardMatch&lt;/span&gt;(shardId &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; kv.currConfig.Shards[shardId] &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; kv.gid &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (kv.db[shardId].Status &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Serving &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; kv.db[shardId].Status &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Waiting)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;配置更新&#34;&gt;配置更新&lt;/h3&gt;
&lt;p&gt;每个 Group 中的 leader 需要在后台启动一个协程向 ShardCtrler 定时使用 &lt;code&gt;Query&lt;/code&gt; 拉取最新的 Config，一旦拉取到就需要提交一条 raft 日志，以在每台机器上更新配置。&lt;/p&gt;
&lt;p&gt;此外，每次只能拉取高一个版本的配置，而且为了防止集群的分片状态被覆盖，从而使得某些任务永远不会被执行，只有在每一 Shard 的状态都为 &lt;code&gt;Serving&lt;/code&gt; 或 &lt;code&gt;Invalid&lt;/code&gt; 时才能拉取、更新配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;fetchConfig&lt;/span&gt;() {
	canFetchConf &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	currConfNum &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.currConfig.Num
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; shardId, shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; kv.db {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; shard.Status &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; Serving &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; shard.Status &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; Invalid {
			canFetchConf = &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
			&lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;
		}
	}

	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; canFetchConf {
		latestConfig &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.scClerk.&lt;span style=&#34;color:#50fa7b&#34;&gt;Query&lt;/span&gt;(currConfNum &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; latestConfig.Num &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; currConfNum&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt; {
			kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(ConfChange, latestConfig))
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在每台机器上，新配置对应的 raft 日志被 commit 之后，都需要更新本地的 &lt;code&gt;prevConfig&lt;/code&gt; 和 &lt;code&gt;currConfig&lt;/code&gt;，以及更新 db 中对应的 Shard 状态，以便让数据拉取、数据清理协程能检测到去进行数据迁移。&lt;/p&gt;
&lt;p&gt;在新版本的 Config 中新增的 Shard 状态改为 Pulling，等待拉取数据协程去其他 Group 上拉数据。失去的 Shard 状态改为 Erasing，等待其他 Group 来拉取数据。若当前 Config 的版本为1，则代表集群刚初始化，不需要去其他 Group 拉取数据，只需更改对应的 Shard 状态为 Serving。&lt;/p&gt;
&lt;h3 id=&#34;数据拉取&#34;&gt;数据拉取&lt;/h3&gt;
&lt;p&gt;新的 Config 在 applier 协程中被应用并不表示所属分片可以立刻对外提供服务，还需要等待在上一个版本的 Config 中不属于自身的 Shard 从它之前所属的 Group 中迁移到本 Group。&lt;/p&gt;
&lt;p&gt;这里显然不能在配置更新时同步阻塞的去拉取 Shard，这会阻塞 applier 协程，严重影响对外服务的可用性。那么是否可以异步的去拉取数据并提交日志？其实不行，leader 可能会在 apply 新配置之后到新数据被异步拉取到并提交日志之前宕机，而 follower 虽然会 apply 配置但是不会去拉数据，这样这些数据将永远无法被更新。&lt;/p&gt;
&lt;p&gt;因此，我们不能在 apply 配置的时候启动异步任务，而是应该只更新 shard 的状态，由单独的后台协程去检测每个 Shard 的状态，从而判断是否需要并执行分片迁移，分片清理等任务。为了让单独的协程能知道该向哪个 Group 去拉取数据或让它去删除数据，&lt;code&gt;ShardKV&lt;/code&gt; 需要维护 currConfig 和 prevConfig，这样其他协程能够通过它们来得知所有 Shard 的 ex-owner。&lt;/p&gt;
&lt;p&gt;需要定义新的RPC来完成数据拉取。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; PullDataRequest &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	ConfNum  &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	ShardIds []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; PullDataResponse &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Err     Err
	ConfNum &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	Shards  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Shard
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并行向状态为 &lt;code&gt;Pulling&lt;/code&gt; 的不同 Shard 的 ex-owner 发送RPC来拉取数据，使用 waitGroup 来保证尝试拉取了一遍当前版本的配置所需要的所有 Shard 之后才能进行下一轮循环。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;pullData&lt;/span&gt;() {
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	groupToShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getGroupToShards&lt;/span&gt;(Pulling)
	currConfNum &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.currConfig.Num
	wg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; sync.WaitGroup{}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; gid, shards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; groupToShards {
		wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
		servers &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.prevConfig.Groups[gid]
		&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(servers []&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, shards []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, confNum &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Done&lt;/span&gt;()
			&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, server &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; servers {
				shardOwner &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;make_end&lt;/span&gt;(server)
				args &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; PullDataRequest{
					ConfNum:  confNum,
					ShardIds: shards,
				}

				reply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; PullDataResponse{}
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; shardOwner.&lt;span style=&#34;color:#50fa7b&#34;&gt;Call&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;ShardKV.PullData&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply) &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; reply.Err &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; OK {
					kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(InsertData, resp))
					&lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;
				}
			}
		}(servers, shards, currConfNum)
	}

	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()
	wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Wait&lt;/span&gt;()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据的被拉取方在处理 RPC 时，只有在 PullDataRequest 中的配置版本与自身的配置版本相同时，才回应其需要的 Shard 信息。需要注意正确的对所有 Shard 深拷贝。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;PullData&lt;/span&gt;(args &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;PullDataRequest, reply &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;PullDataResponse) {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] reply %s for PULL DATA request %s&amp;#34;&lt;/span&gt;, kv.gid, kv.me, reply, args)
	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] received a PULL DATA request %s&amp;#34;&lt;/span&gt;, kv.gid, kv.me, args)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; _, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetState&lt;/span&gt;(); !isLeader {
		reply.Err = ErrWrongLeader
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.currConfig.Num &amp;lt; args.ConfNum {
		reply.Err = ErrNotReady
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.currConfig.Num &amp;gt; args.ConfNum {
		&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;panic&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;duplicated pull data request&amp;#34;&lt;/span&gt;)
	}

	replyShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Shard)

	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, shardId &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; args.ShardIds {
		shard &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.db[shardId]
		replyShards[shardId] = &lt;span style=&#34;color:#50fa7b&#34;&gt;deepCopyShard&lt;/span&gt;(shard)
	}

	reply.ConfNum = kv.currConfig.Num
	reply.Shards = replyShards
	reply.Err = OK
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 applyInsertData 时，为了保证集群数据变更的幂等性，要保证 Config 的版本与当前版本相同时以及其 Shard 的本地状态为 &lt;code&gt;Pulling&lt;/code&gt; 时才能更新 Shard 的状态。将其状态改为 &lt;code&gt;Waiting&lt;/code&gt; 让数据清理协程去检测。&lt;/p&gt;
&lt;h3 id=&#34;数据清理&#34;&gt;数据清理&lt;/h3&gt;
&lt;h4 id=&#34;current-owner&#34;&gt;current owner&lt;/h4&gt;
&lt;p&gt;在完成数据拉取之后，需要清理掉每个新拉到的 Shard 对应的 ex-owner 机器上的旧数据。后台协程检查所有状态为 &lt;code&gt;Waiting&lt;/code&gt; 的 Shard，并行向它们的 ex-owners 分别发送 RPC，告知它们：我已拉取到我要的数据，现在你可以把它们（对应的 Shard 状态为 Erasing）删了。这里 waitGroup 的用法同上。&lt;/p&gt;
&lt;p&gt;RPC返回且得知 ex-owners 上的数据清理已经完成后需要提交一条 &lt;code&gt;StopWaiting&lt;/code&gt; 类型的 raft 日志，将这个信息同步到 Group 内所有机器上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; EraseDataRequest &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	ConfNum  &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	ShardIDs []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; EraseDataResponse &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	Err Err
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;eraseData&lt;/span&gt;() {
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	groupToShards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getGroupToShards&lt;/span&gt;(Waiting)
	currConfNum &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.currConfig.Num
	wg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; sync.WaitGroup{}
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; gid, shards &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; groupToShards {
		wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
		servers &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.prevConfig.Groups[gid]
		&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(servers []&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, shards []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, confNum &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Done&lt;/span&gt;()
			&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, server &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; servers {
				shardOwner &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;make_end&lt;/span&gt;(server)
				args &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; EraseDataRequest{
					ConfNum:  confNum,
					ShardIDs: shards,
				}

				reply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; EraseDataResponse{}
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; shardOwner.&lt;span style=&#34;color:#50fa7b&#34;&gt;Call&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;ShardKV.EraseData&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply) &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; reply.Err &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; OK {
					kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(StopWaiting, req))
					&lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;
				}
			}
		}(servers, shards, currConfNum)
	}

	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()
	wg.&lt;span style=&#34;color:#50fa7b&#34;&gt;Wait&lt;/span&gt;()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;StopWaiting&lt;/code&gt; 日志以及 Shard 的 &lt;code&gt;Waiting&lt;/code&gt; 状态存在的用途是标记我是否已经成功在 ex-owner 上删除过期的 Shard。applyStopWaiting 时，在 Config 版本相同时将对应的状态为 &lt;code&gt;Waiting&lt;/code&gt; 的 Shard 更新状态为 &lt;code&gt;Serving&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;ex-owner&#34;&gt;ex-owner&lt;/h4&gt;
&lt;p&gt;ex-owner 在 handle &lt;code&gt;EraseData&lt;/code&gt; 的RPC时，需要返回数据清理是否完成，这里的处理类似处理客户端请求，不需要进行去重。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;EraseData&lt;/span&gt;(req &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;EraseDataRequest, resp &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;EraseDataResponse) {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] resp %s for ERASE DATA request %s&amp;#34;&lt;/span&gt;, kv.gid, kv.me, resp, req)
	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Group %d][Server %d] received a ERASE DATA request %s&amp;#34;&lt;/span&gt;, kv.gid, kv.me, req)
	index, _, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(EraseData, &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;req))
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !isLeader {
		resp.Err = ErrWrongLeader
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
	ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getNotifyChan&lt;/span&gt;(index)
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; response &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;ch:
		resp.Err = response.Err

	&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;500&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Millisecond).C:
		resp.Err = ErrTimeout
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;() {
		kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
		kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;removeNotifyChan&lt;/span&gt;(index)
		kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
	}()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;apply 时，在版本号相同的情况下将对应的状态为 &lt;code&gt;Erasing&lt;/code&gt; 的 Shard 更新为 &lt;code&gt;Invalid&lt;/code&gt;，表明对应 Shard 已经成功被清除，清空 kv 和客户端请求去重表。不要忘了返回OK。&lt;/p&gt;
&lt;h3 id=&#34;提交空日志&#34;&gt;提交空日志&lt;/h3&gt;
&lt;p&gt;在某个涉及重启的测试中，有时候会出现集群对外出现活锁，无法再服务请求直到超时。我重新打了很多日志，发现这时各个 Group 间的 Config 版本不一致，且版本较低的 Group 的一些 Shard 状态不为 &lt;code&gt;Serving&lt;/code&gt; 和 &lt;code&gt;Invalid&lt;/code&gt;，这卡着配置更新协程无法拉取最新的 Config。按理说 Config 的版本只能以1为公差递增，其余的 Group 版本高说明也经历过较低的这个版本，应该有向这个 Group 发送过拉取数据和清理数据的RPC来更新 Shard 状态，那么为什么状态并没有被更新呢？&lt;/p&gt;
&lt;p&gt;仔细读了很久日志，我发现版本较低的 Group 在推进 Config 到这个版本之后已经正确处理过拉取数据或是清理数据的RPC也更新了 Shard 状态，但在重启后这最后处理的关键RPC对应的日志并没有重新被commit。原来，此时 leader 的 currentTerm 高于这个RPC对应的日志的 term，且这个时间节点客户端碰巧没有向该 Group 组执行读写请求，导致 leader 无法拥有当前任期的 term 的日志，无法将状态机更新到最新。&lt;/p&gt;
&lt;p&gt;lab4的最后一部分是我在写完 TinyKV 之后做的，我想到 TinyKV （其实 etcd 也是这么做的）中要求的 leader 在当选时要先提交一条空日志，这样可以保证集群的可用性，于是我也移植了这个特性到 6.824 中。&lt;/p&gt;
&lt;p&gt;想起了以前几个月前看过的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md#%E7%A9%BA%E6%97%A5%E5%BF%97%E6%A3%80%E6%B5%8B&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;谭新宇&lt;/a&gt; 的文章，我知道了不能把这个特性加到 raft 层。于是我也让 leader 在 kv 层周期性的去检测下层是否包含当前 term 的日志，如果没有便 append 一条空日志，这样即可保证新选出的 leader 状态机能够迅速达到最新。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ShardKV) &lt;span style=&#34;color:#50fa7b&#34;&gt;proposeEmpty&lt;/span&gt;() {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;HasLogAtCurrentTerm&lt;/span&gt;() {
		kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;newRaftLogCommand&lt;/span&gt;(Empty, &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;))
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;测试结果-1&#34;&gt;测试结果&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;Test: static shards ...
  ... Passed
Test: join then leave ...
  ... Passed
Test: snapshots, join, and leave ...
  ... Passed
Test: servers miss configuration changes...
  ... Passed
Test: concurrent puts and configuration changes...
  ... Passed
Test: more concurrent puts and configuration changes...
  ... Passed
Test: concurrent configuration change and restart...
  ... Passed
Test: unreliable 1...
  ... Passed
Test: unreliable 2...
  ... Passed
Test: unreliable 3...
  ... Passed
Test: shard deletion (challenge 1) ...
  ... Passed
Test: unaffected shard access (challenge 2) ...
  ... Passed
Test: partial migration shard access (challenge 2) ...
  ... Passed
PASS
ok  	6.824/shardkv	108.040s
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>mit-6.824 lab3: RaftKV</title>
        <link>https://ziannchen.work/2022/mit-6.824-lab3-raftkv/</link>
        <pubDate>Thu, 03 Feb 2022 15:06:21 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/mit-6.824-lab3-raftkv/</guid>
        <description>&lt;h1 id=&#34;lab3-kvraft&#34;&gt;Lab3: KVRaft&lt;/h1&gt;
&lt;p&gt;lab链接 &lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本次lab中我们需要使用lab2中实现的Raft库来构建一个可容错的 Key/Value 存储服务，要求其对外提供强一致性（&lt;code&gt;Strong consistency&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;这个KV存储服务支持Get/Put/Append三种客户端操作。客户端通过RPC与集群中的leader通信，leader接收到请求后将其包装在一条Raft日志中下放到Raft层进行共识，日志被apply后返回客户端结果。&lt;/p&gt;
&lt;h2 id=&#34;一些思考&#34;&gt;一些思考&lt;/h2&gt;
&lt;p&gt;在PartA的描述中提到，leader在将一个请求下放到raft层之后，commit之前宕机，这时它无法回复Clerk。又或者是，这条日志成功commit，但返回的RPC丢失。Clerk在规定时间内没有收到结果，会向另一台主机（可能是新选出的leader）发送RPC，这条日志最终被commit之后又会被应用于状态机，从而状态机执行了两次相同的请求。&lt;/p&gt;
&lt;p&gt;这要求我们能够判断重复的请求。因此每个请求都需要被唯一标识，请求中需要加上（ClientID, RequestID），Clerk每次请求成功之后自增RequestID。&lt;/p&gt;
&lt;p&gt;我们还需要在遇到重复的请求时直接返回第一次请求时的结果，这需要我们保存每一个Clerk的最后一次请求的结果ClientID -&amp;gt; (RequestID, LastResponse)。只需要保存最后一次请求结果是因为如果服务端收到RequestID = x的RPC，说明这个Clerk已经收到了RequestID为[1, x-1]之间内的所有请求的结果，服务端如果再次收到这个RequestID在区间之内的请求说明该RPC过期，直接丢弃即可。&lt;/p&gt;
&lt;h2 id=&#34;client&#34;&gt;client&lt;/h2&gt;
&lt;p&gt;我将3种请求共用了一个RPC，简化了逻辑。&lt;/p&gt;
&lt;p&gt;Clerk保存一个leaderID，请求失败了再换另一个server，请求成功了自增requestID。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Clerk &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	servers []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd
	&lt;span style=&#34;color:#6272a4&#34;&gt;// You will have to modify this struct.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	leaderID  &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	clientID  &lt;span style=&#34;color:#8be9fd&#34;&gt;int64&lt;/span&gt;
	requestID &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (ck &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Clerk) &lt;span style=&#34;color:#50fa7b&#34;&gt;Get&lt;/span&gt;(key &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; ck.&lt;span style=&#34;color:#50fa7b&#34;&gt;Command&lt;/span&gt;(key, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, OpGet)
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (ck &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Clerk) &lt;span style=&#34;color:#50fa7b&#34;&gt;Put&lt;/span&gt;(key &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, value &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) {
	ck.&lt;span style=&#34;color:#50fa7b&#34;&gt;Command&lt;/span&gt;(key, value, OpPut)
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (ck &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Clerk) &lt;span style=&#34;color:#50fa7b&#34;&gt;Append&lt;/span&gt;(key &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, value &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) {
	ck.&lt;span style=&#34;color:#50fa7b&#34;&gt;Command&lt;/span&gt;(key, value, OpAppend)
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (ck &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Clerk) &lt;span style=&#34;color:#50fa7b&#34;&gt;Command&lt;/span&gt;(key, value &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, op Operation) &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt; {
	req &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;getCommandRequest&lt;/span&gt;(key, value, op, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;int&lt;/span&gt;(ck.clientID), ck.requestID)	
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; {
		resp &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; CommandResponse{}
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !ck.servers[ck.leaderID].&lt;span style=&#34;color:#50fa7b&#34;&gt;Call&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;KVServer.Command&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;req, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;resp) &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; resp.Err &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; ErrWrongLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; resp.Err &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; ErrTimeout {		
			ck.leaderID = (ck.leaderID &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#ff79c6&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(ck.servers)
			&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
		}

		ck.requestID&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;	resp.Value	
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;server&#34;&gt;server&lt;/h2&gt;
&lt;p&gt;KVServer的结构体如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; KVServer &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	mu      sync.RWMutex
	me      &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	rf      &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;raft.Raft
	applyCh &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; raft.ApplyMsg
	dead    &lt;span style=&#34;color:#8be9fd&#34;&gt;int32&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// set by Kill()
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
	maxraftstate &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// snapshot if log grows this big
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your definitions here.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	persister        &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;raft.Persister
	notifyChans      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandResponse
	db               &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;
	lastSessions     &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]Session
	lastAppliedIndex &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;state-machine&#34;&gt;state-machine&lt;/h3&gt;
&lt;p&gt;本次lab中只需使用一个内存版本的 KV 状态机 map[string]string。&lt;/p&gt;
&lt;h3 id=&#34;rpc-handler&#34;&gt;RPC handler&lt;/h3&gt;
&lt;p&gt;客户端请求来临时，Server端会启动一个协程作为RPC handler来处理客户端请求，其中会调用 &lt;code&gt;Raft.Start&lt;/code&gt; 函数将请求下放到Raft层形成一条日志去做共识。在Raft层，每条被commit的日志会按照index的顺序写入applyCh中，上层必须也按index序从applyCh中读出日志并应用于状态机，这样才能保证不同节点上的数据一致。&lt;/p&gt;
&lt;p&gt;这要求必须有一个单独的applier协程来循环读applyCh，并应用于状态机。由于来自不同客户端的请求是并发的，如果在RPC handler协程中直接读applyCh无法保证index序。返回给客户端的response要根据日志应用于状态机的结果来生成，这需要我们处理RPC handler和applier协程之间的通信问题。&lt;/p&gt;
&lt;p&gt;自然想到使用channel来通信，使用一个 notifyChans map (log index -&amp;gt; response) 来记录每一个请求对应的channel。在RPC handler协程将日志下放到Raft层之后，在notifyChans中注册一个channel并阻塞读，applier协程读出日志，应用于状态机之后生成response写入这个channel。RPC handler协程在规定时间内读出结果则正常返回客户端，若超时则返回超时。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;KVServer) &lt;span style=&#34;color:#50fa7b&#34;&gt;Command&lt;/span&gt;(req &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandRequest, resp &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandResponse) {
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your code here.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] reply %+v for Request %+v&amp;#34;&lt;/span&gt;, kv.me, resp, req)

	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] received Request %+v from Clerk&amp;#34;&lt;/span&gt;, kv.me, req)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; req.Op &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; OpGet &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;isDuplicatedRequest&lt;/span&gt;(req.ClientID, req.RequestID) {
		resp.Err = kv.lastSessions[req.ClientID].Err
		kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()

	index, _, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Start&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;req)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !isLeader {
		resp.Err = ErrWrongLeader
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] add command into raft layer [index %d]&amp;#34;&lt;/span&gt;, kv.me, index)
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
	ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getNotifyChan&lt;/span&gt;(index)
	kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; result &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;ch:
		resp.Value = result.Value
		resp.Err = result.Err

	&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;500&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Millisecond).C:
		resp.Err = ErrTimeout
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;() {
		kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
		kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;removeNotifyChan&lt;/span&gt;(index)
		kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
	}()
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;KVServer) &lt;span style=&#34;color:#50fa7b&#34;&gt;applier&lt;/span&gt;() {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;killed&lt;/span&gt;() {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; applyMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;kv.applyCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; applyMsg.CommandValid {
				command &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; applyMsg.Command.(CommandRequest)
				
				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; applyMsg.CommandIndex &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;=&lt;/span&gt; kv.lastAppliedIndex {
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] discard out-of-date apply Msg in [index %d]&amp;#34;&lt;/span&gt;, kv.me, applyMsg.CommandIndex)
					kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
					&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
				}
				
				kv.lastAppliedIndex = applyMsg.CommandIndex
				&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; response &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandResponse
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; command.Op &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; OpGet &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;isDuplicatedRequest&lt;/span&gt;(command.ClientID, command.RequestID) {
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] received a duplicated command in [index %d]&amp;#34;&lt;/span&gt;, kv.me, applyMsg.CommandIndex)
					response = kv.lastSessions[command.ClientID].CommandResponse
				} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
					response = kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applyCommand&lt;/span&gt;(command)
					&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; command.Op &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; OpGet {
						kv.lastSessions[command.ClientID] = Session{
							RequestID:       command.RequestID,
							CommandResponse: response,
						}
					}
				}

				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;needToSnapshot&lt;/span&gt;(applyMsg.RaftStateSize) {
					&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] reach maxraftstate, take a snapshot till [index %d]&amp;#34;&lt;/span&gt;, kv.me, applyMsg.CommandIndex)
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;takeSnapshot&lt;/span&gt;(applyMsg.CommandIndex)
				}

				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; currentTerm, isLeader &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;GetState&lt;/span&gt;(); currentTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; applyMsg.CommandTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isLeader {
					ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;getNotifyChan&lt;/span&gt;(applyMsg.CommandIndex)
					ch &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; response
				}

				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
			} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
				&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[KVServer %d] received a snapshot from raft layer [index %d, term %d]&amp;#34;&lt;/span&gt;, kv.me, applyMsg.SnapshotIndex, applyMsg.SnapshotTerm)
				&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; kv.rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;CondInstallSnapshot&lt;/span&gt;(applyMsg.SnapshotTerm, applyMsg.SnapshotIndex, applyMsg.Snapshot) {
					kv.&lt;span style=&#34;color:#50fa7b&#34;&gt;applySnapshotToService&lt;/span&gt;(applyMsg.Snapshot)
					kv.lastAppliedIndex = applyMsg.SnapshotIndex
				}
				kv.mu.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有几点需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;apply日志时需要防止状态机回滚。在lab2中提到作为follower的节点可能收到leader的install snapshot，将snapshot写入applyCh中，此时读applyCh的顺序是：旧日志1 -&amp;gt; 新快照 -&amp;gt; 旧日志2。应用了新快照之后要避免再次应用旧日志，所以应用快照之后也要更新 lastAppliedIndex，应用日志时要先判断是否 applyMsg.CommandIndex &amp;lt;= kv.lastAppliedIndex。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仅对leader的notifyChan进行通知。每个节点在读出日志后都要提交到状态机，且更新lastSessions。但只有leader需要将response写入notifyChan。leader可能会在提交日志后失去leader身份，所以在applier中写入response前要先判断。此时RPC handler协程就让其超时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端的非读请求需要两次去重。重复的请求到来时，之前相同的请求可能已经被应用于该节点的状态机，也可能其对应的日志还没被commit。因此需要在RPC handler中调用Start之前以及日志commit之后应用于状态机之前两次去重。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;leader在调用Start提交日志后去获取notifyChan来阻塞读 以及 applier 在commit日志并应用于状态机之后获取notifyChan来写入response 这二者之间顺序无法保证。因此channel容量设置为1，先获取channel的协程要负责创建channel，这个过程要加写锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (kv &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;KVServer) &lt;span style=&#34;color:#50fa7b&#34;&gt;getNotifyChan&lt;/span&gt;(index &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandResponse {
	ch, ok &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; kv.notifyChans[index]
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !ok {
		ch &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;CommandResponse, &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)
		kv.notifyChans[index] = ch
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; ch
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; ch
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;snapshot&#34;&gt;snapshot&lt;/h3&gt;
&lt;p&gt;part B中要求我们在raft state size达到阈值时给raft层下发快照。快照中不仅需要包含KV状态机，还需要包含lastSessions客户端请求去重表。由于快照是和lastIncludeIndex对应的，所以需要由applier协程在将对应的index的日志应用于状态机后继续阻塞的生成快照。&lt;/p&gt;
&lt;h2 id=&#34;测试结果&#34;&gt;测试结果&lt;/h2&gt;
&lt;h3 id=&#34;3a&#34;&gt;3A&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;Test: one client (3A) ...
  ... Passed --  15.1  5  9881  941
Test: ops complete fast enough (3A) ...
  ... Passed --  15.5  3  7032    0
Test: many clients (3A) ...
  ... Passed --  15.6  5 11160 1171
Test: unreliable net, many clients (3A) ...
  ... Passed --  16.2  5  7462  901
Test: concurrent append to same key, unreliable (3A) ...
  ... Passed --   1.5  3   282   52
Test: progress in majority (3A) ...
  ... Passed --   1.1  5   108    2
Test: no progress in minority (3A) ...
  ... Passed --   1.0  5   184    3
Test: completion after heal (3A) ...
  ... Passed --   1.0  5    63    3
Test: partitions, one client (3A) ...
  ... Passed --  22.5  5  9323  643
Test: partitions, many clients (3A) ...
  ... Passed --  23.3  5 18230  837
Test: restarts, one client (3A) ...
  ... Passed --  22.0  5 12689  822
Test: restarts, many clients (3A) ...
  ... Passed --  22.9  5 24109 1144
Test: unreliable net, restarts, many clients (3A) ...
  ... Passed --  25.7  5  9398  873
Test: restarts, partitions, many clients (3A) ...
  ... Passed --  30.3  5 19984  848
Test: unreliable net, restarts, partitions, many clients (3A) ...
  ... Passed --  29.9  5  7443  622
Test: unreliable net, restarts, partitions, random keys, many clients (3A) ...
  ... Passed --  32.9  7 14185  904
PASS
ok  	6.824/kvraft	277.625s
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3b&#34;&gt;3B&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;Test: InstallSnapshot RPC (3B) ...
  ... Passed --   3.4  3  2151   63
Test: snapshot size is reasonable (3B) ...
  ... Passed --   2.8  3  5727  800
Test: ops complete fast enough (3B) ...
  ... Passed --   3.2  3  6962    0
Test: restarts, snapshots, one client (3B) ...
  ... Passed --  21.2  5 46519 4431
Test: restarts, snapshots, many clients (3B) ...
  ... Passed --  21.6  5 53053 4531
Test: unreliable net, snapshots, many clients (3B) ...
  ... Passed --  15.9  5 11057 1341
Test: unreliable net, restarts, snapshots, many clients (3B) ...
  ... Passed --  22.3  5 12478 1412
Test: unreliable net, restarts, partitions, snapshots, many clients (3B) ...
  ... Passed --  29.6  5  8653  760
Test: unreliable net, restarts, partitions, snapshots, random keys, many clients (3B) ...
  ... Passed --  31.6  7 25416 1802
PASS
ok  	6.824/kvraft	151.660s
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>mit-6.824 lab2: Raft</title>
        <link>https://ziannchen.work/2022/mit-6.824-lab2-raft/</link>
        <pubDate>Thu, 03 Feb 2022 15:04:30 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/mit-6.824-lab2-raft/</guid>
        <description>&lt;h1 id=&#34;lab2-raft&#34;&gt;Lab2: Raft&lt;/h1&gt;
&lt;p&gt;lab原链接 &lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/labs/lab-raft.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pdos.csail.mit.edu/6.824/labs/lab-raft.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Raft是一种基于复制的状态机协议，通过在多个副本服务器上存储其状态（即数据）的完整副本来实现容错。&lt;/p&gt;
&lt;p&gt;Raft将客户端请求组织成一个称为日志的序列，并通过复制确保所有副本服务器都看到相同的日志。每个副本按日志顺序执行客户端请求，并将它们应用于本地的状态机副本。由于所有副本服务器都看到相同的日志内容，因此它们都以相同的顺序执行相同的请求，从而继续具有相同的服务状态。如果服务器出现故障但随后恢复，Raft保证只要至少半数的服务器存活，并且可以相互通信，就可以保证正常对外服务。&lt;/p&gt;
&lt;p&gt;在本次lab中我们的任务是使用go语言实现raft。参考论文 &lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;raft-extended&lt;/a&gt;，我们需要实现除了集群成员变更之外的绝大部分内容。论文中我认为最核心的就是描述3个RPC的(Figure 2)这张图，我的实现大体上遵循了这张图。此外我也参考了一些工业级的raft实现，比如SOFAJraft、etcd，做了一些优化。在我秋招面试美团的一个做分布式存储的部门时，他们问了我很多关于raft的内容（虽然最后挂了）。&lt;/p&gt;
&lt;p&gt;有些需要注意的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当收到的RPC中的term大于自身时，无条件跟随term并转为follower，这在不同的RPC handler中的处理略有不同。&lt;/li&gt;
&lt;li&gt;在lab的一些测试用例中，网络将是不稳定的，带来大量随机的RPC丢包、乱序、超时。对于过期的RPC，直接抛弃不处理即可。对于是否过期的判断体现在term太小、身份不正确之类（例如follow收到append entries response）。&lt;/li&gt;
&lt;li&gt;锁的使用：在接发RPC、读写channel时一定不要持有锁，不然很有可能死锁。此外有许多代码块对Raft结构中各字段是只读的，我使用了读写锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结构体&#34;&gt;结构体&lt;/h2&gt;
&lt;p&gt;Raft结构中的各个变量和论文大致一样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Raft &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	rw        sync.RWMutex        &lt;span style=&#34;color:#6272a4&#34;&gt;// Lock to protect shared access to this peer&amp;#39;s state
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	peers     []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd &lt;span style=&#34;color:#6272a4&#34;&gt;// RPC end points of all peers
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	persister &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Persister          &lt;span style=&#34;color:#6272a4&#34;&gt;// Object to hold this peer&amp;#39;s persisted state
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	me        &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;                 &lt;span style=&#34;color:#6272a4&#34;&gt;// this peer&amp;#39;s index into peers[]
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	dead      &lt;span style=&#34;color:#8be9fd&#34;&gt;int32&lt;/span&gt;               &lt;span style=&#34;color:#6272a4&#34;&gt;// set by Kill()
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your data here (2A, 2B, 2C).
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#6272a4&#34;&gt;// Look at the paper&amp;#39;s Figure 2 for a description of what
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#6272a4&#34;&gt;// state a Raft server must maintain.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;
	currentState   State
	currentTerm    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	votedFor       &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	voteFrom       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;
	logs           []LogEntry
	commitIndex    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	lastApplied    &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	nextIndex      []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	matchIndex     []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	electionTimer  &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;time.Timer
	heartbeatTimer &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;time.Timer
	applyCh        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; ApplyMsg
	applierCond    sync.Cond
	replicatorCond []sync.Cond
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Make&lt;/span&gt;(peers []&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;labrpc.ClientEnd, me &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;,
	persister &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Persister, applyCh &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; ApplyMsg) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft {
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your initialization code here (2A, 2B, 2C).
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	rf &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;Raft{
		rw:             sync.RWMutex{},
		peers:          peers,
		persister:      persister,
		me:             me,
		dead:           &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;,
		currentState:   Follower,
		currentTerm:    &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;,
		votedFor:       &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;,
		voteFrom:       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;),
		logs:           &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]LogEntry, &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;),
		nextIndex:      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(peers)),
		matchIndex:     &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(peers)),
		electionTimer:  time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;RandomizedElectionTimeout&lt;/span&gt;()),
		heartbeatTimer: time.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewTimer&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;StableHeartbeatTimeout&lt;/span&gt;()),
		applyCh:        applyCh,
		replicatorCond: &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]sync.Cond, &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(peers)),
	}

	rf.applierCond = &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;sync.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewCond&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;rf.rw)
	rf.logs[&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;] = LogEntry{&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;}
	&lt;span style=&#34;color:#6272a4&#34;&gt;// initialize from state persisted before a crash
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;readPersist&lt;/span&gt;(persister.&lt;span style=&#34;color:#50fa7b&#34;&gt;ReadRaftState&lt;/span&gt;())
	rf.commitIndex, rf.lastApplied = rf.logs[&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;].Index, rf.logs[&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;].Index
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(peers); i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt; {
		rf.matchIndex[i], rf.nextIndex[i] = &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; me {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
		}

		rf.replicatorCond[i] = &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;sync.&lt;span style=&#34;color:#50fa7b&#34;&gt;NewCond&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;sync.Mutex{})
		&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;replicator&lt;/span&gt;(i)
	}

	&lt;span style=&#34;color:#6272a4&#34;&gt;// start ticker goroutine to start elections
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;ticker&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;applier&lt;/span&gt;(rf.applyCh)

	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; rf
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据论文，日志的index和term都从1开始，所以在logs[0]处存放一个index和term均为0的dummy value。&lt;/p&gt;
&lt;p&gt;在Make函数中启动了一些后台协程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replicator：共len(peers)-1个，用于管理leader对每一个follower的日志复制，下文会详细介绍。&lt;/li&gt;
&lt;li&gt;ticker：用来触发选举和心跳timeout。&lt;/li&gt;
&lt;li&gt;applier：用于向applyCh中提交已经commit的日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;leader-election&#34;&gt;leader-election&lt;/h2&gt;
&lt;h3 id=&#34;sender&#34;&gt;sender&lt;/h3&gt;
&lt;p&gt;在ticker函数中需要循环使用select监听两个timer的channel，lab的提示中说使用timer可能会有问题但我没有遇到过，懒得改了。&lt;/p&gt;
&lt;p&gt;如果是选举计时器到期，则发起一轮选举；如果是心跳计时器到期，则发起一轮心跳。二者都要首先判断当前身份是否正确。我使用了一个map来记录当前term中投票给自己的peer，需要在每次转换为candidate时清空map。也可以每次start election时声明一个得票计数，之后使用闭包来计算。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;ticker&lt;/span&gt;() {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Killed&lt;/span&gt;() {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;rf.electionTimer.C:
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.currentState &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; Leader {
				rf.currentState = Candidate
				rf.voteFrom = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;)
				rf.currentTerm&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;
				rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;startElection&lt;/span&gt;()
			}

			rf.electionTimer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Reset&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;RandomizedElectionTimeout&lt;/span&gt;())
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;rf.heartbeatTimer.C:
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.currentState &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Leader {
				&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] boardcast heartbeat at term %d&amp;#34;&lt;/span&gt;, rf.me, rf.currentTerm)
				rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;boardcastHeartbeat&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;)
			}

			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;选举需要异步对每个peer发送request vote，不然就太慢了。异步才不会阻塞ticker，能快速重置计时器。response handler中要先判断是否仍满足rf.currentTerm == args.Term &amp;amp;&amp;amp; rf.currentState == Candidate，若不满足说明RPC过期，直接抛弃不处理。&lt;/p&gt;
&lt;p&gt;我之所以没有使用闭包是因为这样难以抽象出一个 handleRequestVoteResponse 函数，代码结构不够统一。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;startElection&lt;/span&gt;() {
	args &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getDefaultRequestVoteArgs&lt;/span&gt;()
	rf.votedFor, rf.voteFrom[rf.me] = rf.me, &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] start election at term %d&amp;#34;&lt;/span&gt;, rf.me, rf.currentTerm)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; index &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; rf.peers {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; index &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; rf.me {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
		}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(i &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
			reply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; RequestVoteReply{}
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;sendRequestVote&lt;/span&gt;(i, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply) {
				rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
				rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;handleRequestVoteResponse&lt;/span&gt;(i, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply)
				rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
			}
		}(index)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;handler&#34;&gt;handler&lt;/h3&gt;
&lt;p&gt;handler的实现完全参照论文，先判断term是否小于自身，再判断term、voteFor和日志是否满足条件。判断voteFor时要先满足args.Term == rf.currentTerm，这是由于args.Term &amp;gt; rf.currentTerm时需要无条件跟随term并重置voteFor。&lt;/p&gt;
&lt;p&gt;需要注意的是只有同意投票时才需要重置election timer，这在课程的TA的guidance中有提及，有利于在网络不稳定时仍能快速选出leader。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;RequestVote&lt;/span&gt;(args &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;RequestVoteArgs, reply &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;RequestVoteReply) {
	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your code here (2A, 2B).
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] reply [%s] for RequestVote to %d&amp;#34;&lt;/span&gt;, rf.me, reply, args.CandidateId)

	rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d][state %s term %d vote %d lastindex %d lastterm %d] receive RequestVote [%s] from %d&amp;#34;&lt;/span&gt;, rf.me, StateName[rf.currentState], rf.currentTerm, rf.votedFor, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Term, args, args.CandidateId)

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; args.Term &amp;lt; rf.currentTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; (args.Term &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; rf.currentTerm &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; rf.votedFor &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; rf.votedFor &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; args.CandidateId) {
		reply.Term, reply.VoteGranted = rf.currentTerm, &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	needToPersist &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; args.Term &amp;gt; rf.currentTerm {
		rf.currentTerm, rf.votedFor = args.Term, &lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;
		&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] change state from Leader to Follower at term %d&amp;#34;&lt;/span&gt;, rf.me, rf.currentTerm)
		rf.currentState = Follower
		needToPersist = &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;isLogUpToDate&lt;/span&gt;(args.LastLogIndex, args.LastLogTerm) {
		reply.Term, reply.VoteGranted = rf.currentTerm, &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; needToPersist {
			rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
		}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	reply.Term, reply.VoteGranted = rf.currentTerm, &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	rf.votedFor = args.CandidateId
	rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
	rf.electionTimer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Reset&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;RandomizedElectionTimeout&lt;/span&gt;())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;log-replication&#34;&gt;log-replication&lt;/h2&gt;
&lt;h3 id=&#34;replicator&#34;&gt;replicator&lt;/h3&gt;
&lt;p&gt;根据每个peer的nextIndex判断发送entries或是snapshot。&lt;/p&gt;
&lt;p&gt;response handler的实现参照论文，先判断是否过期，再判断是否成功。若成功，则更新match、next index。找到最新的复制到超过半数peer且term等于当前term的日志，更新commit。需要注意日志的term必须和当前term一致才能更新commit，不然可能会有安全性问题导致已经commit的日志被覆盖，我忘了哪个测试一直过不了后来发现就是这个原因，所以论文一定要非常仔细读。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;doReplicate&lt;/span&gt;(i &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
	rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.currentState &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; Leader {
		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.nextIndex[i] &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getDummyLogntry&lt;/span&gt;().Index {
		args &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getDefaultInstallSnapshotArgs&lt;/span&gt;()
		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()

		reply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; InstallSnapshotReply{}
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;sendInstallSnapshot&lt;/span&gt;(i, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply) {
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
			rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;handleInstallSnapshotResponse&lt;/span&gt;(i, args, reply)
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
		}
	} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
		args &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getDefaultAppendEntriesArgs&lt;/span&gt;(i)
		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()

		reply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; AppendEntriesReply{}
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;sendAppendEntries&lt;/span&gt;(i, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply) {
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
			rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;handleAppendEntriesReponse&lt;/span&gt;(i, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;args, &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;reply)
			rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我参考了 &lt;a class=&#34;link&#34; href=&#34;https://github.com/LebronAl/MIT6.824-2021/blob/master/docs/lab2.md#%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LebronAI&lt;/a&gt; 的设计。&lt;/p&gt;
&lt;p&gt;如果为每一次Start、心跳都广播发送一次append entries，则将下层的日志同步与上层的提交新指令强绑定了，会造成RPC数量过多，还会重复发送很多次相同的日志项。每次发送 rpc 都不论是发送端还是接收端都需要若干次系统调用和内存拷贝，rpc 次数过多也会对 CPU 造成不必要的压力。&lt;/p&gt;
&lt;p&gt;这里可以做一个batching的优化，也将二者之间解耦。这里原作者参考了SOFAJraft的日志复制模型，让每个peer对于其他所有peer各维护一个replicator协程，负责在自己成为leader时对单独一个peer的日志复制。&lt;/p&gt;
&lt;p&gt;这个协程利用条件变量 &lt;code&gt;sync.Cond&lt;/code&gt; 执行 &lt;code&gt;Wait&lt;/code&gt; 来避免耗费 cpu，每次需要进行一次日志复制时调用 &lt;code&gt;Signal&lt;/code&gt; 唤醒。它在满足复制条件时会尽最大努力将[nextIndex, lastIndex]之间的日志复制到peer上。&lt;/p&gt;
&lt;p&gt;由于leader使用replicator维护对于一个peer的日志复制，同一时间下最多只会发送一个RPC，若RPC丢失、超时很可能触发re-election。因此：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;心跳计时器到期，很急，要立即发送RPC。leader commit更新时也要立即发送RPC，这个是为啥我忘记了。&lt;/li&gt;
&lt;li&gt;Start被调用，不急，只需调用条件变量的 &lt;code&gt;Singal&lt;/code&gt;，让replicator慢慢发。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;replicator&lt;/span&gt;(peer &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) {
	rf.replicatorCond[peer].L.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; rf.replicatorCond[peer].L.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Killed&lt;/span&gt;() {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;needToReplicate&lt;/span&gt;(peer) {
			rf.replicatorCond[peer].&lt;span style=&#34;color:#50fa7b&#34;&gt;Wait&lt;/span&gt;()
		}

		rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;doReplicate&lt;/span&gt;(peer)
	}
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;needToReplicate&lt;/span&gt;(peer &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt; {
	rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RLock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;RUnlock&lt;/span&gt;()

	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; rf.currentState &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Leader &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; rf.nextIndex[peer] &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index
}
 
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;boardcastHeartbeat&lt;/span&gt;(isHeartbeat &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;) {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; index &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; rf.peers {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; index &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; rf.me {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;continue&lt;/span&gt;
		}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; isHeartbeat {
			&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;doReplicate&lt;/span&gt;(index)
		} &lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt; {
			rf.replicatorCond[index].&lt;span style=&#34;color:#50fa7b&#34;&gt;Signal&lt;/span&gt;()
		}
	}

	rf.heartbeatTimer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Reset&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;StableHeartbeatTimeout&lt;/span&gt;())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;handler-1&#34;&gt;handler&lt;/h3&gt;
&lt;p&gt;完全按照论文图中伪代码实现，包括了课程视频中提到的加速解决日志冲突的优化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;AppendEntries&lt;/span&gt;(args &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;AppendEntriesArgs, reply &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;AppendEntriesReply) {
	rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
	&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d][term %d lastindex %d lastterm %d commit %d] receive AppendEntries %+v from %d&amp;#34;&lt;/span&gt;, rf.me, rf.currentTerm, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Term, rf.commitIndex, args, args.LeaderId)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
	&lt;span style=&#34;color:#ff79c6&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] reply [%s] for AppendEntries to %d&amp;#34;&lt;/span&gt;, rf.me, reply, args.LeaderId)

	needToPersist &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; args.Term &amp;lt; rf.currentTerm {
		reply.Success, reply.Term = &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;, rf.currentTerm
		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; args.Term &amp;gt; rf.currentTerm {
		rf.currentTerm = args.Term
		needToPersist = &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	}

	rf.currentState = Follower
	rf.electionTimer.&lt;span style=&#34;color:#50fa7b&#34;&gt;Reset&lt;/span&gt;(&lt;span style=&#34;color:#50fa7b&#34;&gt;RandomizedElectionTimeout&lt;/span&gt;())

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; args.PrevLogIndex &amp;lt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getDummyLogntry&lt;/span&gt;().Index {
		reply.Success, reply.Term = &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; needToPersist {
			rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
		}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;isLogMatch&lt;/span&gt;(args.PrevLogIndex, args.PrevLogTerm) {
		reply.Term, reply.Success = rf.currentTerm, &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;
		reply.XIndex, reply.Term = rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getConflictEntry&lt;/span&gt;(args.PrevLogIndex)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; needToPersist {
			rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
		}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
	}

	lastLogIndex &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; index, entry &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; args.Entries {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; entry.Index &amp;gt; lastLogIndex &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; rf.logs[rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getSliceIndex&lt;/span&gt;(entry.Index)].Term &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; entry.Term {
			rf.logs = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;(rf.logs[:rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getSliceIndex&lt;/span&gt;(entry.Index)], args.Entries[index:]&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)
			&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] append Follower&amp;#39;s last log index from %d to %d&amp;#34;&lt;/span&gt;, rf.me, lastLogIndex, rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getLastLogEntry&lt;/span&gt;().Index)
			needToPersist = &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
			&lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;
		}
	}

	rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;maybeAdvanceFollowerCommit&lt;/span&gt;(args.LeaderCommit)
	reply.Success = &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; needToPersist {
		rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;persist&lt;/span&gt;()
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;persistence&#34;&gt;persistence&lt;/h2&gt;
&lt;p&gt;论文中提到有三个变量是需要持久化的：currentTerm、votedFor、log[]，这三个量每次改变之后都应该持久化。&lt;/p&gt;
&lt;p&gt;持久化应当在被其他协程感知（发送RPC、释放锁）之前完成，而每个函数中如果没有改变这三个量（如加锁之后发现RPC过期）则不用持久化，若有也只需持久化一次，所以我在很多地方都使用了一个 needToPersist 布尔量进行判断。这样写感觉不够优雅，暂时没想到其他方法。&lt;/p&gt;
&lt;h2 id=&#34;log-compaction&#34;&gt;log-compaction&lt;/h2&gt;
&lt;p&gt;对于leader，在replicator中根据next index判断出需要给peer发送快照时，调用 &lt;code&gt;persister.ReadSnapshot&lt;/code&gt; 获得快照并发送。&lt;/p&gt;
&lt;p&gt;对于接收方，需要判断如果 args.LastIncludedIndex &amp;lt;= rf.commitIndex，则拒绝接收快照。这说明本地状态机已经至少比该快照更新（或者将要，因为applier协程已经在apply这些日志的过程中了），可能导致raft回到旧的状态。应当等待service层调用 &lt;code&gt;Snapshot&lt;/code&gt; 函数来安装快照。接收快照后，异步写入到applyCh中。&lt;/p&gt;
&lt;p&gt;对于两个service层给raft层安装快照的函数，它们的区别是：&lt;code&gt;Snapshot&lt;/code&gt; 是由service层在处理apply message时判断raft state&amp;rsquo;s size是否达到阈值，主动调用。&lt;code&gt;CondInstallSnapshot&lt;/code&gt; 是service层在处理apply message中leader发来的更新的快照时调用，也需要再次判断是否 LastIncludedIndex &amp;lt;= rf.commitIndex，安装快照之后应该更新lastApplied、commitIndex。&lt;/p&gt;
&lt;p&gt;安装快照后需要压缩日志，但是需要记录下包含在快照中的最新的日志项的index和term，我将其记录在dummy entry（即rf.log[0]）中。此外被删除的日志项需要被正确的删除使其能够被gc。&lt;/p&gt;
&lt;h2 id=&#34;applier&#34;&gt;applier&lt;/h2&gt;
&lt;p&gt;根据论文，一旦commitIndex &amp;gt; lastApplied，则需要将[lastApplied+1, commitIndex]中的所有日志项apply到状态机并增加lastApplied。&lt;/p&gt;
&lt;p&gt;一开始我的实现是每次commitIndex更新，都异步起一个协程将[lastApplied+1, commitIndex]间日志写入applyCh。但是因为写channel时不能持有锁，所以这个过程只能是：&lt;/p&gt;
&lt;p&gt;加锁 -&amp;gt; 深拷贝日志项 -&amp;gt; 释放锁 -&amp;gt; 写channel -&amp;gt; 加锁 -&amp;gt; 更新lastApplied -&amp;gt; 释放锁&lt;/p&gt;
&lt;p&gt;日志在push完之前不会更新lastApplied，这样容易造成相同的日志项被重复apply，存在资源浪费。所以这里也可以参考之前replicator的实现思路，后台起一个applier协程，平时调用一个条件变量的 &lt;code&gt;Wait&lt;/code&gt; ，被 &lt;code&gt;Signal&lt;/code&gt; 唤醒时将[lastApplied+1, commitIndex]中的所有日志项apply到状态机，每次更新commitIndex时调用 &lt;code&gt;Signal&lt;/code&gt;。这样即能避免日志被重复apply，也完成了 apply 日志到状态机和 raft 提交新日志之间的解耦。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (rf &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Raft) &lt;span style=&#34;color:#50fa7b&#34;&gt;applier&lt;/span&gt;(applyCh &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; ApplyMsg) {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;Killed&lt;/span&gt;() {
		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; !rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;needToApply&lt;/span&gt;() {
			rf.applierCond.&lt;span style=&#34;color:#50fa7b&#34;&gt;Wait&lt;/span&gt;()
		}

		lastApplied, commitIndex &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; rf.lastApplied, rf.commitIndex
		needToApply &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DeepCopy&lt;/span&gt;(rf.logs[rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getSliceIndex&lt;/span&gt;(lastApplied&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;) : rf.&lt;span style=&#34;color:#50fa7b&#34;&gt;getSliceIndex&lt;/span&gt;(commitIndex)&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;])

		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
		&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; _, entry &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; needToApply {
			applyMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; ApplyMsg{
				CommandValid:  &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;,
				Command:       entry.Command,
				CommandIndex:  entry.Index,
				CommandTerm:   entry.Term,
				RaftStateSize: rf.persister.&lt;span style=&#34;color:#50fa7b&#34;&gt;RaftStateSize&lt;/span&gt;(),
			}

			applyCh &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; applyMsg
			&lt;span style=&#34;color:#50fa7b&#34;&gt;DPrintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Server %d] applied log [index %d] at term %d&amp;#34;&lt;/span&gt;, rf.me, entry.Index, entry.Term)
		}

		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Lock&lt;/span&gt;()
		&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; commitIndex &amp;gt; rf.lastApplied {
			rf.lastApplied = commitIndex
		}

		rf.rw.&lt;span style=&#34;color:#50fa7b&#34;&gt;Unlock&lt;/span&gt;()
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意因为写channel时是不加锁的，而写channel是可能出现并发的，可能存在一种情况：applier在写入一批旧日志时，follower接受leader的 &lt;code&gt;InstallSnapshot&lt;/code&gt; 之后将新的snapshot写入channel。此时channel的写入顺序可能是：旧日志1 -&amp;gt; 新快照 -&amp;gt; 旧日志2。&lt;/p&gt;
&lt;p&gt;service层读channel是线性的，在读出snapshot并调用 &lt;code&gt;CondInstallSnapshot&lt;/code&gt; 后会更新raft层的lastApplied、commitIndex。因此在raft层apply完日志之后，重新获得锁去更新lastApplied时要注意不能回退，在这二者之间可能service层已经对更新的快照调用过 &lt;code&gt;CondInstallSnapshot&lt;/code&gt; 了（新快照的 lastIncludeIndex 一定大于 commitIndex ）。&lt;/p&gt;
&lt;h2 id=&#34;测试结果&#34;&gt;测试结果&lt;/h2&gt;
&lt;h3 id=&#34;2a&#34;&gt;2A&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;Test (2A): initial election ...
  ... Passed --   3.6  3   46   12142    0
Test (2A): election after network failure ...
  ... Passed --   5.6  3   94   19292    0
Test (2A): multiple elections ...
  ... Passed --   7.9  7  534  113432    0
PASS
ok  	6.824/raft	17.177s
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2b&#34;&gt;2B&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Test (2B): basic agreement ...
  ... Passed --   1.1  3   16    4326    3
Test (2B): RPC byte count ...
  ... Passed --   1.3  3   48  153910   11
Test (2B): agreement despite follower disconnection ...
  ... Passed --   4.3  3   75   19840    7
Test (2B): no agreement if too many followers disconnect ...
  ... Passed --   4.7  5  146   33983    4
Test (2B): concurrent Start()s ...
  ... Passed --   1.5  3   18    5054    6
Test (2B): rejoin of partitioned leader ...
  ... Passed --   5.1  3  117   27458    4
Test (2B): leader backs up quickly over incorrect follower logs ...
  ... Passed --   9.8  5 1023  627193  102
Test (2B): RPC counts aren&#39;t too high ...
  ... Passed --   3.0  3   42   12296   12
PASS
ok  	6.824/raft	30.976s
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2c&#34;&gt;2C&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Test (2C): basic persistence ...
  ... Passed --   6.0  3   91   21819    6
Test (2C): more persistence ...
  ... Passed --  18.3  5  821  178397   16
Test (2C): partitioned leader and one follower crash, leader restarts ...
  ... Passed --   2.7  3   35    8235    4
Test (2C): Figure 8 ...
  ... Passed --  27.9  5  530  117688   23
Test (2C): unreliable agreement ...
  ... Passed --   3.0  5  753  240518  246
Test (2C): Figure 8 (unreliable) ...
  ... Passed --  36.6  5 1684 3862021  145
Test (2C): churn ...
  ... Passed --  16.5  5 7937 3098958 1199
Test (2C): unreliable churn ...
  ... Passed --  16.3  5 1631 1031494  298
PASS
ok  	6.824/raft	127.309s
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2d&#34;&gt;2D&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Test (2D): snapshots basic ...
  ... Passed --   2.4  3  247   96514  251
Test (2D): install snapshots (disconnect) ...
  ... Passed --  46.7  3 1035  293753  399
Test (2D): install snapshots (disconnect+unreliable) ...
  ... Passed --  52.4  3 1153  310385  377
Test (2D): install snapshots (crash) ...
  ... Passed --  32.0  3  722  206681  322
Test (2D): install snapshots (unreliable+crash) ...
  ... Passed --  43.7  3  806  220815  388
PASS
ok  	6.824/raft	177.243s
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>mit-6.824 lab1: MapReduce</title>
        <link>https://ziannchen.work/2022/mit-6.824-lab1-mapreduce/</link>
        <pubDate>Thu, 03 Feb 2022 15:01:24 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/mit-6.824-lab1-mapreduce/</guid>
        <description>&lt;h1 id=&#34;lab1-mapreduce&#34;&gt;Lab1: MapReduce&lt;/h1&gt;
&lt;p&gt;在本次lab中我们的任务是实现一个分布式的MapReduce，它由两个程序组成，Coordinator和Worker。只有一个Coordinator，一个或多个Worker并行执行。&lt;/p&gt;
&lt;p&gt;每个Worker将通过RPC与Coordinator通信以请求一个Map或Reduce任务，之后从一个或多个文件中读取任务的输入，执行任务，并将任务的输出写入一个或多个文件。&lt;/p&gt;
&lt;p&gt;Coordinator应注意到Worker是否在合理的时间内（10s）完成了任务，如果没有则将相同的任务交给另一个Worker。&lt;/p&gt;
&lt;h2 id=&#34;coordinator&#34;&gt;Coordinator&lt;/h2&gt;
&lt;p&gt;写这个lab的时候刚学go语言不久，觉得channel这个东西很帅，就使用了很多channel实现了一个lock-free版本的Coordinator，实践了一下csp。&lt;/p&gt;
&lt;h3 id=&#34;核心结构体&#34;&gt;核心结构体&lt;/h3&gt;
&lt;p&gt;Coordinator维护每一个Map和Reduce任务的状态，这样就不用维护每一个worker的状态，这也利于worker的弹性伸缩。&lt;/p&gt;
&lt;p&gt;xxxidCh用于在获取任务编号并发放给worker，xxxDoneCh和xxxUndoneCh用于获取完成或未完成的任务编号修改任务状态。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Coordinator &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	files          []&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;
	nMap           &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	nReduce        &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	mapidCh        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	reduceidCh     &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	mapStatus      []Task
	reduceStatus   []Task

	heartbeatCh    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; heartbeatMsg
	reportCh       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; reportMsg
	stateCh        &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; getStateMsg

	mapDoneCh      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; Execution
	reduceDoneCh   &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; Execution
	mapUndoneCh    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; Execution
	reduceUndoneCh &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; Execution
	
	mapComplete    &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;
	reduceComplete &lt;span style=&#34;color:#8be9fd&#34;&gt;bool&lt;/span&gt;
	mapRemain      &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	reduceRemain   &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每个任务的状态有3种，每个任务被初始化时都是UnStarted，被分配给Worker之后转换为Processing，收到Report完成转为Done，未完成转为UnStarted。&lt;/p&gt;
&lt;p&gt;结构体Task用term和任务状态共同表示一个任务的信息，term代表该任务被分配给worker执行的次数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; TaskStatus &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;const&lt;/span&gt; (
	UnStarted TaskStatus = &lt;span style=&#34;color:#ff79c6&#34;&gt;iota&lt;/span&gt;
	Processing
	Done
)

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Task &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	term &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	TaskStatus
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;rpc-handler&#34;&gt;RPC-handler&lt;/h3&gt;
&lt;p&gt;Coordinator接收到RPC之后，包装出一个xxxMsg结构，传入RPC对应的channel中。&lt;/p&gt;
&lt;p&gt;Done在这里作用类似于一个回调。Coordinator在启动时会在后台启动一个goroutine，不断监控 heartbeatCh 和 reportCh 中的Msg并处理，处理完成后执行msg.Done &amp;lt;- struct{}{}。在RPC handler中只需要等待Done这个channel返回。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; heartbeatMsg &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	response &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;HeartbeatResponse
	Done       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt;{}
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; reportMsg &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	request &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ReportRequest
	Done      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt;{}
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (c &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Coordinator) &lt;span style=&#34;color:#50fa7b&#34;&gt;Heartbeat&lt;/span&gt;(request &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;HeartbeatRequest, response &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;HeartbeatResponse) &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt; {
	log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Coordinator] receive a request from worker&amp;#34;&lt;/span&gt;)
	msg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; heartbeatMsg{
		response: response,
		Done:       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt;{}),
	}
	c.heartbeatCh &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; msg
	&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;msg.Done

	log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Coordinator] run heartbeat [%s] for worker&amp;#34;&lt;/span&gt;, response)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;
}

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (c &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Coordinator) &lt;span style=&#34;color:#50fa7b&#34;&gt;Report&lt;/span&gt;(request &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ReportRequest, response &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ReportResponse) &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt; {
	log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Coordinator] receive worker&amp;#39;s report [%s]&amp;#34;&lt;/span&gt;, request)
	msg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; reportMsg{
		request: request,
		Done:      &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt;{}),
	}

	c.reportCh &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; msg
	&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;msg.Done

	log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Coordinator] finish dealing with the report from worker&amp;#34;&lt;/span&gt;)
	&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;handleHeartbeatMsg&lt;/code&gt;函数中处理心跳，根据当前Map和Reduce任务的状态给Worker分配一个任务、让worker等待或是告知所有任务已经完成。任务的id从mapidCh或reduceidCh两个channel中读出，在response中还要加上任务的term，每次分配该任务前需要对term自增以在不同的执行者之间区分。&lt;/p&gt;
&lt;p&gt;那么任务的id是什么时候写入channel中的呢？Coordinator在初始化时先将所有Map任务的id写入mapidCh，在所有Map任务都完成后将所有Reduce任务的id写入reduceidCh。&lt;/p&gt;
&lt;p&gt;需要注意一点，每个任务在分配之后10s内如果没有收到Report，则应该默认任务失败。这需要另起一个goroutine来判断，直接sleep 10s之后将id写入Undone channel即可，让run函数去判断。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;handleReportMsg&lt;/code&gt;函数中处理worker的返回任务结果，根据结构类型将任务的Execution写入对应的Done/Undone channel。我将任务的term和id包装成一个Execution结构表示任务的一次执行，使得某次任务失败是超时还是worker返回失败这两种情况可以被区分。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Execution &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
	term &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
	id   &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;核心逻辑&#34;&gt;核心逻辑&lt;/h3&gt;
&lt;p&gt;run函数是Coordinator的核心，它作为一个后台运行的goroutine在不断的循环中监听各个channel并执行对应的操作。由于所有的数据都在这一个goroutine中修改，避免了data-race。&lt;/p&gt;
&lt;p&gt;Coordinator真正处理worker上报的任务的完成情况是由run函数在select中同时监听这4个channel，再根据任务id来执行对应逻辑。因此&lt;code&gt;handleReportMsg&lt;/code&gt;函数可以另起一个goroutine来执行，这4个channel的容量也只需设置为1。&lt;/p&gt;
&lt;p&gt;从4个channel读出任务id后要注意，只有在对应的状态、Execution中term和本地任务的term一致时才能执行逻辑。&lt;/p&gt;
&lt;p&gt;例如某个MapFailed消息在10s之后到达，这可能是因为网络拥塞或是worker执行任务太慢，这个map任务已经被重新分配给了另一个worker，此时状态是仍是Processing。但这时term不一致应该放弃处理这个MapFailed消息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (c &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Coordinator) &lt;span style=&#34;color:#50fa7b&#34;&gt;run&lt;/span&gt;() &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt; {
	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;select&lt;/span&gt; {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; hbMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.heartbeatCh:
			c.&lt;span style=&#34;color:#50fa7b&#34;&gt;handleHeartbeatMsg&lt;/span&gt;(hbMsg)

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; rpMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.reportCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;go&lt;/span&gt; c.&lt;span style=&#34;color:#50fa7b&#34;&gt;handleReportMsg&lt;/span&gt;(rpMsg)

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; e &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.mapDoneCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; c.mapStatus[e.id].TaskStatus &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Processing &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c.mapStatus[e.id].term &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; e.term {
				···
			}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; e &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.reduceDoneCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; c.reduceStatus[e.id].TaskStatus &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Processing &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c.reduceStatus[e.id].term &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; e.term {
				···
			}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; e &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.mapUndoneCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; c.mapStatus[e.id].TaskStatus &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Processing &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c.mapStatus[e.id].term &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; e.term {
				···
			}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; e &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.reduceUndoneCh:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; c.reduceStatus[e.id].TaskStatus &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; Processing &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; c.reduceStatus[e.id].term &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; e.term {
				···
			}

		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; stMsg &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt;c.stateCh:
			stMsg.state &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;-&lt;/span&gt; c.reduceComplete

		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;worker&#34;&gt;Worker&lt;/h2&gt;
&lt;p&gt;worker的实现比较简单，只需要循环向coordinator请求任务执行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Worker&lt;/span&gt;(mapf &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) []KeyValue,
	reducef &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;, []&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) {

	&lt;span style=&#34;color:#6272a4&#34;&gt;// Your worker implementation here.
&lt;/span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; {
		response &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;doHeartbeat&lt;/span&gt;()
		log.&lt;span style=&#34;color:#50fa7b&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Worker] receive coordinator&amp;#39;s heartbeat [%s]&amp;#34;&lt;/span&gt;, response)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;switch&lt;/span&gt; response.Type {
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; Map:
			&lt;span style=&#34;color:#50fa7b&#34;&gt;doMapTask&lt;/span&gt;(mapf, response.Id, response.Term, response.NReduce, response.Name)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; Reduce:
			&lt;span style=&#34;color:#50fa7b&#34;&gt;doReduceTask&lt;/span&gt;(reducef, response.Id,response.Term, response.NMap)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; Wait:
			time.&lt;span style=&#34;color:#50fa7b&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; time.Second)
		&lt;span style=&#34;color:#ff79c6&#34;&gt;case&lt;/span&gt; Completed:
			&lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt;
		&lt;span style=&#34;color:#ff79c6&#34;&gt;default&lt;/span&gt;:
			&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;panic&lt;/span&gt;(fmt.&lt;span style=&#34;color:#50fa7b&#34;&gt;Sprintf&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;[Worker] unexpected jobType %v&amp;#34;&lt;/span&gt;, response.Type))
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行Map任务时，只需将mapf函数产生的中间文件kv pair按照ihash(kv.Key)%nReduce的余数写入不同的文件等待Reduce即可。写入的文件要先调用ioutil.TempFile(&amp;quot;&amp;quot;, &amp;ldquo;temp&amp;rdquo;)生成再调用os.Rename()改为mr-i-j。&lt;/p&gt;
&lt;p&gt;执行Reduce任务时，先建立一个kv数组，再将所有中间文件中的kv pair append到数组中再排序，将相同key对应的所有value append到一个string数组中，喂给reducef函数执行。看起来非常暴力，在工业界应该不可行，但通过本次lab的测试足够了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>mit-6.824 lab0: Preface</title>
        <link>https://ziannchen.work/2022/mit-6.824-lab0-preface/</link>
        <pubDate>Thu, 03 Feb 2022 14:01:24 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/mit-6.824-lab0-preface/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;21年的3月份，大三下学期，我收到了一份暑期实习的offer。需要提前学习一下go语言，之后在某学长的安利下我了解到了mit-6.824这门课程，他建议我做一下这门课的4个lab就当实践一下go。不过我配好环境后就去浪了2333，也就断断续续的在b站上看了几期课的视频。&lt;/p&gt;
&lt;p&gt;真正开始写lab还是暑假实习在公司摸鱼的时候开始的，当时还拉着旁边组的一个实习生一起写相互交流进度。不得不说，课程、论文和lab真的都是非常非常的硬核（虽然我论文只大概看了前几篇），分布式系统这个领域也真的是非常非常的有趣，比学校里学的东西不知道高到哪里去了。暑假结束时还只写完了lab2，lab3只写了一点点，之后由于搞完秋招后一直在玩，年底又去写PingCAP talent-plan的tinykv了（这个也挺有意思的，也更贴近工业界，可惜文档给的太少，与之相比6.824的实现就像个玩具）导致进度很慢，最终22年1月中旬才全部写完。&lt;/p&gt;
&lt;p&gt;最近（毕业之前）我应该会将整理完所有的文档、实现思路发出来，也锻炼一下自己写技术文章的水平。&lt;/p&gt;
&lt;h2 id=&#34;一些资料&#34;&gt;一些资料&lt;/h2&gt;
&lt;h3 id=&#34;我的实验配置&#34;&gt;我的实验配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;win10 + wsl2 + ubuntu 20.04&lt;/li&gt;
&lt;li&gt;16G内存&lt;/li&gt;
&lt;li&gt;go version 1.15&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;课程网站&#34;&gt;课程网站&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://nil.csail.mit.edu/6.824/2021/schedule.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;6.824 Schedule: Spring 2021&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;用于并发测试的脚本&#34;&gt;用于并发测试的脚本&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&lt;/span&gt;rm -rf tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;
mkdir tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;start_time&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;$(&lt;/span&gt;date + %s&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;[&lt;/span&gt; -e /tmp/fd1 &lt;span style=&#34;color:#ff79c6&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;||&lt;/span&gt; mkfifo /tmp/fd1
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;exec&lt;/span&gt; 3&amp;lt;&amp;gt;/tmp/fd1
rm -rf /tmp/fd1
&lt;span style=&#34;color:#6272a4&#34;&gt;# 同时执行 10 个线程，依照cpu核心数视情况而定&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 1; i &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 10; i++&lt;span style=&#34;color:#ff79c6&#34;&gt;))&lt;/span&gt;; &lt;span style=&#34;color:#ff79c6&#34;&gt;do&lt;/span&gt;
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;echo&lt;/span&gt; &amp;gt;&amp;amp;&lt;span style=&#34;color:#bd93f9&#34;&gt;3&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;done&lt;/span&gt;

&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 1; i &amp;lt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 500; i++&lt;span style=&#34;color:#ff79c6&#34;&gt;))&lt;/span&gt;; &lt;span style=&#34;color:#ff79c6&#34;&gt;do&lt;/span&gt;
  &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;read&lt;/span&gt; -u3
  &lt;span style=&#34;color:#ff79c6&#34;&gt;{&lt;/span&gt;
	touch ./tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;/report_&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$i&lt;/span&gt;.log
    go &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;test&lt;/span&gt; -run &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt; -race &amp;gt; ./tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;/report_&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$i&lt;/span&gt;.log
	&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;$(&lt;/span&gt;tail -n &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt; ./tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;/report_&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$i&lt;/span&gt;.log&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;s&lt;/span&gt;:&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;ok&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;]&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;then&lt;/span&gt;
		rm ./tmp-&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$1&lt;/span&gt;/report_&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$i&lt;/span&gt;.log
	&lt;span style=&#34;color:#ff79c6&#34;&gt;else&lt;/span&gt;
		&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;test &lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$i&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt; Failed&amp;#34;&lt;/span&gt;
	&lt;span style=&#34;color:#ff79c6&#34;&gt;fi&lt;/span&gt;

    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;echo&lt;/span&gt; &amp;gt;&amp;amp;&lt;span style=&#34;color:#bd93f9&#34;&gt;3&lt;/span&gt;
  &lt;span style=&#34;color:#ff79c6&#34;&gt;}&lt;/span&gt; &amp;amp;
&lt;span style=&#34;color:#ff79c6&#34;&gt;done&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;wait&lt;/span&gt;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;stop_time&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;$(&lt;/span&gt;date +%s&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;

&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;TIME:&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;$(&lt;/span&gt;expr &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$stop_time&lt;/span&gt; - &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$start_time&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;exec&lt;/span&gt; 3&amp;lt;&amp;amp;-
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;exec&lt;/span&gt; 3&amp;gt;&amp;amp;-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Hugo&amp;Stack &#43; Github Pages &#43; Github Actions 建站记录</title>
        <link>https://ziannchen.work/2022/hugostack-github-pages-github-actions-%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/</link>
        <pubDate>Mon, 31 Jan 2022 14:38:17 +0800</pubDate>
        
        <guid>https://ziannchen.work/2022/hugostack-github-pages-github-actions-%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/</guid>
        <description>&lt;h2 id=&#34;开端&#34;&gt;开端&lt;/h2&gt;
&lt;p&gt;一个程序员怎么能没有一个属于自己的技术博客呢？念叨这句话很久了，22年的春节我终于新建了文件夹。&lt;/p&gt;
&lt;h2 id=&#34;技术栈选型&#34;&gt;技术栈选型&lt;/h2&gt;
&lt;p&gt;框架 &lt;code&gt;Hugo&lt;/code&gt; ，主题 &lt;code&gt;Stack&lt;/code&gt; ，托管于 &lt;code&gt;GitHub Pages&lt;/code&gt;，域名备案于阿里云。此外使用了 &lt;code&gt;Github Actions&lt;/code&gt; 进行自动化部署。&lt;/p&gt;
&lt;h2 id=&#34;框架&#34;&gt;框架&lt;/h2&gt;
&lt;p&gt;一开始只知道博客可以托管在GitHub Pages上，作为完全不懂前端的我，肯定要选个简单的博客框架，上网查了下主要有Hexo和Hugo。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hexo？要用 nodejs，先pass。&lt;/li&gt;
&lt;li&gt;Hugo？是 go 语言开发的，这我熟，就它了！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt; 是由 Go 语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。&lt;code&gt;Hugo&lt;/code&gt; 的速度真的非常快，本地运行后，更新一保存之后马上在浏览器之后就能看到结果。此外还要选个主题，我用的是 &lt;code&gt;Stack&lt;/code&gt;。具体看 &lt;a class=&#34;link&#34; href=&#34;https://www.gohugo.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hugo 官方文档&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://docs.stack.jimmycai.com/zh/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Stack 官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;折腾博客的各种小细节时，基本都在参考这位博主的 &lt;a class=&#34;link&#34; href=&#34;https://mantyke.icu/2022/stack-theme-furnish03/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;装修记录&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;需要注意一点，&lt;code&gt;Hugo&lt;/code&gt; 框架的文件结构和 themes 中主题的文件结构是相同的，在修改样式时需要将主题文件夹中的同名文件复制到外边再做修改。若在主题文件夹中修改，由于自动化部署时是在 GitHub Actions 提供的 runner 上每次重新获取 hugo 和 theme 来生成静态网站，本地的更改就没了。&lt;/p&gt;
&lt;p&gt;写博客时，只需先执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;hugo new post/xxx.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后修改顶部的 FrontMatter&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;---
&lt;span style=&#34;color:#ff79c6&#34;&gt;title&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;my title&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;description&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;my description&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;date&lt;/span&gt;: 2022-02-03T15:01:24&lt;span style=&#34;color:#bd93f9&#34;&gt;+08&lt;/span&gt;:&lt;span style=&#34;color:#bd93f9&#34;&gt;00&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;draft&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;tags&lt;/span&gt;:
    - tag1
&lt;span style=&#34;color:#ff79c6&#34;&gt;categories&lt;/span&gt;:
    - categorie1
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再之后就可以开始创作了。&lt;/p&gt;
&lt;h2 id=&#34;后端&#34;&gt;后端&lt;/h2&gt;
&lt;p&gt;将博客托管在Github Pages上，具体看 &lt;a class=&#34;link&#34; href=&#34;https://pages.github.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官网&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;新建一个public Repository，名字要是 &lt;code&gt;username.github.io&lt;/code&gt;。之后在hugo框架根目录下执行 &lt;code&gt;hugo -D&lt;/code&gt; 在 public 文件夹中生成静态网站，再将 public 文件夹中内容 push 到该 Repository 中即可完成部署。&lt;/p&gt;
&lt;h2 id=&#34;自动化部署&#34;&gt;自动化部署&lt;/h2&gt;
&lt;p&gt;每次部署很麻烦，需要以下步骤：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;hugo -D
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;cd&lt;/span&gt; public
git add .
git commit -m &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;some messages&amp;#34;&lt;/span&gt;
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而且这样想要用git管理源文件有一点麻烦，自然想到使用 GitHub Actions 来完成自动化部署。&lt;/p&gt;
&lt;p&gt;需要先新建一个 Repository 保存博客框架源文件，我取名为 &lt;code&gt;my-hugo-stack&lt;/code&gt;。&lt;code&gt;username.github.io&lt;/code&gt; 这个Repository保存的是静态网站文件，不要混淆。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;my-hugo-stack&lt;/code&gt; 的 &lt;code&gt;Actions&lt;/code&gt; 中，新建一个 &lt;code&gt;workflow&lt;/code&gt; ，点击 configure 写入以下内容&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: ci
&lt;span style=&#34;color:#ff79c6&#34;&gt;on&lt;/span&gt;:
  &lt;span style=&#34;color:#ff79c6&#34;&gt;push&lt;/span&gt;: 
    &lt;span style=&#34;color:#ff79c6&#34;&gt;branches&lt;/span&gt;: 
      - master
      
&lt;span style=&#34;color:#ff79c6&#34;&gt;jobs&lt;/span&gt;:
  &lt;span style=&#34;color:#ff79c6&#34;&gt;build&lt;/span&gt;:
    &lt;span style=&#34;color:#ff79c6&#34;&gt;runs-on&lt;/span&gt;: ubuntu-latest 
    &lt;span style=&#34;color:#ff79c6&#34;&gt;steps&lt;/span&gt;:
      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: checkout 
        &lt;span style=&#34;color:#ff79c6&#34;&gt;uses&lt;/span&gt;: actions/checkout@v2.3.4
        &lt;span style=&#34;color:#ff79c6&#34;&gt;with&lt;/span&gt;:
          &lt;span style=&#34;color:#ff79c6&#34;&gt;submodules&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
          
      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: Setup Hugo
        &lt;span style=&#34;color:#ff79c6&#34;&gt;uses&lt;/span&gt;: peaceiris/actions-hugo@v2
        &lt;span style=&#34;color:#ff79c6&#34;&gt;with&lt;/span&gt;:
          &lt;span style=&#34;color:#ff79c6&#34;&gt;hugo-version&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;0.92.1&amp;#39;&lt;/span&gt;
          &lt;span style=&#34;color:#ff79c6&#34;&gt;extended&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
          
      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: Build
        &lt;span style=&#34;color:#ff79c6&#34;&gt;run&lt;/span&gt;: hugo -D

      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: Add CNAME
        &lt;span style=&#34;color:#ff79c6&#34;&gt;run&lt;/span&gt;: echo &amp;#34;ziannchen.work&amp;#34; &amp;gt; public/CNAME
        
      - &lt;span style=&#34;color:#ff79c6&#34;&gt;name&lt;/span&gt;: Deploy
        &lt;span style=&#34;color:#ff79c6&#34;&gt;uses&lt;/span&gt;: peaceiris/actions-gh-pages@v3
        &lt;span style=&#34;color:#ff79c6&#34;&gt;with&lt;/span&gt;:
          &lt;span style=&#34;color:#ff79c6&#34;&gt;deploy_key&lt;/span&gt;: ${{ secrets.ACTIONS_DEPLOY_KEY }} 
          &lt;span style=&#34;color:#ff79c6&#34;&gt;external_repository&lt;/span&gt;: cza2000/cza2000.github.io  
          &lt;span style=&#34;color:#ff79c6&#34;&gt;publish_branch&lt;/span&gt;: master  
          &lt;span style=&#34;color:#ff79c6&#34;&gt;publish_dir&lt;/span&gt;: ./public 
          &lt;span style=&#34;color:#ff79c6&#34;&gt;commit_message&lt;/span&gt;: ${{ github.event.head_commit.message }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此外还需要新建一对SSH密钥。私钥写入博客源文件仓库的 &lt;code&gt;Settings&lt;/code&gt; - &lt;code&gt;Actions secrets&lt;/code&gt;，命名为 &lt;code&gt;ACTIONS_DEPLOY_KEY&lt;/code&gt;，公钥写入静态网站仓库的 &lt;code&gt;Settings&lt;/code&gt; - &lt;code&gt;Deploy keys&lt;/code&gt;，命名随意。&lt;/p&gt;
&lt;p&gt;之后将本地博客源文件 push 至 &lt;code&gt;my-hugo-stack&lt;/code&gt; 的 master 分支就会触发 action，自动部署并将生成的 public 文件夹内的内容 push 到 &lt;code&gt;username.github.io&lt;/code&gt; 中完成部署。&lt;/p&gt;
&lt;p&gt;由于我买了域名，这样做每次都把我的 CNAME 搞没了，我就在 yml 文件中手动加了一个 step，每次重新生成 CNAME 文件。&lt;/p&gt;
&lt;p&gt;为了更懒一点，又写了个脚本 deploy.sh:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;#!/bin/sh
&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&lt;/span&gt;git add .
&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;msg&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;rebuilding site &lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;$(&lt;/span&gt;date&lt;span style=&#34;color:#ff79c6&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;[&lt;/span&gt; -n &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$*&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;]&lt;/span&gt;; &lt;span style=&#34;color:#ff79c6&#34;&gt;then&lt;/span&gt;
	&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;msg&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$*&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#ff79c6&#34;&gt;fi&lt;/span&gt;
git commit -m &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;$msg&lt;/span&gt;&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#6272a4&#34;&gt;# Push source and build repos.&lt;/span&gt;
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 考虑弄个 CDN&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 加了个访问量统计
&lt;a class=&#34;link&#34; href=&#34;http://ibruce.info/2015/04/04/busuanzi/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;不蒜子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
