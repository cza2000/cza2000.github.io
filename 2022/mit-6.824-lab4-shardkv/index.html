<!DOCTYPE html>
<html lang="zh-CN">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='实现一个基于Raft的分布式KV存储服务，其数据在多个副本组上分片存储'><title>mit-6.824 lab4: ShardKV</title>

<link rel='canonical' href='https://ziannchen.work/2022/mit-6.824-lab4-shardkv/'>

<link rel="stylesheet" href="/scss/style.min.0f551e1e8f12e484db7a1602fcb8eced03029344f0e9cedaf9073100eb80d3e8.css"><meta property='og:title' content='mit-6.824 lab4: ShardKV'>
<meta property='og:description' content='实现一个基于Raft的分布式KV存储服务，其数据在多个副本组上分片存储'>
<meta property='og:url' content='https://ziannchen.work/2022/mit-6.824-lab4-shardkv/'>
<meta property='og:site_name' content='陈子桉的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='分布式系统' /><meta property='article:tag' content='golang' /><meta property='article:tag' content='raft' /><meta property='article:published_time' content='2022-02-04T13:21:03&#43;08:00'/><meta property='article:modified_time' content='2022-02-04T13:21:03&#43;08:00'/><meta property='og:image' content='https://ziannchen.work/img/avatar.png' />
<meta name="twitter:title" content="mit-6.824 lab4: ShardKV">
<meta name="twitter:description" content="实现一个基于Raft的分布式KV存储服务，其数据在多个副本组上分片存储"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://ziannchen.work/img/avatar.png' />
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
        <a href="/categories/mit-6.824/" >
            mit-6.824
        </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/2022/mit-6.824-lab4-shardkv/">mit-6.824 lab4: ShardKV</a>
    </h2>

    
    <h3 class="article-subtitle">
        实现一个基于Raft的分布式KV存储服务，其数据在多个副本组上分片存储
    </h3>
    

    
    <footer class="article-time">
        
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
            <time class="article-time--published">Feb 04, 2022</time>
        </div>
        

        
        <div>
            <time class="article-words">
                4909字
            </time>
        </div>
        
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



            <span id="busuanzi_container_page_pv" style='display:none'>
                本文总访问量<span id="busuanzi_value_page_pv"></span>次
            </span>
        </div>
    </footer>
    
</div>
</header>

    <section class="article-content">
    
    
    <p>lab课程网址 <a class="link" href="https://pdos.csail.mit.edu/6.824/labs/lab-shard.html"  target="_blank" rel="noopener"
    >https://pdos.csail.mit.edu/6.824/labs/lab-shard.html</a></p>
<p>本次lab是最难的一次lab，很多地方需要我们自由发挥，不像lab2那样可以参考论文。</p>
<p>Lab2和Lab3构成基础分布式数据库的框架，实现了多节点间的数据一致性，支持crud，数据同步和快照保存。然而，由于所有的请求都需要由 leader 来处理，当数据增长到一定程度时，若仍然使用单一集群服务所有数据，leader面对的压力会非常大，请求响应时间也会延长，磁盘空间也会不足。在这种模式下，增加机器并不会带来性能的提升，反而存在浪费。一个非常直接的解决方法，就是将数据按照某种方式分开存储到不同的集群上，将不同的请求引流到不同的集群，降低单一集群的压力，提供更为高效、更为健壮的服务。</p>
<p>Lab4就是要实现数据的划分，将不同的数据划分到不同的集群上，保证相应数据请求引流到对应的集群。这里，将互不相交并且组成完整数据的每一个数据子集称为 Shard。在同一阶段中，Shard 与集群的对应关系称为 Config，随着时间的推移，增加或减少机器、某个 Shard 中的数据请求过热，Shard 需要在不同集群之中进行迁移。如何在 Config更新、 Shard 迁移的同时仍能正确对外提供强一致性的服务，是lab4主要挑战。</p>
<p>一个集群只有Leader才能服务，系统的性能与集群的数量成正比。lab3是一个集群，lab4要实现的是多个集群之间的配合。</p>
<p>我画了一个 ShardKV 最终的结构图</p>
<p><figure 
	>
	<a href="/img/ShardKV/1.png" >
		<img src="/img/ShardKV/1.png"
			
			
			
			loading="lazy"
			alt="图片 1">
	</a>
	
	<figcaption>图片 1</figcaption>
	
</figure></p>
<h2 id="shardctrler">ShardCtrler</h2>
<p>Client 在向 Server 发送RPC之前，需要先知道目标 key 所在的 Shard 位于哪一个 Group，以及如何和这个 Group 中的leader通信。这就需要有一个地方保存 shard -&gt; gid 和 gid -&gt; server 信息，这就是lab4A中需要实现的 ShardCtrler，它使用 Config 结构保存这些信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6272a4">// A configuration -- an assignment of shards to groups.
</span><span style="color:#6272a4">// Please don&#39;t change this.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Config <span style="color:#8be9fd;font-style:italic">struct</span> {
	Num    <span style="color:#8be9fd">int</span>              <span style="color:#6272a4">// config number
</span><span style="color:#6272a4"></span>	Shards [NShards]<span style="color:#8be9fd">int</span>     <span style="color:#6272a4">// shard -&gt; gid
</span><span style="color:#6272a4"></span>	Groups <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>][]<span style="color:#8be9fd">string</span> <span style="color:#6272a4">// gid -&gt; servers[]
</span><span style="color:#6272a4"></span>}
</code></pre></div><p>每次 shard -&gt; gid 的对应关系被更改时，ShardCtrler 创建一个新的 Config 保存新的对应关系。ShardCtrler 支持Join、Leave、Move、Query 4种RPC来添加新的 Group、删除 Group，在 Group 之间移动 Shard 以及查询对应 Num 的 Config，底层也使用Raft协议在多台机器上进行数据同步。因此整体实现和lab3类似。</p>
<h3 id="client">Client</h3>
<p>为了简化逻辑4种请求共用一个RPC，也需要加上 ClientID 和 RequestID 让 server 端能够去重。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">type</span> CommandRequest <span style="color:#8be9fd;font-style:italic">struct</span> {
	ClientID  <span style="color:#8be9fd">int</span>
	RequestID <span style="color:#8be9fd">int</span>
	OpType
	JoinArgs
	LeaveArgs
	MoveArgs
	QueryArgs
}

<span style="color:#8be9fd;font-style:italic">type</span> CommandResponse <span style="color:#8be9fd;font-style:italic">struct</span> {
	Err         Err
	Config      Config
}

<span style="color:#8be9fd;font-style:italic">type</span> JoinArgs <span style="color:#8be9fd;font-style:italic">struct</span> {
	Servers   <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>][]<span style="color:#8be9fd">string</span> <span style="color:#6272a4">// new GID -&gt; servers mappings
</span><span style="color:#6272a4"></span>}

<span style="color:#8be9fd;font-style:italic">type</span> LeaveArgs <span style="color:#8be9fd;font-style:italic">struct</span> {
	GIDs      []<span style="color:#8be9fd">int</span>
}

<span style="color:#8be9fd;font-style:italic">type</span> MoveArgs <span style="color:#8be9fd;font-style:italic">struct</span> {
	Shard     <span style="color:#8be9fd">int</span>
	GID       <span style="color:#8be9fd">int</span>
}

<span style="color:#8be9fd;font-style:italic">type</span> QueryArgs <span style="color:#8be9fd;font-style:italic">struct</span> {
	Num       <span style="color:#8be9fd">int</span> <span style="color:#6272a4">// desired config number
</span><span style="color:#6272a4"></span>}
</code></pre></div><h3 id="server">Server</h3>
<p>对于RPC的处理模型和lab3是一样的，由于Config数据较小，还不用处理快照。</p>
<h4 id="join">Join</h4>
<p><code>Join</code> 操作向当前配置中新增一些server，这些server可能被加入现有的 Group 中，也可能是新增的 Group。</p>
<p>新增的 Group 还没有 Shard，需要在 <code>Groups</code> 中对 <code>Shards</code> 进行平衡并且要产生尽可能少的 Shard 迁移，平衡的方法是每次循环让拥有 Shard 最多的 Group 分一个给拥有 Shard 最少的 Group，直到它们之间的差值小等于1。</p>
<p>ShardCtrler 刚启动时还没有 Config 信息，第一次执行 <code>Join</code> 时所有的 Shard 还未被分配到具体的 Group 上，对应的 gid 是0，我称为 <code>zombieShard</code>。因此在处理 <code>Join</code> 时也要分配可能存在的 <code>zombieShard</code>。此外maps数据需要深拷贝。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (sc <span style="color:#ff79c6">*</span>ShardCtrler) <span style="color:#50fa7b">executeJoin</span>(servers <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>][]<span style="color:#8be9fd">string</span>) {
	length <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">len</span>(sc.configs)
	lastConfig <span style="color:#ff79c6">:=</span> sc.configs[length<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]

	newGroups <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">deepCopy</span>(lastConfig.Groups)
	<span style="color:#ff79c6">for</span> gid, servers <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> servers {
		newGroups[gid] = servers
	}
	newConfig <span style="color:#ff79c6">:=</span> Config{
		Num:    length,
		Shards: [NShards]<span style="color:#8be9fd">int</span>{},
		Groups: newGroups,
	}

	groupToShards <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">getGroupToShards</span>(newGroups, lastConfig.Shards)
	zombieShards <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">int</span>{}
	<span style="color:#ff79c6">for</span> shard, gid <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> lastConfig.Shards {
		<span style="color:#ff79c6">if</span> gid <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
			zombieShards = <span style="color:#8be9fd;font-style:italic">append</span>(zombieShards, shard)
		}
	}

	<span style="color:#ff79c6">for</span> _, shard <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> zombieShards {
		target <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">getMinGroup</span>(groupToShards)
		groupToShards[target] = <span style="color:#8be9fd;font-style:italic">append</span>(groupToShards[target], shard)
	}

	groupToShards = <span style="color:#50fa7b">balanceShardBetweenGroups</span>(groupToShards)
	<span style="color:#ff79c6">for</span> gid, shards <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> groupToShards {
		<span style="color:#ff79c6">for</span> _, shard <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> shards {
			newConfig.Shards[shard] = gid
		}
	}

	sc.configs = <span style="color:#8be9fd;font-style:italic">append</span>(sc.configs, newConfig)
}
</code></pre></div><h4 id="leave">Leave</h4>
<p>Group 被删除后，其原先拥有的 Shard 就成了 <code>zombieShard</code>，应当依次分配被拥有 Shard 数量最少的 Group。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (sc <span style="color:#ff79c6">*</span>ShardCtrler) <span style="color:#50fa7b">executeLeave</span>(GIDs []<span style="color:#8be9fd">int</span>) {
	length <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">len</span>(sc.configs)
	lastConfig <span style="color:#ff79c6">:=</span> sc.configs[length<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]
	newGroups <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">deepCopy</span>(lastConfig.Groups)

	newConfig <span style="color:#ff79c6">:=</span> Config{
		Num:    length,
		Shards: [NShards]<span style="color:#8be9fd">int</span>{},
		Groups: newGroups,
	}

	groupToShards <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">getGroupToShards</span>(newGroups, lastConfig.Shards)
	zombieShards <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">int</span>{}
	<span style="color:#ff79c6">for</span> _, gid <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> GIDs {
		<span style="color:#8be9fd;font-style:italic">delete</span>(newConfig.Groups, gid)
		<span style="color:#ff79c6">if</span> shards, ok <span style="color:#ff79c6">:=</span> groupToShards[gid]; ok {
			zombieShards = <span style="color:#8be9fd;font-style:italic">append</span>(zombieShards, shards<span style="color:#ff79c6">...</span>)
			<span style="color:#8be9fd;font-style:italic">delete</span>(groupToShards, gid)
		}
	}

	<span style="color:#ff79c6">for</span> _, shard <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> zombieShards {
		target <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">getMinGroup</span>(groupToShards)
		groupToShards[target] = <span style="color:#8be9fd;font-style:italic">append</span>(groupToShards[target], shard)
	}

	<span style="color:#ff79c6">for</span> gid, shards <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> groupToShards {
		<span style="color:#ff79c6">for</span> _, shard <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> shards {
			newConfig.Shards[shard] = gid
		}
	}

	sc.configs = <span style="color:#8be9fd;font-style:italic">append</span>(sc.configs, newConfig)
}
</code></pre></div><h4 id="move">Move</h4>
<p>将指定的 Shard 交由新的 Group 负责，只需要改动 <code>Shards</code> 数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (sc <span style="color:#ff79c6">*</span>ShardCtrler) <span style="color:#50fa7b">executeMove</span>(shard <span style="color:#8be9fd">int</span>, gid <span style="color:#8be9fd">int</span>) {
	length <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">len</span>(sc.configs)
	lastConfig <span style="color:#ff79c6">:=</span> sc.configs[length<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]
	newGroups <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">deepCopy</span>(lastConfig.Groups)

	newConfig <span style="color:#ff79c6">:=</span> Config{
		Num:    length,
		Shards: lastConfig.Shards,
		Groups: newGroups,
	}

	newConfig.Shards[shard] = gid
	sc.configs = <span style="color:#8be9fd;font-style:italic">append</span>(sc.configs, newConfig)
}
</code></pre></div><h4 id="query">Query</h4>
<p><code>Query</code> 查询指定版本的 Config。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (sc <span style="color:#ff79c6">*</span>ShardCtrler) <span style="color:#50fa7b">executeQuery</span>(num <span style="color:#8be9fd">int</span>) Config {
	length <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">len</span>(sc.configs)
	config <span style="color:#ff79c6">:=</span> Config{}
	<span style="color:#ff79c6">if</span> num <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span> <span style="color:#ff79c6">||</span> num <span style="color:#ff79c6">&gt;=</span> length {
		config = sc.configs[length<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]
	} <span style="color:#ff79c6">else</span> {
		config = sc.configs[num]
	}

	newGroups <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">deepCopy</span>(config.Groups)
	newConfig <span style="color:#ff79c6">:=</span> Config{
		Num:    config.Num,
		Shards: config.Shards,
		Groups: newGroups,
	}

	<span style="color:#ff79c6">return</span> newConfig
}
</code></pre></div><h3 id="测试结果">测试结果</h3>
<pre tabindex="0"><code class="language-log" data-lang="log">Test: Basic leave/join ...
  ... Passed
Test: Historical queries ...
  ... Passed
Test: Move ...
  ... Passed
Test: Concurrent leave/join ...
  ... Passed
Test: Minimal transfers after joins ...
  ... Passed
Test: Minimal transfers after leaves ...
  ... Passed
Test: Multi-group join/leave ...
  ... Passed
Test: Concurrent multi leave/join ...
  ... Passed
Test: Minimal transfers after multijoins ...
  ... Passed
Test: Minimal transfers after multileaves ...
  ... Passed
Test: Check Same config on servers ...
  ... Passed
PASS
ok  	6.824/shardctrler	5.641s
</code></pre><h2 id="shardkv">ShardKV</h2>
<h3 id="整体结构">整体结构</h3>
<p><code>ShardKV</code> 的状态机 db 由多个 Shard 组成，每个 Shard 包含了自己的状态、kv和客户端请求去重表，这使得不同的 Shard 之间可以在独立迁移的同时不影响未受影响的 Shard 对外正常提供服务，也可以通过 Shard 的状态来进行许多判断，每个状态的含义在注释中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">type</span> ShardKV <span style="color:#8be9fd;font-style:italic">struct</span> {
	mu           sync.RWMutex
	me           <span style="color:#8be9fd">int</span>
	rf           <span style="color:#ff79c6">*</span>raft.Raft
	applyCh      <span style="color:#8be9fd;font-style:italic">chan</span> raft.ApplyMsg
	make_end     <span style="color:#8be9fd;font-style:italic">func</span>(<span style="color:#8be9fd">string</span>) <span style="color:#ff79c6">*</span>labrpc.ClientEnd
	gid          <span style="color:#8be9fd">int</span>
	ctrlers      []<span style="color:#ff79c6">*</span>labrpc.ClientEnd
	maxraftstate <span style="color:#8be9fd">int</span> <span style="color:#6272a4">// snapshot if log grows this big
</span><span style="color:#6272a4"></span>
	<span style="color:#6272a4">// Your definitions here.
</span><span style="color:#6272a4"></span>	prevConfig       shardctrler.Config
	currConfig       shardctrler.Config
	persister        <span style="color:#ff79c6">*</span>raft.Persister
	scClerk          <span style="color:#ff79c6">*</span>shardctrler.Clerk
	waitChs      	 <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>]<span style="color:#8be9fd;font-style:italic">chan</span> CommandResponse
	db               <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>]<span style="color:#ff79c6">*</span>Shard
	lastAppliedIndex <span style="color:#8be9fd">int</span>
}

<span style="color:#8be9fd;font-style:italic">type</span> ShardStatus <span style="color:#8be9fd">int</span>

<span style="color:#8be9fd;font-style:italic">const</span> (
	<span style="color:#6272a4">// The group serves and owns the shard.
</span><span style="color:#6272a4"></span>	Serving ShardStatus = <span style="color:#ff79c6">iota</span>
	<span style="color:#6272a4">// The group serves the shard, but does not own the shard yet.
</span><span style="color:#6272a4"></span>	Pulling
	<span style="color:#6272a4">// The group does not serve and own the partition.
</span><span style="color:#6272a4"></span>	Invalid
	<span style="color:#6272a4">// The group owns but does not serve the shard.
</span><span style="color:#6272a4"></span>	Erasing
	<span style="color:#6272a4">// The group own the shard and serve it, but it&#39;s waiting for ex-owner to delete it
</span><span style="color:#6272a4"></span>	Waiting
)

<span style="color:#8be9fd;font-style:italic">type</span> Shard <span style="color:#8be9fd;font-style:italic">struct</span> {
	Status       ShardStatus
	KV           <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#8be9fd">string</span>
	LastSessions <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>]<span style="color:#ff79c6">*</span>Session
}
</code></pre></div><p>leader需要执行多个定时任务，需要在后台启动协程来循环判断状态、执行任务、睡眠。我抽象出了一个 <code>daemon</code> 函数来完成这些。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">StartServer</span>(servers []<span style="color:#ff79c6">*</span>labrpc.ClientEnd, me <span style="color:#8be9fd">int</span>, persister <span style="color:#ff79c6">*</span>raft.Persister, maxraftstate <span style="color:#8be9fd">int</span>, gid <span style="color:#8be9fd">int</span>, ctrlers []<span style="color:#ff79c6">*</span>labrpc.ClientEnd, make_end <span style="color:#8be9fd;font-style:italic">func</span>(<span style="color:#8be9fd">string</span>) <span style="color:#ff79c6">*</span>labrpc.ClientEnd) <span style="color:#ff79c6">*</span>ShardKV {
	···
	<span style="color:#6272a4">// Your initialization code here.
</span><span style="color:#6272a4"></span>
	<span style="color:#6272a4">// Use something like this to talk to the shardctrler:
</span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// kv.mck = shardctrler.MakeClerk(kv.ctrlers)
</span><span style="color:#6272a4"></span>	kv.applyCh = <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> raft.ApplyMsg)
	kv.rf = raft.<span style="color:#50fa7b">Make</span>(servers, me, persister, kv.applyCh)
	kv.scClerk = shardctrler.<span style="color:#50fa7b">MakeClerk</span>(kv.ctrlers)
	kv.mu = sync.RWMutex{}
	kv.waitChs = <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>]<span style="color:#8be9fd;font-style:italic">chan</span> CommandResponse)
	kv.db = <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>]<span style="color:#ff79c6">*</span>Shard)
	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; shardctrler.NShards; i<span style="color:#ff79c6">++</span> {
		kv.db[i] = <span style="color:#ff79c6">&amp;</span>Shard{
			Status:       Invalid,
			KV:           <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#8be9fd">string</span>),
			LastSessions: <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>]<span style="color:#ff79c6">*</span>Session),
		}
	}

	kv.lastAppliedIndex = <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>
	kv.prevConfig = shardctrler.Config{}
	kv.currConfig = shardctrler.Config{}
	kv.<span style="color:#50fa7b">applySnapshot</span>(persister.<span style="color:#50fa7b">ReadSnapshot</span>())

	<span style="color:#ff79c6">go</span> kv.<span style="color:#50fa7b">applier</span>()
	<span style="color:#ff79c6">go</span> kv.<span style="color:#50fa7b">daemon</span>(kv.fetchConfig)
	<span style="color:#ff79c6">go</span> kv.<span style="color:#50fa7b">daemon</span>(kv.pullData)
	<span style="color:#ff79c6">go</span> kv.<span style="color:#50fa7b">daemon</span>(kv.eraseData)
	<span style="color:#ff79c6">go</span> kv.<span style="color:#50fa7b">daemon</span>(kv.proposeEmpty)
	<span style="color:#ff79c6">return</span> kv
}

<span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>ShardKV) <span style="color:#50fa7b">daemon</span>(action <span style="color:#8be9fd;font-style:italic">func</span>()) {
	<span style="color:#ff79c6">for</span> !kv.<span style="color:#50fa7b">killed</span>() {
		<span style="color:#ff79c6">if</span> _, isLeader <span style="color:#ff79c6">:=</span> kv.rf.<span style="color:#50fa7b">GetState</span>(); isLeader {
			<span style="color:#50fa7b">action</span>()
		}

		time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">50</span> <span style="color:#ff79c6">*</span> time.Millisecond)
	}
}
</code></pre></div><p>applier 的结构和lab3类似，日志被 commit 之后根据 CommandType 的不同执行不同的applyxxx，其中 <code>EraseData</code> 和 <code>ClientRequest</code> 需要返回 response。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">type</span> CommandType <span style="color:#8be9fd">int</span>

<span style="color:#8be9fd;font-style:italic">const</span> (
	ClientRequest CommandType = <span style="color:#ff79c6">iota</span>
	ConfChange
	InsertData
	EraseData
	StopWaiting
	Empty
)

<span style="color:#8be9fd;font-style:italic">type</span> RaftLogCommand <span style="color:#8be9fd;font-style:italic">struct</span> {
	CommandType
	Data <span style="color:#8be9fd;font-style:italic">interface</span>{}
}

<span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">newRaftLogCommand</span>(commandType CommandType, data <span style="color:#8be9fd;font-style:italic">interface</span>{}) RaftLogCommand {
	<span style="color:#ff79c6">return</span> RaftLogCommand{
		CommandType: commandType,
		Data: data,
	}
}

<span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>ShardKV) <span style="color:#50fa7b">applier</span>() {
	<span style="color:#ff79c6">for</span> !kv.<span style="color:#50fa7b">killed</span>() {
		<span style="color:#ff79c6">select</span> {
		<span style="color:#ff79c6">case</span> applyMsg <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>kv.applyCh:
			<span style="color:#ff79c6">if</span> applyMsg.CommandValid {
				command <span style="color:#ff79c6">:=</span> applyMsg.Command.(RaftLogCommand)
				kv.mu.<span style="color:#50fa7b">Lock</span>()

				<span style="color:#ff79c6">if</span> applyMsg.CommandIndex <span style="color:#ff79c6">&lt;=</span> kv.lastAppliedIndex {
					<span style="color:#50fa7b">DPrintf</span>(<span style="color:#f1fa8c">&#34;[Group %d][Server %d] discard out-of-date apply Msg [index %d]&#34;</span>, kv.gid, kv.me, applyMsg.CommandIndex)
					kv.mu.<span style="color:#50fa7b">Unlock</span>()
					<span style="color:#ff79c6">continue</span>
				}

				kv.lastAppliedIndex = applyMsg.CommandIndex
				response <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>CommandResponse{}
				<span style="color:#ff79c6">switch</span> command.CommandType {
				<span style="color:#ff79c6">case</span> Empty:
					<span style="color:#50fa7b">DPrintf</span>(<span style="color:#f1fa8c">&#34;[Group %d][Server %d] get empty in apply Msg [index %d]&#34;</span>, kv.gid, kv.me, applyMsg.CommandIndex)
				<span style="color:#ff79c6">case</span> ConfChange:
					lastestConf <span style="color:#ff79c6">:=</span> command.Data.(shardctrler.Config)
					kv.<span style="color:#50fa7b">applyConfChange</span>(lastestConf, applyMsg.CommandIndex)

				<span style="color:#ff79c6">case</span> InsertData:
					resp <span style="color:#ff79c6">:=</span> command.Data.(PullDataResponse)
					kv.<span style="color:#50fa7b">applyInsertData</span>(resp, applyMsg.CommandIndex)

				<span style="color:#ff79c6">case</span> StopWaiting:
					req <span style="color:#ff79c6">:=</span> command.Data.(EraseDataRequest)
					kv.<span style="color:#50fa7b">applyStopWaiting</span>(req, applyMsg.CommandIndex)

				<span style="color:#ff79c6">case</span> EraseData:
					req <span style="color:#ff79c6">:=</span> command.Data.(EraseDataRequest)
					response = kv.<span style="color:#50fa7b">applyEraseData</span>(req, applyMsg.CommandIndex)
					<span style="color:#ff79c6">if</span> currentTerm, isLeader <span style="color:#ff79c6">:=</span> kv.rf.<span style="color:#50fa7b">GetState</span>(); currentTerm <span style="color:#ff79c6">==</span> applyMsg.CommandTerm <span style="color:#ff79c6">&amp;&amp;</span> isLeader {
						ch <span style="color:#ff79c6">:=</span> kv.<span style="color:#50fa7b">getWaitCh</span>(applyMsg.CommandIndex)
						ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#ff79c6">*</span>response
					}

				<span style="color:#ff79c6">case</span> ClientRequest:
					request <span style="color:#ff79c6">:=</span> command.Data.(CommandRequest)
					response = kv.<span style="color:#50fa7b">applyClientRequest</span>(<span style="color:#ff79c6">&amp;</span>request, applyMsg.CommandIndex)
					<span style="color:#ff79c6">if</span> currentTerm, isLeader <span style="color:#ff79c6">:=</span> kv.rf.<span style="color:#50fa7b">GetState</span>(); currentTerm <span style="color:#ff79c6">==</span> applyMsg.CommandTerm <span style="color:#ff79c6">&amp;&amp;</span> isLeader {
						ch <span style="color:#ff79c6">:=</span> kv.<span style="color:#50fa7b">getWaitCh</span>(applyMsg.CommandIndex)
						ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#ff79c6">*</span>response
					}
				}

				<span style="color:#ff79c6">if</span> kv.<span style="color:#50fa7b">needToSnapshot</span>(applyMsg.RaftStateSize) {
					<span style="color:#50fa7b">DPrintf</span>(<span style="color:#f1fa8c">&#34;[Group %d][Server %d] take a snapshot till [index %d]&#34;</span>, kv.gid, kv.me, applyMsg.CommandIndex)
					kv.<span style="color:#50fa7b">takeSnapshot</span>(applyMsg.CommandIndex)
				}

				kv.mu.<span style="color:#50fa7b">Unlock</span>()
			} <span style="color:#ff79c6">else</span> {
				kv.mu.<span style="color:#50fa7b">Lock</span>()
				<span style="color:#50fa7b">DPrintf</span>(<span style="color:#f1fa8c">&#34;[Group %d][Server %d] received a snapshot from raft layer [index %d]&#34;</span>, kv.gid, kv.me, applyMsg.SnapshotIndex)
				<span style="color:#ff79c6">if</span> kv.rf.<span style="color:#50fa7b">CondInstallSnapshot</span>(applyMsg.SnapshotTerm, applyMsg.SnapshotIndex, applyMsg.Snapshot) {
					kv.<span style="color:#50fa7b">applySnapshot</span>(applyMsg.Snapshot)
					kv.lastAppliedIndex = applyMsg.SnapshotIndex
				}

				kv.mu.<span style="color:#50fa7b">Unlock</span>()
			}
		}
	}
}
</code></pre></div><h3 id="客户端请求">客户端请求</h3>
<p>这里和lab3基本一样，不同的是 handle RPC 以及日志apply时都需要额外判断在当前版本的 Config 下本 Group 是否负责该 key 所属的 Shard。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>ShardKV) <span style="color:#50fa7b">isShardMatch</span>(shardId <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">bool</span> {
	<span style="color:#ff79c6">return</span> kv.currConfig.Shards[shardId] <span style="color:#ff79c6">==</span> kv.gid <span style="color:#ff79c6">&amp;&amp;</span> (kv.db[shardId].Status <span style="color:#ff79c6">==</span> Serving <span style="color:#ff79c6">||</span> kv.db[shardId].Status <span style="color:#ff79c6">==</span> Waiting)
}
</code></pre></div><h3 id="配置更新">配置更新</h3>
<p>每个 Group 中的 leader 需要在后台启动一个协程向 ShardCtrler 定时使用 <code>Query</code> 拉取最新的 Config，一旦拉取到就需要提交一条 raft 日志，以在每台机器上更新配置。</p>
<p>此外，每次只能拉取高一个版本的配置，而且为了防止集群的分片状态被覆盖，从而使得某些任务永远不会被执行，只有在每一 Shard 的状态都为 <code>Serving</code> 或 <code>Invalid</code> 时才能拉取、更新配置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>ShardKV) <span style="color:#50fa7b">fetchConfig</span>() {
	canFetchConf <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">true</span>
	kv.mu.<span style="color:#50fa7b">RLock</span>()
	currConfNum <span style="color:#ff79c6">:=</span> kv.currConfig.Num
	<span style="color:#ff79c6">for</span> shardId, shard <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> kv.db {
		<span style="color:#ff79c6">if</span> shard.Status <span style="color:#ff79c6">!=</span> Serving <span style="color:#ff79c6">&amp;&amp;</span> shard.Status <span style="color:#ff79c6">!=</span> Invalid {
			canFetchConf = <span style="color:#ff79c6">false</span>
			<span style="color:#ff79c6">break</span>
		}
	}

	kv.mu.<span style="color:#50fa7b">RUnlock</span>()
	<span style="color:#ff79c6">if</span> canFetchConf {
		latestConfig <span style="color:#ff79c6">:=</span> kv.scClerk.<span style="color:#50fa7b">Query</span>(currConfNum <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>)
		<span style="color:#ff79c6">if</span> latestConfig.Num <span style="color:#ff79c6">==</span> currConfNum<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span> {
			kv.rf.<span style="color:#50fa7b">Start</span>(<span style="color:#50fa7b">newRaftLogCommand</span>(ConfChange, latestConfig))
		}
	}
}
</code></pre></div><p>在每台机器上，新配置对应的 raft 日志被 commit 之后，都需要更新本地的 <code>prevConfig</code> 和 <code>currConfig</code>，以及更新 db 中对应的 Shard 状态，以便让数据拉取、数据清理协程能检测到去进行数据迁移。</p>
<p>在新版本的 Config 中新增的 Shard 状态改为 Pulling，等待拉取数据协程去其他 Group 上拉数据。失去的 Shard 状态改为 Erasing，等待其他 Group 来拉取数据。若当前 Config 的版本为1，则代表集群刚初始化，不需要去其他 Group 拉取数据，只需更改对应的 Shard 状态为 Serving。</p>
<h3 id="数据拉取">数据拉取</h3>
<p>新的 Config 在 applier 协程中被应用并不表示所属分片可以立刻对外提供服务，还需要等待在上一个版本的 Config 中不属于自身的 Shard 从它之前所属的 Group 中迁移到本 Group。</p>
<p>这里显然不能在配置更新时同步阻塞的去拉取 Shard，这会阻塞 applier 协程，严重影响对外服务的可用性。那么是否可以异步的去拉取数据并提交日志？其实不行，leader 可能会在 apply 新配置之后到新数据被异步拉取到并提交日志之前宕机，而 follower 虽然会 apply 配置但是不会去拉数据，这样这些数据将永远无法被更新。</p>
<p>因此，我们不能在 apply 配置的时候启动异步任务，而是应该只更新 shard 的状态，由单独的后台协程去检测每个 Shard 的状态，从而判断是否需要并执行分片迁移，分片清理等任务。为了让单独的协程能知道该向哪个 Group 去拉取数据或让它去删除数据，<code>ShardKV</code> 需要维护 currConfig 和 prevConfig，这样其他协程能够通过它们来得知所有 Shard 的 ex-owner。</p>
<p>需要定义新的RPC来完成数据拉取。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">type</span> PullDataRequest <span style="color:#8be9fd;font-style:italic">struct</span> {
	ConfNum  <span style="color:#8be9fd">int</span>
	ShardIds []<span style="color:#8be9fd">int</span>
}

<span style="color:#8be9fd;font-style:italic">type</span> PullDataResponse <span style="color:#8be9fd;font-style:italic">struct</span> {
	Err     Err
	ConfNum <span style="color:#8be9fd">int</span>
	Shards  <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>]<span style="color:#ff79c6">*</span>Shard
}
</code></pre></div><p>并行向状态为 <code>Pulling</code> 的不同 Shard 的 ex-owner 发送RPC来拉取数据，使用 waitGroup 来保证尝试拉取了一遍当前版本的配置所需要的所有 Shard 之后才能进行下一轮循环。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>ShardKV) <span style="color:#50fa7b">pullData</span>() {
	kv.mu.<span style="color:#50fa7b">RLock</span>()
	groupToShards <span style="color:#ff79c6">:=</span> kv.<span style="color:#50fa7b">getGroupToShards</span>(Pulling)
	currConfNum <span style="color:#ff79c6">:=</span> kv.currConfig.Num
	wg <span style="color:#ff79c6">:=</span> sync.WaitGroup{}
	<span style="color:#ff79c6">for</span> gid, shards <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> groupToShards {
		wg.<span style="color:#50fa7b">Add</span>(<span style="color:#bd93f9">1</span>)
		servers <span style="color:#ff79c6">:=</span> kv.prevConfig.Groups[gid]
		<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>(servers []<span style="color:#8be9fd">string</span>, shards []<span style="color:#8be9fd">int</span>, confNum <span style="color:#8be9fd">int</span>) {
			<span style="color:#ff79c6">defer</span> wg.<span style="color:#50fa7b">Done</span>()
			<span style="color:#ff79c6">for</span> _, server <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> servers {
				shardOwner <span style="color:#ff79c6">:=</span> kv.<span style="color:#50fa7b">make_end</span>(server)
				args <span style="color:#ff79c6">:=</span> PullDataRequest{
					ConfNum:  confNum,
					ShardIds: shards,
				}

				reply <span style="color:#ff79c6">:=</span> PullDataResponse{}
				<span style="color:#ff79c6">if</span> shardOwner.<span style="color:#50fa7b">Call</span>(<span style="color:#f1fa8c">&#34;ShardKV.PullData&#34;</span>, <span style="color:#ff79c6">&amp;</span>args, <span style="color:#ff79c6">&amp;</span>reply) <span style="color:#ff79c6">&amp;&amp;</span> reply.Err <span style="color:#ff79c6">==</span> OK {
					kv.rf.<span style="color:#50fa7b">Start</span>(<span style="color:#50fa7b">newRaftLogCommand</span>(InsertData, resp))
					<span style="color:#ff79c6">break</span>
				}
			}
		}(servers, shards, currConfNum)
	}

	kv.mu.<span style="color:#50fa7b">RUnlock</span>()
	wg.<span style="color:#50fa7b">Wait</span>()
}
</code></pre></div><p>数据的被拉取方在处理 RPC 时，只有在 PullDataRequest 中的配置版本与自身的配置版本相同时，才回应其需要的 Shard 信息。需要注意正确的对所有 Shard 深拷贝。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>ShardKV) <span style="color:#50fa7b">PullData</span>(args <span style="color:#ff79c6">*</span>PullDataRequest, reply <span style="color:#ff79c6">*</span>PullDataResponse) {
	<span style="color:#ff79c6">defer</span> <span style="color:#50fa7b">DPrintf</span>(<span style="color:#f1fa8c">&#34;[Group %d][Server %d] reply %s for PULL DATA request %s&#34;</span>, kv.gid, kv.me, reply, args)
	<span style="color:#50fa7b">DPrintf</span>(<span style="color:#f1fa8c">&#34;[Group %d][Server %d] received a PULL DATA request %s&#34;</span>, kv.gid, kv.me, args)
	<span style="color:#ff79c6">if</span> _, isLeader <span style="color:#ff79c6">:=</span> kv.rf.<span style="color:#50fa7b">GetState</span>(); !isLeader {
		reply.Err = ErrWrongLeader
		<span style="color:#ff79c6">return</span>
	}

	kv.mu.<span style="color:#50fa7b">RLock</span>()
	<span style="color:#ff79c6">defer</span> kv.mu.<span style="color:#50fa7b">RUnlock</span>()

	<span style="color:#ff79c6">if</span> kv.currConfig.Num &lt; args.ConfNum {
		reply.Err = ErrNotReady
		<span style="color:#ff79c6">return</span>
	}

	<span style="color:#ff79c6">if</span> kv.currConfig.Num &gt; args.ConfNum {
		<span style="color:#8be9fd;font-style:italic">panic</span>(<span style="color:#f1fa8c">&#34;duplicated pull data request&#34;</span>)
	}

	replyShards <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>]<span style="color:#ff79c6">*</span>Shard)

	<span style="color:#ff79c6">for</span> _, shardId <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> args.ShardIds {
		shard <span style="color:#ff79c6">:=</span> kv.db[shardId]
		replyShards[shardId] = <span style="color:#50fa7b">deepCopyShard</span>(shard)
	}

	reply.ConfNum = kv.currConfig.Num
	reply.Shards = replyShards
	reply.Err = OK
}
</code></pre></div><p>在 applyInsertData 时，为了保证集群数据变更的幂等性，要保证 Config 的版本与当前版本相同时以及其 Shard 的本地状态为 <code>Pulling</code> 时才能更新 Shard 的状态。将其状态改为 <code>Waiting</code> 让数据清理协程去检测。</p>
<h3 id="数据清理">数据清理</h3>
<h4 id="current-owner">current owner</h4>
<p>在完成数据拉取之后，需要清理掉每个新拉到的 Shard 对应的 ex-owner 机器上的旧数据。后台协程检查所有状态为 <code>Waiting</code> 的 Shard，并行向它们的 ex-owners 分别发送 RPC，告知它们：我已拉取到我要的数据，现在你可以把它们（对应的 Shard 状态为 Erasing）删了。这里 waitGroup 的用法同上。</p>
<p>RPC返回且得知 ex-owners 上的数据清理已经完成后需要提交一条 <code>StopWaiting</code> 类型的 raft 日志，将这个信息同步到 Group 内所有机器上。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">type</span> EraseDataRequest <span style="color:#8be9fd;font-style:italic">struct</span> {
	ConfNum  <span style="color:#8be9fd">int</span>
	ShardIDs []<span style="color:#8be9fd">int</span>
}

<span style="color:#8be9fd;font-style:italic">type</span> EraseDataResponse <span style="color:#8be9fd;font-style:italic">struct</span> {
	Err Err
}

<span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>ShardKV) <span style="color:#50fa7b">eraseData</span>() {
	kv.mu.<span style="color:#50fa7b">RLock</span>()
	groupToShards <span style="color:#ff79c6">:=</span> kv.<span style="color:#50fa7b">getGroupToShards</span>(Waiting)
	currConfNum <span style="color:#ff79c6">:=</span> kv.currConfig.Num
	wg <span style="color:#ff79c6">:=</span> sync.WaitGroup{}
	<span style="color:#ff79c6">for</span> gid, shards <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> groupToShards {
		wg.<span style="color:#50fa7b">Add</span>(<span style="color:#bd93f9">1</span>)
		servers <span style="color:#ff79c6">:=</span> kv.prevConfig.Groups[gid]
		<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>(servers []<span style="color:#8be9fd">string</span>, shards []<span style="color:#8be9fd">int</span>, confNum <span style="color:#8be9fd">int</span>) {
			<span style="color:#ff79c6">defer</span> wg.<span style="color:#50fa7b">Done</span>()
			<span style="color:#ff79c6">for</span> _, server <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> servers {
				shardOwner <span style="color:#ff79c6">:=</span> kv.<span style="color:#50fa7b">make_end</span>(server)
				args <span style="color:#ff79c6">:=</span> EraseDataRequest{
					ConfNum:  confNum,
					ShardIDs: shards,
				}

				reply <span style="color:#ff79c6">:=</span> EraseDataResponse{}
				<span style="color:#ff79c6">if</span> shardOwner.<span style="color:#50fa7b">Call</span>(<span style="color:#f1fa8c">&#34;ShardKV.EraseData&#34;</span>, <span style="color:#ff79c6">&amp;</span>args, <span style="color:#ff79c6">&amp;</span>reply) <span style="color:#ff79c6">&amp;&amp;</span> reply.Err <span style="color:#ff79c6">==</span> OK {
					kv.rf.<span style="color:#50fa7b">Start</span>(<span style="color:#50fa7b">newRaftLogCommand</span>(StopWaiting, req))
					<span style="color:#ff79c6">break</span>
				}
			}
		}(servers, shards, currConfNum)
	}

	kv.mu.<span style="color:#50fa7b">RUnlock</span>()
	wg.<span style="color:#50fa7b">Wait</span>()
}
</code></pre></div><p><code>StopWaiting</code> 日志以及 Shard 的 <code>Waiting</code> 状态存在的用途是标记我是否已经成功在 ex-owner 上删除过期的 Shard。applyStopWaiting 时，在 Config 版本相同时将对应的状态为 <code>Waiting</code> 的 Shard 更新状态为 <code>Serving</code>。</p>
<h4 id="ex-owner">ex-owner</h4>
<p>ex-owner 在 handle <code>EraseData</code> 的RPC时，需要返回数据清理是否完成，这里的处理类似处理客户端请求，不需要进行去重。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>ShardKV) <span style="color:#50fa7b">EraseData</span>(req <span style="color:#ff79c6">*</span>EraseDataRequest, resp <span style="color:#ff79c6">*</span>EraseDataResponse) {
	<span style="color:#ff79c6">defer</span> <span style="color:#50fa7b">DPrintf</span>(<span style="color:#f1fa8c">&#34;[Group %d][Server %d] resp %s for ERASE DATA request %s&#34;</span>, kv.gid, kv.me, resp, req)
	<span style="color:#50fa7b">DPrintf</span>(<span style="color:#f1fa8c">&#34;[Group %d][Server %d] received a ERASE DATA request %s&#34;</span>, kv.gid, kv.me, req)
	index, _, isLeader <span style="color:#ff79c6">:=</span> kv.rf.<span style="color:#50fa7b">Start</span>(<span style="color:#50fa7b">newRaftLogCommand</span>(EraseData, <span style="color:#ff79c6">*</span>req))
	<span style="color:#ff79c6">if</span> !isLeader {
		resp.Err = ErrWrongLeader
		<span style="color:#ff79c6">return</span>
	}

	kv.mu.<span style="color:#50fa7b">Lock</span>()
	ch <span style="color:#ff79c6">:=</span> kv.<span style="color:#50fa7b">getWaitCh</span>(index)
	kv.mu.<span style="color:#50fa7b">Unlock</span>()

	<span style="color:#ff79c6">select</span> {
	<span style="color:#ff79c6">case</span> response <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>ch:
		resp.Err = response.Err

	<span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>time.<span style="color:#50fa7b">NewTimer</span>(<span style="color:#bd93f9">500</span> <span style="color:#ff79c6">*</span> time.Millisecond).C:
		resp.Err = ErrTimeout
	}

	<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
		kv.mu.<span style="color:#50fa7b">Lock</span>()
		kv.<span style="color:#50fa7b">removeWaitCh</span>(index)
		kv.mu.<span style="color:#50fa7b">Unlock</span>()
	}()
}
</code></pre></div><p>apply 时，在版本号相同的情况下将对应的状态为 <code>Erasing</code> 的 Shard 更新为 <code>Invalid</code>，表明对应 Shard 已经成功被清除，清空 kv 和客户端请求去重表。不要忘了返回OK。</p>
<h3 id="提交空日志">提交空日志</h3>
<p>在某个涉及重启的测试中，有时候会出现集群对外出现活锁，无法再服务请求直到超时。我重新打了很多日志，发现这时各个 Group 间的 Config 版本不一致，且版本较低的 Group 的一些 Shard 状态不为 <code>Serving</code> 和 <code>Invalid</code>，这卡着配置更新协程无法拉取最新的 Config。按理说 Config 的版本只能以1为公差递增，其余的 Group 版本高说明也经历过较低的这个版本，应该有向这个 Group 发送过拉取数据和清理数据的RPC来更新 Shard 状态，那么为什么状态并没有被更新呢？</p>
<p>仔细读了很久日志，我发现版本较低的 Group 在推进 Config 到这个版本之后已经正确处理过拉取数据或是清理数据的RPC也更新了 Shard 状态，但在重启后这最后处理的关键RPC对应的日志并没有重新被commit。原来，此时 leader 的 currentTerm 高于这个RPC对应的日志的 term，且这个时间节点客户端碰巧没有向该 Group 组执行读写请求，导致 leader 无法拥有当前任期的 term 的日志，无法将状态机更新到最新。</p>
<p>lab4的最后一部分是我在写完 TinyKV 之后做的，我想到 TinyKV （其实 etcd 也是这么做的）中要求的 leader 在当选时要先提交一条空日志，这样可以保证集群的可用性，于是我也移植了这个特性到 6.824 中。</p>
<p>想起了以前几个月前看过的 <a class="link" href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md#%E7%A9%BA%E6%97%A5%E5%BF%97%E6%A3%80%E6%B5%8B"  target="_blank" rel="noopener"
    >谭新宇</a> 的文章，我知道了不能把这个特性加到 raft 层。于是我也让 leader 在 kv 层周期性的去检测下层是否包含当前 term 的日志，如果没有便 append 一条空日志，这样即可保证新选出的 leader 状态机能够迅速达到最新。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>ShardKV) <span style="color:#50fa7b">proposeEmpty</span>() {
	<span style="color:#ff79c6">if</span> !kv.rf.<span style="color:#50fa7b">HasLogAtCurrentTerm</span>() {
		kv.rf.<span style="color:#50fa7b">Start</span>(<span style="color:#50fa7b">newRaftLogCommand</span>(Empty, <span style="color:#ff79c6">nil</span>))
	}
}
</code></pre></div><h3 id="测试结果-1">测试结果</h3>
<pre tabindex="0"><code class="language-log" data-lang="log">Test: static shards ...
  ... Passed
Test: join then leave ...
  ... Passed
Test: snapshots, join, and leave ...
  ... Passed
Test: servers miss configuration changes...
  ... Passed
Test: concurrent puts and configuration changes...
  ... Passed
Test: more concurrent puts and configuration changes...
  ... Passed
Test: concurrent configuration change and restart...
  ... Passed
Test: unreliable 1...
  ... Passed
Test: unreliable 2...
  ... Passed
Test: unreliable 3...
  ... Passed
Test: shard deletion (challenge 1) ...
  ... Passed
Test: unaffected shard access (challenge 2) ...
  ... Passed
Test: partial migration shard access (challenge 2) ...
  ... Passed
PASS
ok  	6.824/shardkv	108.040s
</code></pre>
</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a>
        
            <a href="/tags/golang/">golang</a>
        
            <a href="/tags/raft/">raft</a>
        
    </section>


    </footer>


    
</article>

    

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/2022/mit-6.824-lab3-raftkv/">
        
        

        <div class="article-details">
            <h2 class="article-title">mit-6.824 lab3: RaftKV</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/2022/mit-6.824-lab2-raft/">
        
        

        <div class="article-details">
            <h2 class="article-title">mit-6.824 lab2: Raft</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/2022/mit-6.824-lab1-mapreduce/">
        
        

        <div class="article-details">
            <h2 class="article-title">mit-6.824 lab1: MapReduce</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/2022/tinykv-project3-multiraftkv/">
        
        

        <div class="article-details">
            <h2 class="article-title">TinyKV Project3: MultiRaftKV</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/2022/tinykv-project2-raftkv/">
        
        

        <div class="article-details">
            <h2 class="article-title">TinyKV Project2: RaftKV</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="ziannchen/ziannchen.github.io"
        issue-term="title"
        
        label="github-light"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy;
        
        2022 -
        
        2023 陈子桉的博客

    </section>

    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener"
                data-version="3.7.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
        <br />
        <span id="busuanzi_container_site_uv" style='display:none'>
            本站总访问量<span id="busuanzi_value_site_uv"></span>次
        </span>
    </section>
</footer>

    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#shardctrler">ShardCtrler</a>
      <ol>
        <li><a href="#client">Client</a></li>
        <li><a href="#server">Server</a>
          <ol>
            <li><a href="#join">Join</a></li>
            <li><a href="#leave">Leave</a></li>
            <li><a href="#move">Move</a></li>
            <li><a href="#query">Query</a></li>
          </ol>
        </li>
        <li><a href="#测试结果">测试结果</a></li>
      </ol>
    </li>
    <li><a href="#shardkv">ShardKV</a>
      <ol>
        <li><a href="#整体结构">整体结构</a></li>
        <li><a href="#客户端请求">客户端请求</a></li>
        <li><a href="#配置更新">配置更新</a></li>
        <li><a href="#数据拉取">数据拉取</a></li>
        <li><a href="#数据清理">数据清理</a>
          <ol>
            <li><a href="#current-owner">current owner</a></li>
            <li><a href="#ex-owner">ex-owner</a></li>
          </ol>
        </li>
        <li><a href="#提交空日志">提交空日志</a></li>
        <li><a href="#测试结果-1">测试结果</a></li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
    </body>
</html>
